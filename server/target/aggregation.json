{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":7534405734956140548,"abi":{"parameters":[{"name":"submitted_models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::MultiClassTrainedModel","fields":[{"name":"models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::TrainedModelPerClass","fields":[{"name":"weights","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}},{"name":"bias","type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}]}}},{"name":"n_samples","type":{"kind":"field"}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9174856516895611197":{"error_kind":"string","string":"Division by zero is not allowed."},"16646908709298801123":{"error_kind":"string","string":"attempt to subtract with underflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+x9ebyN1ff/c8495w7nqgxFmTKVKdzHLJUoNKCBJiqzylDRgAZu0UihookGmihRaECFBhooRRnKUKGiCQ0K/T7b99k/z933OY7ntd/vfZ7jnv3H7cPxWnevtdda+/1ee33OCln/tzqVsazllf7vf0ecvwtZhZf8u1Od/+bpLfsInKy8sGufec5/bbnpDOe/4oN85e9s5+/cK4OoaIO8xg0b9m5Sv7fdwO6eV79Zj6aN8ho26tG4qd3UbtS0Ua/6TRs06N20YdMmzXo0a5LXzG7YoLfdp1GzBn2ktIOX1TOBLNvG6ZgXcewZtuKvg/1difbtlol2yjygTdxBVN9SHK++VTjKVMdDOkteIsUTrPrAfTXAOUOe26ZCbj7ZpjZQFtKmDX3YNNHvctu0oWNTEeBRy8zNgExM7v02Ym64EUFuY6CDsPRu7DIwSC5lr0c4e1Xl6tq1CdhZZeAJuVGSv0pbhMG2QCKdpiS7NnXsahLqAmUVgLrNnP+eKDctlRQf5Ct/d6LFh7pIZ2pm4aDuiVYa6irLbmZxbtnmluJ4zS0+1PWhTEKo2xy4r5NwzlAgiwm5+WSbngiUhbTpyRYH6p5smYe6yMTk3u8pzA2fQpDbAuggLL1buAwMkrvvNsm0Ct4m4L3XbxFHLsLOKDtYHgsge1+yD3vIbCkNIqNffPCL8nfiHxUnHYqQ0cLCZ22ErN59+ghx9qnAfbW0sEFzsBlad9+nKvvWkefebyvmhoVwldzpbr4V7gDt0yxutkfY8DTLO+h1ZJ9mYTMmWu+WcfTWlXu6hYU5MkELuSWsggtd1EAik9bAGPI6f/FBT7uZ3aBZzx5NG/Zs3DSve+PedkPbbtyre17jvEaN7SYNu+f17NPdrm/3btz7f8S5YaO8Pk2b9GrcsE/PvP/zqTiXUoPevbp3b9iwYY9evXo2btKkT89ejexGfRrbDRs1atS9SZMmzZo16Z3XvVn9/wn7n+j6Pfo07tXrf2XpXk3rF64LaMlqCTyPNhb2UnKfSRxf1NK9hcd5ayxb+GMbC39XIGUhgYMbCbZ1/nuGPDSZVMQH+crfnWHt59sh8KEKGS0sfNJdUjLYFXnpfGi9PwTrLVemh/5BDBJd+7U9eFkJC69nAP0F6M820kcOlYJwWwsL0uQ6U25WJtMzLX5B2IcyCQvCZwL3dRbOGQogYSE3n2zTM4CykDY924dN/RSEz7bMF4SBCbNAELZjbrgdQW57oIOw9G7vMjBIbgHEEfWQfSgijg7WoY8SGD4o/K+DhUfQ51jYJCQTqpA7xJHLsgW6/NMBKOtckl3PdezqVYJA21nY4wiXfJQ+bvR8nvPf86UCUlHxQb7yd+db8al5nt7a1yjFcKrzDl5WQop1PvAQDhUqc57FQVEdLcX5Olp8KuNDmYRUpiNwX51wzlAgmwm5+WSbng+UhbTpBT5s6ofKXGCZpzLIxOTe74XMDV9IkHsR0EFYel/kMjBIbgEqg75BkTa9GGhLr/PRacMQS6IQNMy/xMIiB7WPyetVSWP9f+iJkifO/RKL6/dA2YV6mTo7/+0inU5me/GB2ssk/hGpl8lmOegnAeff0oHQei8lvWBFQPuU/WGdgTp3AZ4L0G/speCXIlN9a50tXK3Pvd9LmRsWwtG9CJdaOGe4DKgvy4aXWfi+tcssbiJGJI/LCHIvB+rtvoyFXLVvzSM5a7WVdAHaoatih8Z5PZs26yn6xxo3aJjXqEGTvO55TXs07vU/J6vfI69H90Z5jZv0ymuW16eB+J31/7fBng1696j/v90WvtR1ZKGTs9s3Lcu77GD3zuvdrH6P3j169/mf+eo3btqrceMGPXp279W4V4+efXo17plnN2xmN8n732E06dWgUV4Pu4fdp3vjnrYHgtWVJwEIyAb75HW18PkDeLkXQMDdnP92lwcnA0x8kK/8XXeLVyiOZzjdwFuWIr1MyGTT7eBlJSyOd7dwweZOXLqygInLXpbuZVKX3c3CXtxy9ZCblUmlh8V/AOh28MokfADoAdxXT5wzFEBHQm4+2abdgbKQNu3lw6Z+HgB6WeYfALpbnCDszdxwb4LcPkAHYendx2VgkFxqLxMScVxhpVGCn8XwQeF/V1h4BH2lhU1CMqEKuQMcuSxboB/NrgDKuopk16scu5r6fh7xwHYFUBc3cu7r/Lef3LRUUnyQr/xdP4v7/TyqoroO0PfgZSWkaf0s3AEcKhSmr8VBT/0txfH6W3wK40OZhBSmP3BfA3DOUCCLCbn5ZJv2A8pC2vRqHzb1Q2GutsxTGGRicu/3GuaGryHIvRboICy9r3UZGCSX/f089v8u5d5i30jo6zzP10fCGstjIfQXP9y2Hej8d5A0tIx+8YHa0yL+EaGnZd+hXOE4FCprex2Kbv/FQAsXlIMsbNCY6nMYaHH6HK5jblgIR/c5XIc7QPt6i5vtETa83sK/U15vYTMmWu9BcfTWlXuDhYU5MkELuezv50EikxuBMRTn/Bs07dnb7t6kcWO7R+MGDZp0b9a4YZNGjbt3b9KofqMmPRv36NOwSZOmvZo2a9K0WfceTe1mPXs3Fl/p0yOvQZ8+veJdSuIXavRRqJeSVt/JIOB5DLawl5L7TLx8UdeOEsmhfEj44+A4MaNRWM5T96hzTkjg4EaC8v8oOlQemkwq4oN85e+GWgfu7dANjmstfNJdHvCKvHQ+tN6fG+ppCWqQ6NpvyMHLSlh4HQr0F6A/25+ne1rUZQ+xsCBNrpvkZmUyvcniF4R9KJOwIHwTcF8345yhABIWcvPJNh0KlIW06S0+bOqnIHyLZb4gDEyYBYLwVuaGbyXIHQZ0EJbew1wGBsk9YE/LoYo4hluHPkpg+KDwv+EWHkHnW9gkJBOqkCsTEcsW6PLPcKCs20h2vc2xq8mZUyGgLm7kfLvz3xFy01LJ263CtHyExZ85FQI6wO0HLyshtRqB0/GQoTC3W9gAk2ukpTjeSItPYXwok5DCjATu6w6cMxTIYkJuPtmmI4CykDa904dN/VCYOy3zFAaZmNz7vYu54bsIcu8GOghL77tdBgbJNTJz6m5HJhr6ImGN5bEAsgv1tNzj/PdeaWgZ/eIDtadF/CPWzKmQ41DorI2AYLKnRdgEta97LWzQmOppucfi9LSMYm5YCEf3tIzCHaA92uJme4QNR1v4npbRFjZjovW+N47eunLvs7AwRyZoIZfd04JEJvcDY8jr/MUHOjOnDnApafWhhICy7gWexxgLeym5zySOL2rpLpEcyoeEP46x8HdFCCgLCRzcSHCs899x8tBkUhEf5Ct/N87izZySQYdOuisDXpGXzofW+8sU+Z4WVpDo2m/swctKWHgdB/QXoD/bX6Z7WtRlj8XJKsB0HpCblcn0AYtfEPahTMKC8APAfT2Ic4YCSFjIzSfbdBxQFtKmD/mwqZ+C8EOW+YIwMGEWCMLxzA2PJ8idAHQQlt4TXAYGyaV+T0tQEcfD1qGPEhg+KPzvYQuPoB+xsElIJlQhlzVzStoCXf55GCjrUZJdH7XMzZwS9mDPnHrM+e/jUgGpqPggX/m7xy3uzCmGUz128LISUqzHgYdwqFCZxywOippoKc430eJTGR/KJKQyE4H7moRzhgLZTMjNJ9v0caAspE2f8GFTP1TmCcs8lUEmJvd+n2Ru+EmC3KeADsLS+ymXgUFyqTOnngLKehpoS6/z0WnDkDOnGDB/soVFDuyZUxJ6ouSJc59scf0eKLtQL9MU57/PSKeT2V58oPYyiX/EnDnFcNDVAeff0oHQeq9JkZlTU4A6PwM8F6Df2GvAL0Wm+tamWNi6oVzPMjcshKN7EZ61cM7wHFBflg2fs/B9a89Z3ESMSB7PEeQ+D9TbfRkLueyZU88A7fCCYgedOVGrgTOn0MnZ7ZuWhZ85pSJYXXkSgIBssE/eCxY+fwAv9wIIeKrz32ny4GSAiQ/ylb+bZvEKxfEMpxt4a1OklwmZbKYevKyExfFpFi7YVgOnSQATl7023cukLnuqhb245XpRblYmlRct/gOAD2USPgC8CNzXSzhnKICOhNx8sk2nAWUhbTrdh039PABMt8w/AEyzOEH4MnPDLxPkzgA6CEvvGS4Dg+RSe5mQiGOmlUYJfhbDB4X/zbTwCPoVC5uEZEIVclkzp6Qt0I9mM4GyXiXZ9VXL/MypmUBd3Mh5lvPf2XLTUknxQb7yd7Mt/swppAPMOnhZCWnabAt3AIcKhZllcdDTHEtxvDkWn8L4UCYhhZkD3NdrOGcokMWE3HyyTWcDZSFt+roPm/qhMK9b5ikMMjG59/sGc8NvEOS+CXQQlt5vugwMkmtk5pTYNxL6yvFGSFhjeSyE/uKH27Zznf/Ok4aW0S8+UHtaxD9izZya6TgUeubUTJwse66FC8p5FjZoTPU5zLU4fQ7zmRsWwtF9DvNxB2i/ZXGzPcKGb1n4d8q3LGzGROs9L47eunLftrAwRyZoIZf9/TxIZPIOMIbinL/WzKl4l5L4hTpjdZRLSavvZB7wPBZY2EvJfSZevqhrR4nkUD4k/HGBhZ85pe5R55yQwMGNBBc6/10kD00mFfFBvvJ3iyzezCkZdOikuy7gFXnpfGi916fIzClWkOjab+HBy0pYeF0E9BegP9vr0z0t6rIXWliQJte7crMymb5r8QvCPpRJWBB+F7iv93DOUAAJC7n5ZJsuAspC2vR9Hzb1UxB+3zJfEAYmzAJB+AFzwx8Q5C4GOghL78UuA4PkUmdOBRVxLLEOfZTA8EHhf0ssPIL+0MImIZlQhVzWzClpC3T5ZwlQ1kcku35kmZ85FQbq4kbOHzv//URuWiopPshX/u4Tiz9zKgx0gI8PXlZCavUJTsdDhsJ8bHHQ01JLcbylFp/C+FAmIYVZCtzXMpwzFMhiQm4+2aafAGUhbfqpD5v6oTCfWuYpDDIxuff7GXPDnxHkLgc6CEvv5S4Dg+QamTm13JGPhr5IWGN5LIDsQj0tnzv//UIaWka/+EDtaRH/iDVzKuw4FDprIyCY7Gn5HLivLyxs0Jjqafnc4vS0rGBuWAj3ek/Vkb0Cd4D2Soub7RE2XGnhe1pWWtiMidb7izh668r90sLCHJmghVx2TwsSmXwFjCGv8xcf6MycOsClpNWHEgbK+gJ4Hqss7KXkPpM4vqilu0RyKB8S/rjKwt8VYaAsJHBwI8HVzn/XyEOTSUV8kK/83RqLN3NKBh066X4b8Iq8dD603t+lyPe0sIJE+5seD15WwsLrGqC/AP3Z/i7d06IuezVOVgGms1ZuVibTtRa/IOxDmYQF4bXAfX2Nc4YCSFjIzSfbdA1QFtKm3/iwqZ+C8DeW+YIwMGEWCMJ1zA2vI8hdD3QQlt7rXQYGyaV+T0tQEccG69BHCQwfFP63wcIj6I0WNgnJhCrksmZOSVugyz8bgLK+Jdn1W8vczKkNFn/m1HfOf7+XCkhFxQf5yt99b3FnTm0gONV3By8rIcX6HngIhwqV+c7ioKhNluJ8myw+lfGhTEIqswm4r804ZyiQzYTcfLJNvwfKQtp0iw+b+qEyWyzzVAaZmNz7/YG54R8Icn8EOghL7x9dBgbJpc6cQtr0J6Atvc5Hpw1DzpzaYOFh/lYLixzYM6eEDZAzp8S5b7W4fg+UXaiXaZvz35+l08lsLz5Qe5nEP2LOnNpg4R10c8D5t3QgtN5bUmTm1Dagzj8DzwXoN/aWFJ05tc3C1frc+/2FuWEhHN2L8IuFc4ZfgfqybPirhe9b+9XiJmJE8viVIPc3oN7uy1jIZc+c+hloh98VO+jMidoMnDmFTs5u37Qs/MypDRZ25pQEICAb7JP3u4XPH8DLvQAC3u78d4c8OBlg4oN85e92WLxCcTzD6QbeDynSy4RMNtsPXlbC4vgOCxdsm4HTJICJy/4h3cukLnu7hb245dopNyuTyk6L/wDgQ5mEDwA7gfv6A+cMBdCRkJtPtukOoCykTf/0YVM/DwB/WuYfAHZYnCD8i7nhvwhy/wY6CEvvv10GBsml9jIhEccuK40S/CyGDwr/22XhEfQ/FjYJyYQq5LJmTklboB/NdgFl/Uuy67+W+ZlTu4C6uJHzbue/e+SmpZLig3zl7/ZY/JlTSAfYffCyEtK0PRbuAA4VCrPb4qCnvZbieHstPoXxoUxCCrMXuK//cM5QIIsJuflkm+4BykLaVBjgYG3qh8KIH/mWWQqDTEwFunJDxA0L4Wi54VCwKYzQO+yyMEiukZlTYt9I6CvHGyFhjeWxEPqLH27bZjhGiISsgreU+EDtaRH/iDVzapfjUOiZU7twsuwMYFBGQtigMdXnkBHi9DlEQ8QNC+HoPoco7gDtTHK2R9gwM4R/p8wMYTMmWu9IHL115WaFsDBHJmghl/39PEhkkg2MoTjnrzVzKt6lJH6hzlgd5VLS6juJAM8jB3wpuc/Eyxd17SiRHMqHhD/mhPAzp9Q96pwTEji4kWDMOahcFQnGQoWLZ7kh3swpGXTopLs14BV56XxovbelyMwpVpDo2i928LISFl5zgRce0J/tbemeFnXZMTBIk6uYmmCLhfgFYR/KJCwIFwMG12EhmDMUQMKHhfgF4VygHZA2PZxUED48CQXhXFIQHhEibvgIQkG4eMALwkLv4oSCsOVa6JlTQUUcJYoASmD4oPC/EgQEXZJUrhFyWTOnpC3Q5Z8SQD8vRbJrqZD5mVMZOFkFaPmRzkaPUlHjkR60/KgQt6dFVVTXAY4EUqujwLWrQ4HCHElCT6VVZyxtgML4UCYhhSkNzGJlSBSmjAEKcxTQDkibHk2iMEcngcIcRQrCY0LEDR9DoDBlA05hhN5lCRTGxMypsiFX45YFfPkF2sHyWADZhXpayjlGKK/eUuIDtadF/CPWzCnxO+TBsA5Ft6elHDAoy4MhmKmelnIhTk9LhRBxwxVC+J6WCsDCQ0VytkfYsGII39NSMYTNmGi9y8fRW1fusSQyL+Sye1qQyKQSMIa8zl98oDNz6gCXklYfSgZQVnngeVQGX0ruM4nji1q6y7NB+ZDwx8qEuyIDKAsJHNxIsIpzUFVVJFjFo3hWNcSbOSWDDp10fw14RV46H1rv31Lke1pYQaJrvyrAwmtV4IUH9Gf7t3RPi7rsKqRaVDU1wVYL8QvCPpRJWBCuBgyu40gF4eNC/IJwVaAdkDY9nlQQPj4JBeGqpCCsHiJuuDqhIFwj4AVhoXcNQkHYci3097QEFXHULAIogeGDwv9qEhB0LVK5RshlzZyStkCXf2oC/bw2ya61Q+ZmTgl7sGdOneBsuo6KHE/woOZ1QtyZUwynOgFIseqAa1iHApU5gYSi6qoOWdcAlfGhTEIqUxeYzeqRqEw9A1SmDtAOSJvmkahMXhKoTB1SENoh4oZtApWpH3AqI/SuT6Yy6BsUadMGQPrhdT46bRhy5hQD5jcEIwf2zCkJPVHyxLk3JPs9UHahXqZGzt4bq6hEfKD2Mol/xJw5xXDQHQHn39KB0HrvTJGZU42ASbgxMAkD/cbemaIzpxqFcLU+936bhIgbbhLC9yI0ATpWUzKSQ9iwaQjft9Y0xE3EiOTRlJCIm5EKdkIue+ZUY6CvnqjYQWdO1A7gzKmdKTZzSkWwuvIkAAHZYJ+8Ewn5A3i5F0DAzZ2NnqQi4OYeheKTQrxCcTzD6QbeHynSy4RMNs2BxfGTQrhg2wGcJgFMXPYf6V4mddnNSbXHk9VEc3KI/wDgQ5mEDwAnAwP1FNIDwCkh/gPASUA7IG3agvQA0CIJDwAnkYLw1BBzw4QHgJYBfwAQerckF0LRvUxIxNEqjRJ8LYYPCv9rRUDQp5EovJDLmjklbYF+NGsFjJnTSXY9PWR+5lQrEj1t7Wy0jYoaW3vQ0zYh7vfzqIrqOkBrIE1rAzyAQ4XCtCahp7aqM7Y1QGF8KJOQwrQFOvEZJApzhgEK0wZoB6RNzyRRmDOTQGHakILwrBBxw2cRKMzZAacwQu+zCRTGxMyps8HQV443QsIay2Mh9Bc/3LZt5xihvXpLiQ/Unhbxj1gzp1o5DoWeOYWAYLL/oh0wKNuDIZipPod2IU6fQ4cQccMdQvg+hw64A7TPIWd7hA3PCeHfKc8BZ0y03u3j6K0r91wSmRdy2d/Pg0Qm5wFjKM75a82cincpiV+oM1ZHuZS0+k7aA8/jfPCl5D4TL1/UtaNEcigfEv54fgg/c6oV8NJEAgc3EuzoHFQnFQl29CiedQrxZk7JoEMn3b8DXpGXzofWe1eKzJxiBYmu/ToCC6+dgMkK6M/2rnRPi7rsjqRa1AVqgr0gxC8I+1AmYUH4AmBwXUgqCF8Y4heEOwHtgLTpRaSC8EVJKAh3IgXhxSHihi8mFIQvCXhBWOh9CaEgbLkWeuZUUBFH5yKAEhg+KPyvMwFBdyGVa4Rc1swpaQt0+acz0M8vJdn10pD5mVMRnKwCtPwyZ6OXq6jxMg9afnmI29OiKqrrAJcBqdXl4NrVoUBhLiOhp66qM3Y1QGF8KJOQwnQFZrFuJArTzQCFuRxoB6RNu5MoTPckUJjLSUHYI0TccA8ChekZcAoj9O5JoDAmZk6JfUcsPPRFwhrLYwFkF+pp6eUYobd6S4kP1J4W8Y9YM6eE8cTBoLM2AoLJnpZewKDsDYZgpnpaegHrAO799gkRN9wnhO9p6QMsPFxBzvYIG14Rwve0XBHCZky03r3j6K0r90oSmRdy2T0tSGRyFTCGvM5/3341Zk4d4FLS6kOJAGX1Bp5HX/Cl5D6TOL6opbtEcigfEv7Yl3BXRICykMDBjQT7OQfVX0WC/TyKZ/1DvJlTMujQSXd3wCvy0vnQeu9Jke9pYQWJrv36AQuv/YEXHtCf7T3pnhZ12f1ItagBaoIdEOIXhH0ok7AgPAAYXFeTCsJXh/gF4f5AOyBteg2pIHxNEgrC/UlBeG2IuOFrCQXhgQEvCAu9BxIKwpZrob+nJaiIY1ARQAkMHxT+N4iAoK8jlWuEXNbMKWkLdPlnENDPryfZ9fqQuZlTwh7smVM3OJu+UUWON3hQ8xtD3JlTDKe6AUixbgTXsA4FKnMDCUUNVh1ysAEq40OZhFRmMDCbDSFRmSEGqMyNQDsgbTqURGWGJoHK3EgKwptCxA3fRKAyNwecygi9byZTGfQNirTpLUD64XU+Om0YcuYUA+bfCkYO7JlTEnqi5Ilzv5Xs90DZhXqZhjl7H66iEvGB2ssk/hFz5hTDQa1Swebf0oHQeodKcZwRPXNqGDAJD0cmYZz9bORZmOxbGxbC1frc+80PETecH8L3IuQDHes2MpJD2PC2EL5v7bYQNxEjksdthER8O6lgJ+SyZ04NB/rqCMUOOnOi1OSsIwudnN2+aVn4mVMqgtWVJwEIyAb75I0g5A/g5V4AAY90NnqHioBHehSK7wjxCsXxDKcbeGESEkT3MiGTzUhgcfyOEC7Y3IlLVxYwcdlhcBI8FB4ARpJqj3eqiebOEP8BwIcyCR8A7gQG6l2kB4C7QvwHgDuAdkDa9G7SA8DdSXgAuIMUhPeEiBu+h/AAcG/AHwCE3veSC6HoXiYk4hiVRgm+FsMHhf+NIiDo0SQKL+SyZk5JW6AfzUYBY+Y+kl3vC5mfOTWKRE/vdzY6RkWN93vQ0zEh7vfzqIrqOsD9QJo2BngAhwqFuZ+EnsaqzjjWAIXxoUxCCjMW6MTjSBRmnAEKMwZoB6RNHyBRmAeSQGHGkILwwRBxww8SKMxDAacwQu+HCBTGxMyph8DQV443QsIay2Mh9Bc/3LYd7xhhgnpLiQ/Unhbxj1gzp0Y5DoWeOYWAYLL/YjwwKCeAIZipPofxIU6fw8Mh4oYfDuH7HB7GHaD9CDnbI2z4SAj/TvkIOGOi9Z4QR29duY+SyLyQy/5+HiQyeQwYQ3HOX2vmVLxLSfxCnbE6yqWk1XcyAXgej4MvJfeZePmirh0lkkP5kPDHx0P4mVOjgJcmEji4keBE56AmqUhwokfxbFKIN3NKBh066UYDXpGXzofWO9NQT0tQg0TXfhOBhddJwGQF9Gc7M93Toi57IqkW9YSaYJ8I8QvCPpRJWBB+AhhcT5IKwk+G+AXhSUA7IG36FKkg/FQSCsKTSEH4dIi44acJBeHJAS8IC70nEwrClmuhZ04FFXFMKQIogeGDwv+mEBD0M6RyjZDLmjklbYEu/0wB+vmzJLs+GzI/cyqKk1WAlj/nbPR5FTU+50HLnw9xe1pURXUd4DkgtXoeXLs6FCjMcyT09ILqjC8YoDA+lElIYV4AZrGpJAoz1QCFeR5oB6RNp5EozLQkUJjnSUH4Yoi44RcJFOalgFMYofdLBApjYuaU2HfUIhTNgXawPBZAdqGelumOEV5WbynxgdrTIv4Ra+aUMJ44GHTWRkAw2dMyHRiUL4MhmKmelunAOoB7vzNCxA3PCOF7WmYACw8zydkeYcOZIXxPy8wQNmOi9X45jt66cl8hkXkhl93TgkQmrwJjyOv8xQc6M6cOcClp9aFEgbJeBp7HLPCl5D6TOL6opbtEcigfEv44i3BXRIGykMDBjQRnOwc1R0WCsz2KZ3NCvJlTMujQSTcn4BV56XxovWMp8j0trCDRtd9sYOF1DvDCA/qzHUv3tKjLnk2qRb2mJtjXQvyCsA9lEhaEXwMG1+ukgvDrIX5BeA7QDkibvkEqCL+RhILwHFIQvhkibvhNQkF4bsALwkLvuYSCsOVa6O9pCSrimFcEUALDB4X/zSMg6Pmkco2Qy5o5JW2BLv/MA/r5WyS7vhUyN3NK2IM9c+ptZ9PvqMjxbQ9q/k6IO3OK4VRvAynWO+Aa1qFAZd4moagFqkMuMEBlfCiTkMosAGazhSQqs9AAlXkHaAekTReRqMyiJFCZd0hB+G6IuOF3CVTmvYBTGaH3e2Qqg75BkTZ9H0g/vM5Hpw1DzpxiwPwPwMiBPXNKQk+UPHHuH5D9Hii7UC/TYmfvS1RUIj5Qe5nEP2LOnGI46GEB59/SgdB6H54iM6cWA5PwEmASBvqNfXiKzpxaHMLV+tz7/TBE3PCHIXwvwodAx/qIjOQQNvwohO9b+yjETcSI5PERIRF/TCrYCbnsmVNLgL76iWIHnTlRhwFnTh2eYjOnVASrK08CEJAN9sn7hJA/gJd7AQS81NnoMhUBL/UoFC8L8QrF8QynG3hHpEgvEzLZLAUWx5eFcMF2GHCaBDBx2Ueke5nUZS8l1R4/VRPNpyH+A4APZRI+AHwKDNTPSA8An4X4DwDLgHZA2nQ56QFgeRIeAJaRgvDzEHHDnxMeAL4I+AOA0PsLciEU3cuERBwr0ijB12L4oPC/FQQEvZJE4YVc1swpaQv0o9kKYMx8SbLrlyHzM6dWkOjpV85GV6mo8SsPeroqxP1+HlVRXQf4CkjTVgEP4FChMF+R0NNq1RlXG6AwPpRJSGFWA514DYnCrDFAYVYB7YC06VoShVmbBAqzihSEX4eIG/6aQGG+CTiFEXp/Q6AwJmZOfQOGvnK8ERLWWB4Lob/44bbtOscI69VbSnyg9rSIf8SaObXCcSj0zCkEBJP9F+uAQbkeDMFM9TmsC3H6HDaEiBveEML3OWzAHaC9kZztETbcGMK/U24EZ0y03uvj6K0r91sSmRdy2d/Pg0Qm3wFjKM75a82cincpiV+oM1ZHuZS0+k7WA8/je/Cl5D4TL1/UtaNEcigfEv74fQg/c2oF8NJEAgc3EtzkHNRmFQlu8iiebQ7xZk7JoEMn3ZIBr8hL50PrXSpFZk6xgkTXfpuAhdfNwGQF9Ge7VLqnRV32JlItaouaYLeE+AVhH8okLAhvAQbXD6SC8A8hfkF4M9AOSJv+SCoI/5iEgvBmUhD+FCJu+CdCQXhrwAvCQu+thIKw5VromVNBRRzbigBKYPig8L9tBAT9M6lcI+SyZk5JW6DLP9uAfv4Lya6/hMzPnMrEySpAy391Nvqbihp/9aDlv4W4PS2qoroO8CuQWv0Grl0dChTmVxJ6+l11xt8NUBgfyiSkML8Ds9h2EoXZboDC/Aa0A9KmO0gUZkcSKMxvpCDcGSJueCeBwvwRcAoj9P6DQGFMzJwS+8608NAXCWssjwWQXain5U/HCH+pt5T4QO1pEf+INXNKGE8cDDprIyCY7Gn5ExiUf4EhmKmelj+BdQD3fv8OETf8dwjf0/I3sPCwi5ztETbcFcL3tOwKYTMmWu+/4uitK/cfEpkXctk9LUhk8i8whrzOX3ygM3PqAJeSVh9KJlDWX8Dz2A2+lNxnEscXtXSXSA7lQ8IfdxPuikygLCRwcCPBPc5B7VWR4B6P4tneEG/mlAw6dNItHfCKvHQ+tN5lUuR7WlhBomu/PcDC617ghQf0Z7tMuqdFXfYeUi3qPzXB/hfiF4R9KJOwIPwfkq2EYc5QAAkLuflkm+4F2gFp05APm/opCIfC5gvCe0lBGA4TNyyEo+VmhINdEBZ6Z7hSPkgu9Xtagoo4IuFDHyUwfFD4XySMR9DRMDYJyYQq5LJmTklboMs/EWAeyiTZNTNsbuaUsAd75lSW84fssFUQOWaFC1Pz7DB35hTDqbIO3qkSUqxsoFMdKlQmCxxocuWoDpkT5lMZH8okpDI5wGwWI1GZmAEqkw20A9KmuSQqk5sEKpNNCsJiYeKGixGozGEBpzJC78NcKR8klzpzCmnTw4H0w+t8dNow5MwpBsw/Aowc2DOnJPREyRPnfgTZ74GyC/UyFXf+UEJFJeIDtZdJ/CPmzCmGg5YNOP+WDoTWu1yKzJwqDkzCJYBJGOg3drkUnTlVPIyr9bn3WzJM3HDJML4XoSTQsUqRkRzChqXC+L61UmFuIkYkj1KERHwkmMLIy1jIZc+cKgH01aMUO+jMiSoLnDlVLsVmTqkIVleeBCAgG+yTdxQhfwAv9wIIuLTzhzIqAi4dLlwoLhPmFYrjGU438MqnSC8TMtmUPnhZCYvjZcK4YCsLnCYBTFx2+XQvk7rs0uCLW66j1URzdJj/AOBDmYQPAEcDA/WYMMwZCqCjY8L8B4AyQDsgbVrWh039PACUDZt/AChDCsJyYeKGy4XxcsuTaWOe3tqnd3lXygfJpfYyIRFHhTRK8LUYPij8rwIBQVckUXghlzVzStoiDLZFBWDMHEuy67Fh8zOnKpDoaSXnD5VV1FjJg55WDvNnTiEdoBKQplUGHsChQmEqkdBTFdUZqxigMD6USUhhqgCduCqJwlQ1QGEqA+2AtGk1EoWplgQKU5kUhMeFiRs+jkBhjg84hRF6H+9K+SC5RmZOHQ+GvnK8ERLWWB4Lob/44bZtdecPNdRbSnyg9rSIf8SaOVXBcSj0zCkEBJP9F9WBQVkDDMFM9TlUD3P6HGqGiRuuGcb3OdTEHaBdi5ztETasFca/U9YCZ0y03jXi6K0rtzaJzAu57O/nQSKTE4AxFOf8tWZOxbuUxC/UGaujXEpafSc1gOdRB3wpuc/Eyxd17SiRHMqHhD/WCeNnTlUAXppI4BB2nU1d5w/1VCRY16N4Vi/Mmzklgw6ddI8NeEVeOh9a70opMnOKFSS69qt78LISFl7rAZMV0J/tSumeFnXZdcEgTa48NcHmhfkFYR/KJCwI5wGDyw7DnKEAErbD/IJwPaAdkDat78OmfgrC9cPmC8L1SEHYIEzccIMwXm5DcokgT2/t07uhK+WD5FJnTgUVcTQqAiiB4YPC/xoREHRjUrlGyGXNnJK2CINt0Qjo501Idm0SNj9zKgsnqwAtb+r8oZmKGpt60PJmYf7MqSygMzUFUqtm4NrVoUBhmpLQ04mqM55ogML4UCYhhTkRmMWakyhMcwMUphnQDkibnkSiMCclgcI0IwXhyWHihk8mUJhTAk5hhN6nuFI+SK6RmVNi31kWHvoiYY3lsQCyC/W0tHD+cKp6S4kP1J4W8Y9YM6eE8cTBwL+hDiBL9rS0AAblqWAIZqqnpQWwDuDeb8t4GRqx4ZZhfE9LS2DhoRU52yNs2CqM72lpFcZmTLTep8bRW1fuaSQyL+Sye1qQyOR0YAx5nb/4QGfm1AEuJa0+lCygrFOB59EafCm5zySOL2rpLpEcyoeEP7Ym3BVZQFlI4BB2nU0b5w9tVSTYxqN41jbMmzklgw6ddKsGvCIvnQ+td7UU+Z4WVpDo2q/NwctKWHhtC7zwgP5sV0v3tKjLbgMGaXKdoSbYM8L8grAPZRIWhM8ABteZYZgzFEDCZ4b5BeG2QDsgbXqWD5v6KQifFTZfEG5LCsKzw8QNnx3Gy21HLhHk6a19erdzpXyQXOr3tAQVcbQvAiiB4YPC/9oTEHQHUrlGyGXNnJK2QJd/2gP9/BySXc8Jm5s5JezBnjl1rvOH81TkeK4HNT8vzJ05xXCqc4EU6zxwDetQoDLnklDU+apDnm+AyvhQJiGVOR+YzTqSqExHA1TmPKAdkDbtRKIynZJAZc4jBeEFYeKGLyBQmQsDTmWE3he6Uj5ILnXmFNKmFwHph9f56LRhyJlTDJh/MRg5sGdOSeiJkifO/WKy3wNlF+plusT5Q2cVlYgP1F4m8Y+YM6cYDlo94PxbOhBa7xopMnPqEmAS7gxMwkC/sWuk6MypS8K4Wp97v13CxA13CeN7EboAHetSMpJD2PDSML5v7dIwNxEjkselhER8GZjCyMtYyGXPnOoM9NXLFTvozImqDpw5VSPFZk6pCFZXngQgIBvsk3c5IX8AL/cCCLir84duKgLuGi5cKO4W5hWK4xlON/BqpkgvEzLZdD14WQmL493CuGCrDpwmAUxcds10L5O67K7gi1uu7mqi6R7mPwD4UCbhA0B3YKD2CMOcoQA66hHmPwB0A9oBadOePmzq5wGgZ9j8A0A3UhD2ChM33CuMl9ubTBvz9NY+vXu7Uj5ILrWXCYk4+qRRgq/F8EHhf30ICPoKEoUXclkzp6QtwmBb9AHGzJUku14ZNj9zqg+Jnl7l/KGvihqv8qCnfcP8mVNIB7gKSNP6Ag/gUKEwV5HQUz/VGfsZoDA+lElIYfoBnbg/icL0N0Bh+gLtgLTpABKFGZAECtOXFIRXh4kbvppAYa4JOIURel/jSvkguUZmTl0Dhr5yvBES1lgeC6G/+OG27bXOHwaqt5T4QO1pEf+INXOqj+NQ6JlTCAgm+y+uBQblQDAEM9XncG2Y0+cwKEzc8KAwvs9hEO4A7evI2R5hw+vC+HfK68AZE633wDh668q9nkTmhVz29/MgkckNwBiKc/5aM6fiXUriF+qM1VEuJa2+k4HA87gRfCm5z8TLF3XtKJEcyoeEP94Yxs+c6gO8NJHAIew6m8HOH4aoSHCwR/FsSJg3c0oGHTrpnhDwirx0PrTedVJk5hQrSHTtN/jgZSUsvA4BJiugP9t10j0t6rIHg0GaXEPVBDs0zC8I+1AmYUF4KDC4bgrDnKEAEr4pzC8IDwHaAWnTm33Y1E9B+Oaw+YLwEFIQ3hImbviWMF7ureQSQZ7e2qf3ra6UD5JLnTkVVMQxrAigBIYPCv8bRkDQw0nlGiGXNXNK2iIMtsUwoJ/nk+yaHzY/cyobJ6sALb/N+cPtKmq8zYOW3x7mz5zKBjrTbUBqdTu4dnUoUJjbSOhphOqMIwxQGB/KJKQwI4BZbCSJwow0QGFuB9oBadM7SBTmjiRQmNtJQXhnmLjhOwkU5q6AUxih912ulA+Sa2TmlNh3toWHvkhYY3ksgOxCPS13O3+4R72lxAdqT4v4R6yZU8J44mDQWRsBwWRPy93AoLwHDMFM9bTcDawDuPd7b5i44XvD+J6We4GFh1HkbI+w4agwvqdlVBibMdF63xNHb125o0lkXshl97Qgkcl9wBjyOn/xgc7MqQNcSlp9KNlAWfcAz+N+8KXkPpM4vqilu0RyKB8S/ng/4a7IBspCAoew62zGOH8YqyLBMR7Fs7Fh3swpGXTopJsX8Iq8dD603naKfE8LK0h07Tfm4GUlLLyOBV54QH+27XRPi7rsMWCQJtc4NcGOC/MLwj6USVgQHgcMrgfCMGcogIQfCPMLwmOBdkDa9EEfNvVTEH4wbL4gPJYUhA+FiRt+KIyXO55cIsjTW/v0Hu9K+SC51O9pCSrimFAEUALDB4X/TSAg6IdJ5RohlzVzStoCXf6ZAPTzR0h2fSRsbuaUsAd75tSjzh8eU5Hjox7U/LEwd+YUw6keBVKsx8A1rEOByjxKQlGPqw75uAEq40OZhFTmcWA2m0iiMhMNUJnHgHZA2nQSicpMSgKVeYwUhE+EiRt+gkBlngw4lRF6P+lK+SC51JlTSJs+BaQfXuej04YhZ04xYP7TYOTAnjkloSdKnjj3p8l+D5RdqJdpsvOHKSoqER+ovUziHzFnTjEctGHA+bd0ILTejVJk5tRkYBKeAkzCQL+xG6XozKnJYVytz73fZ8LEDT8TxvciPAN0rGfJSA5hw2fD+L61Z8PcRIxIHs8SEvFzYAojL2Mhlz1zagrQV59X7KAzJ6ohcOZUoxSbOaUiWF15EoCAbLBP3vOE/AG83Asg4BecP0xVEfAL4cKF4qlhXqE4nuF0A69xivQyIZPNCwcvK2FxfGoYF2wNgdMkgInLbpzuZVKX/QL44pZrmppopoX5DwA+lEn4ADANGKgvhmHOUAAdvRjmPwBMBdoBadOXfNjUzwPAS2HzDwBTSUE4PUzc8PQwXu7LZNqYp7f26f2yK+WD5FJ7mZCIY0YaJfhaDB8U/jeDgKBnkii8kMuaOSVtEQbbYgYwZl4h2fWVsPmZUzNI9PRV5w+zVNT4qgc9nRXmz5xCOsCrQJo2C3gAhwqFeZWEnmarzjjbAIXxoUxCCjMb6MRzSBRmjgEKMwtoB6RNXyNRmNeSQGFmkYLw9TBxw68TKMwbAacwQu83XCkfJNfIzKk3wNBXjjdCwhrLYyH0Fz/ctn3T+cNc9ZYSH6g9LeIfsWZOzXAcCj1zCgHBZP/Fm8CgnAuGYKb6HN4Mc/oc5oWJG54Xxvc5zMMdoD2fnO0RNpwfxr9TzgdnTLTec+PorSv3LRKZF3LZ38+DRCZvA2MozvlrzZyKdymJX6gzVke5lLT6TuYCz+Md8KXkPhMvX9S1o0RyKB8S/vhOGD9zagbw0kQCh7DrbBY4f1ioIsEFHsWzhWHezCkZdOik2yzgFXnpfGi9T0yRmVOsING134KDl5Ww8LoQmKyA/myfmO5pUZe9AAzS5FqkJthFYX5B2IcyCQvCi4DB9W4Y5gwFkPC7YX5BeCHQDkibvufDpn4Kwu+FzReEF5KC8P0wccPvh/FyPyCXCPL01j69P3ClfJBc6sypoCKOxUUAJTB8UPjfYgKCXkIq1wi5rJlT0hZhsC0WA/38Q5JdPwybnzmVg5NVgJZ/5PzhYxU1fuRByz8O82dO5QCd6SMgtfoYXLs6FCjMRyT09InqjJ8YoDA+lElIYT4BZrGlJAqz1ACF+RhoB6RNl5EozLIkUJiPSUH4aZi44U8JFOazgFMYofdnrpQPkmtk5pTYd46Fh75IWGN5LIDsQj0ty50/fK7eUuIDtadF/CPWzClhPHEw6KyNgGCyp2U5MCg/B0MwUz0ty4F1APd+vwgTN/xFGN/T8gWw8LCCnO0RNlwRxve0rAhjMyZa78/j6K0rdyWJzAu57J4WJDL5EhhDXucvPtCZOXWAS0mrDyUHKOtz4Hl8Bb6U3GcSxxe1dJdIDuVDwh+/ItwVOUBZSOAQdp3NKucPq1UkuMqjeLY6zJs5JYMOnXRPDnhFXjofWu9TUuR7WlhBomu/VQcvK2HhdTXwwgP6s31KuqdFXfYqMEiTa42aYNeE+QVhH8okLAivAQbX2jDMGQog4bVhfkF4NdAOSJt+7cOmfgrCX4fNF4RXk4LwmzBxw9+E8XLXkUsEeXprn97rXCkfJJf6PS1BRRzriwBKYPig8L/1BAS9gVSuEXJZM6ekLdDln/VAP99IsuvGsLmZU8Ie7JlT3zp/+E5Fjt96UPPvwtyZUwyn+hZIsb4D17AOBSrzLQlFfa865PcGqIwPZRJSme+B2WwTicpsMkBlvgPaAWnTzSQqszkJVOY7UhBuCRM3vIVAZX4IOJURev/gSvkgudSZU0ib/gikH17no9OGIWdOMWD+T2DkwJ45JaEnSp4495/Ifg+UXaiXaavzh20qKhEfqL1M4h8xZ04xHLRlwPm3dCC03q1SZObUVmAS3gZMwkC/sVul6MyprWFcrc+935/DxA3/HMb3IvwMdKxfyEgOYcNfwvi+tV/C3ESMSB6/EBLxr2AKIy9jIZc9c2ob0Fd/U+ygMyeqJXDmVKsUmzmlIlhdeRKAgGywT95vhPwBvNwLIODfnT9sVxHw7+HCheLtYV6hOJ7hGmgG3mkp0suETDa/H7yshMXx7WFcsLUETpMAJi77tHQvk7rs38EXt1w71ESzI8x/APChTMIHgB3AQN0ZhjlDAXS0M8x/ANgOtAPSpn/4sGmi3+W26R9h8w8A20lB+GeYuOE/w3i5f5FpY57e2qf3X66UD5JL7WVCIo6/0yjB12L4oPC/vwkIeheJwgu5rJlT0hZhsC3+BsbMPyS7/hM2P3PqbxI9/df5w24VNf7rQU93h/kzp5AO8C+Qpu0GHsChQmH+JaGnPaoz7jFAYXwok5DC7AE68V4ShdlrgMLsBtoBadP/SBTmvyRQmN2kIPz/zsDYsBCOlhvKCDaFEXqHMvbbFyTXyMwpsW8k9JXjjZCwxvJYCP3FD7dtw84ZZsiol/8VH6g9LeIfsWZO/e04FHrmFAKCyf6LMDAoMzJSs88hnMHpc4hkEDcshKvkTnfzEdwB2lFytkfYMJqBf6eMZmAzJlrvjDh668rNzMDCHJmghVz29/MgkUkWMIbinL/WzKl4l5L4hTpjdZRLSavvJAN4HtngS8l9Jl6+qGtHieRQPiT8MTsDP3NK3aPOOSGBgxsJ5jhOHlORoPggX/m7WAZv5pQMOnTSbRPwirx0PrTebVNk5hQrSHTtl3PwshIWXmPACw/oz3bbdE+LuuwcMEiTK1dNsLkZ/IKwD2USFoRzgcFVLAPmDAWQcLEMfkE4BrQD0qaH+bCpn4LwYRnmC8IxUhAenkHc8OGEgvARAS8IC72PIBSELddCz5wKKuIoXgRQAsMHhf8VJyDoEqRyjZDLmjklbYEu/xQH+nlJkl1LZpifORXDySpAy0s5OfVIFTWW8qDlR2Zwe1pURXUdoBSQWh0Jrl0dChSmFAk9HaU641EGKIwPZRJSmKOAWaw0icKUNkBhjgTaAWnTMiQKUyYJFOZIUhAenUHc8NEECnNMwCmM0PsYAoUxMXNK7Dtm4aEvEtZYHgsgu1BPS1nnDMupt1RZj56Wchm8mVPCeMdkEApPAFmyp6UsMCjLpWhPS1lST0v5DOKGyxN6WsoDCw8VAt7TImxYgdDTUiHgPS3l4uitK7ciicxXNNDTgkQmx5J7WsQHOjOnDnApafWhxICyygHPo5LhnhZd3SWSQ/mQ8MdKhLsiBpSFBA5uJFjZcfIqKhKs7FE8q5LBmzklgw6ddM8KeEVeOh9a77NT5HtaWEGia7/KwMJrFeCFB/Rn++x0T4u67MqkWlRVNcFWNVAQ9qFMwoJwVWBwVSMVhKsZKAhXAdoBadPjSAXh45JQEK5CCsLjM4gbPp5QEK4e8IKw0Ls6oSBsuRb6e1qCijhqFAGUwPBB4X81CAi6JqlcI+SyZk5JW6DLPzWAfl6LZNdaGeZmTgl7sGdO1Xby6gkqcqztQc1PyODOnGI4VW0gxToh3duiLrs2CUXVUR2yjgEq40OZhFSmDjCb1SVRmboGqMwJQDsgbVqPRGXqJYHKnEAKwrwM4obzCFTGDjiVEXrbZCqDvkGRNq1PfpXTacOQM6cYML8BGDmwZ05J6ImSJ869AdnvgbIL9TI1dPbeSEUlDT16mRplcGdOMRy0Q8D5t3QgtN7npMjMqYbAJNwImISBfmOfk6IzpxqS+tYaZxA33JjQi9AY6FhNyEgOYcMmhL61JhncRIxIHk0IibgpqWDXNIM/c6oR0FebKXbQmRPVAThz6pwUmzmlIlhdeRKAgGywT14zQv4AXu4FEPCJzgE1VxHwiR6F4uYZvEJxPMPpBt65KdLLhEw2JwKL480zcMHWAThNApi47HPTvUzqsk8k1R5PUhPNSQYeAHwok/AB4CRgoJ5MegA42cADQHOgHZA2PYX0AHBKEh4AmpOCsEUGccMtCA8Apwb8AWDfQZELoeheJiTiaJlGCb4WwweF/7UkIOhWJAov5LJmTklboB/NWgJj5jSSXU/LMD9zqiWJnp7u5NTWKmo83YOets7gfj+PqqiuA5wOpGmt0z1M6rJPJ6GnNqoztjFAYXwok5DCtAE6cVsShWlrgMK0BtoBadMzSBTmjCRQmNakIDwzg7jhMwkU5qyAUxih91kECmNi5tRZYOgrxxshYY3lsRD6ix9u257tnGE79ZY626OnpV0Gb+ZUS8ehUFnb61B0+y/OBgZlOzAEM9XncDapz6F9BnHD7Ql9Du2B74AdAt7nIGzYgfBO2SHgfQ7t4uit3XBGIvPnZPC/nweJTM4FxlCc89eaORXvUhK/UGesjnIpafWdtAOex3ngS8l9Jl6+qGtHieRQPiT88bwM/MyplsBLEwkc3EjwfMfJO6pI8HyP4lnHDN7MKRl06KTbMeAVeel8aL07pcjMKVaQ6NrvfGDhtSMwWQH92e6U7mlRl30+qRbVSU2wnQwUhH0ok7Ag3AkYXBeQCsIXGCgIdwTaAWnTC0kF4QuTUBDuSArCizKIG76IUBC+OOAFYaH3xRn7DQySS505FVTEcUkRQAkMHxT+dwkBQXcmlWuEXNbMKWkLdPnnEqCfdyHZtUuG+ZlTuThZBWj5pU5OvUxFjZd60PLLMrg9Laqiug5wKZBaXQauXR0KFOZSEnq6XHXGyw1QGB/KJKQwlwOzWFcShelqgMJcBrQD0qbdSBSmWxIozGWkIOyeQdxwdwKF6RFwCiP07kGgMCZmTol951p46IuENZbHAsgu1NPS0znDXuot1dOjp6VXBm/mlDBejwx81kZAMNnT0hMYlL1StKelJ7AO4N5v7wzihnsTelp6AwsPfcjZHmHDPoSelj4Z2IyJ1rtXHL115V5BIvNXGOhpQSKTK8k9LeIDnZlTB7iUtPpQcoGyegHP4yrDPS26ukskh/Ih4Y9XEe6KXKAsJHBwI8G+jpP3U5FgX4/iWb8M3swpGXTopHtRwCvy0vnQel+cIt/TwgoSXfv1BRZe+wEvPKA/2xene1rUZfcl1aL6qwm2v4GCsA9lEhaE+wODawCpIDzAQEG4H9AOSJteTSoIX52EgnA/UhBek0Hc8DWEgvC1AS8IC72vJRSELddCf09LUBHHwCKAEhg+KPxvIAFBDyKVa4Rc1swpaQt0+Wcg0M+vI9n1ugxzM6eEPdgzp6538uoNKnK83oOa35DBnTnFcKrrgRTrhnRvi7rs60ko6kbVIW80QGV8KJOQytwIzGaDSVRmsAEqcwPQDkibDiFRmSFJoDI3kIJwaAZxw0MJVOamgFMZofdNZCqDvkGRNr2Z/Cqn04YhZ04xYP4tYOTAnjkloSdKnjj3W8h+D5RdqJfpVmfvw1RUcqtHL9OwDO7MKYaDdgk4/5YOhNb70hSZOXUrMAkPAyZhoN/Yl6bozKlbSX1rwzOIGx5O6EUYDnSsfDKSQ9gwn9C3lp/BTcSI5JFPSMS3kQp2t2XwZ04NA/rq7YoddOZEdQHOnLo0xWZOqQhWV54EICAb7JN3OyF/AC/3Agh4hHNAI1UEPMKjUDwyg1cojmc47f8PVor0MiGTzQhgcXxkBi7YugCnSQATl31ZupdJXfYIUu3xDjXR3GHgAcCHMgkfAO4ABuqdpAeAOw08AIwE2gFp07tIDwB3JeEBYCQpCO/OIG74bsIDwD0BfwAQet9DLoSie5mQiOPeNErwtRg+KPzvXgKCHkWi8EIua+aUtAX60exeYMyMJtl1dIb5mVP3kujpfU5OvV9Fjfd50NP7M7jfz6MqqusA9wFp2v3pHiZ12feR0NMY1RnHGKAwPpRJSGHGAJ14LInCjDVAYe4H2gFp03EkCjMuCRTmflIQPpBB3PADBArzYMApjND7QQKFMTFz6kEw9JXjjZCwxvJYCP3FD7dtH3LOcLx6Sz3k0dMyPoM3c+pex6FQWdvrUHT7Lx4CBuV4MAQz1efwEKnPYUIGccMTCH0OE4DvgA8HvM9B2PBhwjvlwwHvcxgfR29duY+QyPwjGfzv50Eik0eBMRTn/LVmTsW7lMQv1Bmro1xKWn0n44Hn8Rj4UnKfiZcv6tpRIjmUDwl/fCwDP3PqXuCliQQObiT4uOPkE1Uk+LhH8WxiBm/mlAw6dNLtFvCKvHQ+tN7dU2TmFCtIdO33OLDwOhGYrID+bHdP97Soy36cVIuapCbYSQYKwj6USVgQngQMridIBeEnDBSEJwLtgLTpk6SC8JNJKAhPJAXhUxnEDT9FKAg/HfCCsND76Yz9BgbJpc6cCirimFwEUALDB4X/TSYg6Cmkco2Qy5o5JW2BLv9MBvr5MyS7PpNhfuZUMZysArT8WSenPqeixmc9aPlzGdyeFlVRXQd4FkitngPXrg4FCvMsCT09rzrj8wYojA9lElKY54FZ7AUShXnBAIV5DmgHpE2nkijM1CRQmOdIQTgtg7jhaQQK82LAKYzQ+0UChTExc0rsu5iFh75IWGN5LIDsQj0tLzlnOF29pV7y6GmZnsGbOSWM92IGPmsjIJjsaXkJGJTTU7Sn5SVgHcC935cziBt+mdDT8jKw8DCDnO0RNpxB6GmZkYHNmGi9p8fRW1fuTBKZn2mgpwWJTF4h97SID3RmTh3gUtLqQykGlDUdeB6vGu5p0dVdIjmUDwl/fJVwVxQDykICBzcSnOU4+WwVCc7yKJ7NzuDNnJJBh066vQJekZfOh9a7d4p8TwsrSHTtNwtYeJ0NvPCA/mz3Tve0qMueRapFzVET7BwDBWEfyiQsCM8BBtdrpILwawYKwrOBdkDa9HVSQfj1JBSEZ5OC8I0M4obfIBSE3wx4QVjo/SahIGy5Fvp7WoKKOOYWAZTA8EHhf3MJCHoeqVwj5LJmTklboMs/c4F+Pp9k1/kZ5mZOCXuwZ0695eTVt1Xk+JYHNX87gztziuFUbwEp1tvp3hZ12W+RUNQ7qkO+Y4DK+FAmIZV5B5jNFpCozAIDVOZtoB2QNl1IojILk0Bl3iYF4aIM4oYXEajMuwGnMkLvd8lUBn2DIm36HvlVTqcNQ86cYsD898HIgT1zSkJPlDxx7u+T/R4ou1Av0wfO3herqOQDj16mxRncmVMMB70y4PxbOhBa76tSZObUB8AkvBiYhIF+Y1+VojOnPiD1rS3JIG54CaEXYQnQsT4kIzmEDT8k9K19mMFNxIjk8SEhEX9EKth9lMGfObUY6KsfK3bQmRN1JXDm1FUpNnNKRbC68iQAAdlgn7yPCfkDeLkXQMCfOAe0VEXAn3gUipdm8ArF8QynG3h9U6SXCZlsPgEWx5dm4ILtSuA0CWDisvume5nUZX9Cqj0uUxPNMgMPAD6USfgAsAwYqJ+SHgA+NfAAsBRoB6RNPyM9AHyWhAeApaQgXJ5B3PBywgPA5wF/ABB6f04uhKJ7mZCI44s0SvC1GD4o/O8LAoJeQaLwQi5r5pS0BfrR7AtgzKwk2XVlhvmZU1+Q6OmXTk79SkWNX3rQ068yuN/Poyqq6wBfAmnaV+keJnXZX5LQ0yrVGVcZoDA+lElIYVYBnXg1icKsNkBhvgLaAWnTNSQKsyYJFOYrUhCuzSBueC2BwnwdcAoj9P6aQGFMzJz6Ggx95XgjJKyxPBZCf/HDbdtvnDNcp95S33j0tKzL4M2c+sJxKFTW9joU3f6Lb4BBuQ4MwUz1OXxD6nNYn0Hc8HpCn8N64DvghoD3OQgbbiC8U24IeJ/Dujh668rdSCLzGzP438+DRCbfAmMozvlrzZyKdymJX6gzVke5lLT6TtYBz+M78KXkPhMvX9S1o0RyKB8S/vhdBn7m1BfASxMJHNxI8HvHyTepSPB7j+LZpgzezCkZdOikOyDgFXnpfGi9r06RmVOsING13/fAwusmYLIC+rN9dbqnRV3296Ra1GY1wW42UBD2oUzCgvBmYHBtIRWEtxgoCG8C2gFp0x9IBeEfklAQ3kQKwh8ziBv+kVAQ/ingBWGh908Z+w0MkkudORVUxLG1CKAEhg8K/9tKQNDbSOUaIZc1c0raAl3+2Qr0859Jdv05w/zMqcNwsgrQ8l+cnPqrihp/8aDlv2Zwe1pURXUd4BcgtfoVXLs6FCjMLyT09JvqjL8ZoDA+lElIYX4DZrHfSRTmdwMU5legHZA23U6iMNuTQGF+JQXhjgzihncQKMzOgFMYofdOAoUxMXNK7PswCw99kbDG8lgA2YV6Wv5wzvBP9Zb6w6On5c8M3swpYbydGfisjYBgsqflD2BQ/pmiPS1/AOsA7v3+lUHc8F+Enpa/gIWHv8nZHmHDvwk9LX9nYDMmWu8/4+itK3cXiczvMtDTgkQm/5B7WsQHOjOnDnApafWhHAaU9SfwPP413NOiq7tEcigfEv74L+GuOAwoCwkc3Ehwt+Pke1QkuNujeLYngzdzSgYdOukODHhFXjofWu9BKfI9Lawg0bXfbmDhdQ/wwgP6sz0o3dOiLns3qRa1V02wew0UhH0ok7AgvBcYXP+RCsL/GSgI7wHaAWlTUbE9WJv6KQgLufmW2YLwHlIQhiLEDQvhaLnhSLALwkLvcGS/gUFyqd/TElTEkRE59FECwweF/2VE8Ag6EsEmIZlQhVzWzClpC3T5JwOYh6Iku0Yj5mZOCXuwZ05lOopkSWgtFc2MFKbmWRHuzCmGU2UevFMlpFhZQKc6VKhMJjjQ5MpWHTI7wqcyPpRJSGWygdksJwJzhgLZLCfCpzJZQDsgbRojUZlYEqhMFikIcyPEDecSqEyxgFMZoXcxMpVB36BImx4GpB9e56PThiFnTjFg/uFg5MCeOSWhJ0qeOPfDyX4PlF2ol+kIZ+/FVVQiPlB7mcQ/Ys6cYjjoDQHn39KB0HrfmCIzp44AJuHiwCQM9Bv7xhSdOXVEBFfrc++3RIS44RIRfC9CCaBjlSQjOYQNS0bwfWslI9xEjEgeJQmJuBSpYCfksmdOFQf66pGKHXTmRN0AnDl1Y4rNnFIRrK48CUBANtgn70hC/gBe7gUQ8FHOoZVWEfBRHoXi0hFeoTie4XQDb3CK9DIhk81RwOJ46Qgu2G4ATpMAJi57cLqXSV32UaTaYxk10ZQx8ADgQ5mEDwBlgIF6NOkB4GgDDwClgXZA2vQY0gPAMUl4AChNCsKyEeKGyxIeAMoF/AFA6F0ust/AILnUXiYk4iifRgm+FsMHhf+VJyDoCiQKL+SyZk5JW6AfzcoDY6Yiya4VI+ZnTpUn0dNjHSUqqajxWA96WinC/X4eVVFdBzgWSNMqpXuY1GUfS0JPlVVnrGyAwvhQJiGFqQx04iokClPFAIWpBLQD0qZVSRSmahIoTCVSEFaLEDdcjUBhjgs4hRF6H0egMF59LcC97xtvdBwY+srxRkhYY3kshP7ih9u2xztnWF29pY736GmpHuHNnCrvOBQqa3sdim7/xfHAoKwOhmCm+hyOJ/U51IgQN1yD0OdQA/gOWDPgfQ7ChjUJ75Q1A97nUD2O3rpya5HIfK0I//t5kMikNjCG4py/1sypeJeS+IU6Y3WUS0mr76Q68DxOAF9K7jPx8kVdO0okh/Ih4Y8nRPAzp8oDL00kcHAjwTrOgdVVkWAdj+JZ3Qhv5pQMOnTSvSngFXnpfGi9b06RmVOsING1Xx1g4bUuMFkB/dm+Od3Toi67DqkWVU9NsPUMFIR9KJOwIFwPGFx5pIJwnoGCcF2gHZA2tUkFYTsJBeG6pCCsHyFuuD6hINwg4AVhoXeDyH4Dg+RSZ04FFXE0LAIogeGDwv8aEhB0I1K5RshlzZyStkCXfxoC/bwxya6NI+ZnTh2Ok1WAljdxlGiqosYmHrS8aYTb06IqqusATYDUqmm6p0VddhMSemqmOmMzAxTGhzIJKUwzYBY7kURhTjRAYZoC7YC0aXMShWmeBArTlBSEJ0WIGz6JQGFODjiFEXqfTKAw5J4WseqLfR9uEb6zBmgHy2MBZBfqaTnFOcMW6i11ikdPS4sIb+aUMN7JEXzWRkAw2dNyCjAoW6RoT8sppJ6WUyPMDRN6Wk4FFh5aBrynRdiwJaGnpWXAe1paxNFbV24rEplvZaCnBYlMTiP3tIgPdGZOHeBS0upDORwoqwXwPE433NOiq7tEcigfEv54OuGuOBwoCwkc3EiwtXNgbVQk2NqjeNYmwps5JYMOnXSHBbwiL50PrffwFPmeFlaQ6NqvNbDw2gZ44QH92R6e7mlRl92aVItqqybYtgYKwj6USVgQbgsMrjNIBeEzDBSE2wDtgLTpmaSC8JlJKAi3IQXhWRHihs8iFITPDnhBWOh9dmS/gUFyqd/TElTE0a4IoASGDwr/a0dA0O1J5RohlzVzStoCXf5pB/TzDiS7doiYmzkl7MGeOXWOo8i5KnI8x4OanxvhzpxiONU5QIp1brq3RV32OSQUdZ7qkOcZoDI+lElIZc4DZrPzSVTmfANU5lygHZA27UiiMh2TQGXOJQVhpwhxw50IVOaCgFMZofcFZCqDvkGRNr2Q/Cqn04YhZ04xYP5FYOTAnjkloSdKnjj3i8h+D5RdqJfpYmfvl6io5GKPXqZLItyZUwwHvT3g/Fs6EFrvESkyc+piYBK+BJiEgX5jj0jRmVMXk/rWOkeIG+5M6EXoDHSsLmQkh7BhF0LfWpcINxEjkkcXQiK+lFSwuzTCnzl1CdBXL1PsoDMn6nbgzKkRKTZzSkWwuvIkAAHZYJ+8ywj5A3i5F0DAlzuH1lVFwJd7FIq7RniF4niG0w28kSnSy4RMNpcDi+NdI7hgux04TQKYuOyR6V4mddmXk2qP3dRE083AA4APZRI+AHQDBmp30gNAdwMPAF2BdkDatAfpAaBHEh4AupKCsGeEuOGehAeAXgF/ABB694rsNzBILrWXCYk4eqdRgq/F8EHhf70JCLoPicILuayZU9IW6Eez3sCYuYJk1ysi5mdO9SbR0ysdJa5SUeOVHvT0qoNAPXkaS1VU1wGuBNK0q9I9TOqyryShp76qM/Y1QGF8KJOQwvQFOnE/EoXpZ4DCXAW0A9Km/UkUpn8SKMxVpCAcECFueACBwlwdcAoj9L6aQGG8+lqAe9833uhqMPSV442QsMbyWAj9xQ+3ba9xzvBa9Za6xqOn5doIb+ZUb8eh0DOnEBBM9l9cAwzKa8EQzFSfwzWkPoeBEeKGBxL6HAYC3wEHBbzPQdhwEOGdclDA+xyujaO3rtzrSGT+ugj/+3mQyOR6YAzFOX+tmVPxLiXxC3XG6iiXklbfybXA87gBfCm5z8TLF3XtKJEcyoeEP94Qwc+c6g28NJHAwY0Eb3QObLCKBG/0KJ4NjvBmTsmgQyfduwJekZfOh9b77hSZOcUKEl373QgsvA4GJiugP9t3p3ta1GXfSKpFDVET7BADBWEfyiQsCA8BBtdQUkF4qIGC8GCgHZA2vYlUEL4pCQXhwaQgvDlC3PDNhILwLQEvCAu9b4nsNzBILnXmVFARx61FACUwfFD4360EBD2MVK4Rclkzp6Qt0OWfW4F+Ppxk1+ER8zOnjsXJKkDL8x0lblNRY74HLb8twu1pURXVdYB8ILW6Ld3Toi47n4Sebled8XYDFMaHMgkpzO3ALDaCRGFGGKAwtwHtgLTpSBKFGZkECnMbKQjviBA3fAeBwtwZcAoj9L6TRGEYcONORpGcBMmE3CjJX6Ut0FAXiXTuJtn1bseuJqFucYsDde9xlLhXRRf3eEDdew1A3eJAB7gHCHXvTUNdddn3kG7ZUaozjjIAdX0okxDqjgLeuqNJUHe0Aah7L9AOSJveR4K69yUB6t5LCsL7I8QN30+AumMCDnWF3mMIUFeIZI9XFfsubuGhLxLWWB4LILtQ+/ZY5wzHqbeU+EBt3x4X4Y1XFXLFwaCzNgKCyfbtscCgHAeGYKbat8cCn7zc+30gQtzwAxF8+/YDwDe2B8nZHmHDByP49u0HI9iMidZ7XBy9deU+RCLzQi67fRuJTMYDY8jr/MUHOuNVD3ApabVcFwfKGgc8jwngS8l9JnF8UUt3ieRQPiT8cQLhrigOlIUEDm4k+LBzYI+oSPBhj+LZIxHeeFUZdOikOyrgzSfS+dB6j06RryRkBYmu/R4GFl4fAV54QH+2R6fbt9VlP0yqRT2qJthHDRSEfSiTsCD8KDC4HiMVhB8zUBB+BGgHpE0fJxWEH09CQfgRUhBOjBA3PJFQEJ4U8IKw0HtSZL+BQXKpX0kYVMTxRBFACQwfFP73BAFBP0kq1wi5rPGq0hbo8s8TQD9/imTXpyLmxqsKexzrko/Sx42en3YUmawix6c9qPnkCO9b84WiDKd6GkixJqd7W9RlP01CUVNUh5xigMr4UCYhlZkCzGbPkKjMMwaozGSgHZA2fZZEZZ5NApWZTArC5yLEDT9HoDLPB5zKCL2fJ1MZ9A2KtOkL5Fc5nTYMsSQKQcP8qWDkwB6vKqEnSp4496lkvwfKLtTLNM3Z+4sqKpnm0cv0YoQ3XpXloGMCzr+lA8HbT1JkvOo0YBJ+EZiEgX5jj03R8arTSH1rL0WIG36J0IvwEtCxppORHMKG0wl9a9Mj3ESMSB7TCYn4ZVLB7uUIf7zqi0BfnaHYQWck6hjgeNWxKTZeVUWwuvIkAAHZYJ+8GYT8AbzcCyDgmc6hvaIi4JkeheJXIrxCcTzDaTfkpkgvEzLZzAQWx1+J4IJtDHBwGjBx2ePSvUzqsmeSao+vqonmVQMPAD6USfgA8CowUGeRHgBmGXgAeAVoB6RNZ5MeAGYn4QHgFVIQzokQNzyH8ADwWsAfAITer0X2Gxgkl9rLhEQcr6dRgq/F8EHhf68TEPQbJAov5LLGq0pboB/NXgfGzJsku74ZMT9e9XUSPZ3rKDFPRY1zPejpvAj3+3lURXUdYC6Qps1L9zCpy55LQk/zVWecb4DC+FAmIYWZD3Tit0gU5i0DFGYe0A5Im75NojBvJ4HCzCMF4TsR4obfIVCYBQGnMELvBQQK49XXAtz7vkmeC8DQV07yRMIay2Mh9Bc/3LZd6JzhIvWWWujR07Iowhuv+rrjUOjxqggIJvsvFgKDchEYgpnqc1hI6nN4N0Lc8LuEPod3ge+A7wW8z0HY8D3CO+V7Ae9zWBRHb12575PI/PsR/vfzIJHJB8AYinP+WuNV411K4hfqTJBULiWtvpNFwPNYDL6U3Gfi5Yu6dpRIDuVDwh8XR/DjVV8HXppI4OBGgkucA/tQRYJLPIpnH0Z441Vl0KGT7kMBr8hL50PrPT5FxquygkTXfkuAhdcPgckK6M/2+HRPi7rsJaRa1Edqgv3IQEHYhzIJC8IfAYPrY1JB+GMDBeEPgXZA2vQTUkH4kyQUhD8kBeHSCHHDSwkF4WUBLwgLvZdF9hsYJJc6XjWoiOPTIoASGD4o/O9TAoL+jFSuEXJZ41WlLdDln0+Bfr6cZNflEfPjVUvgZBWg5Z87SnyhosbPPWj5FxFuT4uqqK4DfA6kVl+ke1rUZX9OQk8rVGdcYYDC+FAmIYVZAcxiK0kUZqUBCvMF0A5Im35JojBfJoHCfEEKwq8ixA1/RaAwqwJOYYTeqwgUhtzTIlb9Vc7LHxr6ImGN5bEAsgv1tKx2znCNekut9uhpWRPhzZwSxlsVwWdtBASTPS2rgUG5JkV7WlaTelrWRogbXkvoaVkLLDx8HfCeFmHDrwk9LV8HvKdlTRy9deV+QyLz30T4PS1IZLKO3NMiPtCZOXWAS0mrD6UEUNYa4HmsN9zToqu7RHIoHxL+uJ5wV5QAykICBzcS3OAc2EYVCW7wKJ5tjPBmTsmgQyfdRwJekZfOh9b70RT5nhZWkOjabwOw8LoReOEB/dl+NN3Toi57A6kW9a2aYL81UBD2oUzCgvC3wOD6jlQQ/s5AQXgj0A5Im35PKgh/n4SC8EZSEG6KEDe8iVAQ3hzwgrDQe3Nkv4FBcqnf0xJUxLGlCKAEhg8K/9tCQNA/kMo1Qi5r5pS0Bbr8swXo5z+S7PpjxNzMKWEP9sypnxxFtqrI8ScPar41wp05xXCqn4AUa2u6t0Vd9k8kFLVNdchtBqiMD2USUpltwGz2M4nK/GyAymwF2gFp019IVOaXJFCZraQg/DVC3PCvBCrzW8CpjND7NzKVQd+gSJv+Tn6V02nDkDOnGDB/Oxg5sGdOSeiJkifOfTvZ74GyC/Uy7XD2vlNFJTs8epl2RrgzpxgOOjHg/Fs6EFrvSSkyc2oHMAnvBCZhoN/Yk1J05tQOUt/aHxHihv8g9CL8AXSsP8lIDmHDPwl9a39GuIkYkTz+JCTiv0gFu78i/JlTO4G++rdiB505UROBM6cmpdjMKRXB6sqTAARkg33y/ibkD+DlXgAB73IO7R8VAe/yKBT/E+EViuMZTjfwnkiRXiZkstkFLI7/E8EF20TgNAlg4rKfSPcyqcveRao9/qsmmn8NPAD4UCbhA8C/wEDdTXoA2G3gAeAfoB2QNt1DegDYk4QHgH9IQbg3QtzwXsIDwH8BfwAQev8X2W9gkFxqLxMScYjNuWWlUcKBF8MH/3MyExpBh6IcCi/ksmZOSVugH81UP9eRFSbZNRw1P3PKAuriRs4ZTtKLyBtXKik+yFf+LhLlz5xCOkDGwctKSNMiwAM4VChMRpSDnqKqM0ajfArjQ5mEFCYKdOLMKMwZCmSxzCifwkSAdkDaNMuHTf1QmKyoeQoTIQVhdpS44ewoXm4O0EFYeudE9xsYJNfIzKl9+wZCXzneCAlrLI+F0F/8cNs25pxhrnpLiQ/Unhbxj1gzpyzHodAzpxAQTPZfxIBBmQuGYKb6HGJRTp9DsShxw8Wi+D6HYrgDtA8jZ3uEDQ+L4t8pDwNnTLTeuXH01pV7OInMC7ns7+dBIpMjgDEU5/y1Zk7Fu5TEL9QZq6NcSlp9J7nA8ygOvpTcZ+Lli7p2lEgO5UPCH4tH8TOnLOCliQQObiRYwrmAS6pIsIRH8axklDdzSgYdOuk+HfCKvHQ+tN6TU2TmFCtItL/hE1h4LQlMVkB/tiene1rUZZcg1aJKqQm2lIGCsA9lEhaESwGD60hSQfhIAwXhkkA7IG16FKkgfFQSCsIlSUFYOkrccGlCQbhMwAvCQu8y0f0GBsmlzpwKKuI4ugigBIYPCv87moCgjyGVa4Rc1swpaQt0+edooJ+XJdm1bNT8zKmSOFkFaHk5J+mVV1FjOQ9aXj7K7WlRFdV1gHJAalU+3dOiLrscCT1VUJ2xggEK40OZhBSmAjCLVSRRmIoGKEx5oB2QNj2WRGGOTQKFKU8KwkpR4oYrEShM5YBTGKF3ZQKFIfe0iFVf7LukhYe+SFhjeSyA7EI9LVWcM6yq3lJVPHpaqkZ5M6eE8SpHCYUngCzZ01IFGJRVU7SnpQqpp6ValLjhaoSelmrAwsNxAe9pETY8jtDTclzAe1qqxtFbV+7xJDJ/vIGeFiQyqU7uaREf6MycOsClpNWHUhIoqyrwPGoY7mnR1V0iOZQPCX+sQbgrSgJlIYGDGwnWdC7gWioSrOlRPKsV5c2ckkGHTrrPBrwiL50PrfdzKfI9Lawg0bVfTWDhtRbwwgP6s/1cuqdFXXZNUi2qtppgaxsoCPtQJmFBuDYwuE4gFYRPMFAQrgW0A9KmdUgF4TpJKAjXIgVh3Shxw3UJBeF6AS8IC73rEQrClmtFPWQfiogjrwigBIYPCv/LIyBom1SuEXJZM6ekLdDlnzygn9cn2bV+1NzMKWEP9sypBk7ia6gixwYe1LxhlDtziuFUDYAUq2G6t0VddgMSimqkOmQjA1TGhzIJqUwjYDZrTKIyjQ1QmYZAOyBt2oREZZokgco0JAVh0yhxw00JVKZZwKmM0LsZmcqgb1CkTU8kv8rptGHImVMMmN8cjBzYM6ck9ETJE+fenOz3QNmFeplOcvZ+sopKTvLoZTo5yp05xXDQqQHn39KB0HpPS5GZUycBk/DJwCQM9Bt7WorOnDqJ1Ld2SpS44VMIvQinAB2rRcD71oQNWxD61loEvG/t5Dh668o9lVSwOzXKnzl1MtBXWyp20JkTNRU4c2pais2cUhGsrjwJQEA22CevJSF/AC/3Agi4lXMZnaYi4FYeheLTorxCcTzD6QbeiynSy4RMNq2AxfHTorhgmwqcJgFMXPaL6V4mddmtSLXH09VEc7qBBwAfyiR8ADgdGKitSQ8ArQ08AJwGtAPSpm1IDwBtkvAAcBopCNtGiRtuS3gAOCPgDwBC7zPIhVB0LxMScZyZRgm+FsMHhf+dSUDQZ5EovJDLmjklbYF+NDsTGDNnk+x6dtT8zKkzSfS0nZP02quosZ0HPW0f5X4/j6qorgO0A9K09ukeJnXZ7UjoqYPqjB0MUBgfyiSkMB2ATnwOicKcY4DCtAfaAWnTc0kU5twkUJj2pCA8L0rc8HkECnN+wCmM0Pt8AoUxMXPqfDD0leONkLDG8lgI/cUPt207OmfYSb2lOnr0tHSK8mZOnek4FHrmFAKCyf6LjsCg7ASGYKb6HDqS+hwuiBI3fAGhz+EC4DvghQHvcxA2vJDwTnlhwPscOsXRW1fuRSQyf1GU//08SGRyMTCG4py/1sypeJeS+IU6Y3WUS0mr76QT8DwuAV9K7jPx8kVdO0okh/Ih4Y+XRPEzp84EXppI4OBGgp2dC7iLigQ7exTPukR5M6dk0KGT7ssBr8hL50PrPSNFZk6xgkTXfp2BhdcuwGQF9Gd7RrqnRV12Z1It6lI1wV5qoCDsQ5mEBeFLgcF1GakgfJmBgnAXoB2QNr2cVBC+PAkF4S6kIOwaJW64K6Eg3C3gBWGhd7fofgOD5FJnTgUVcXQvAiiB4YPC/7oTEHQPUrlGyGXNnJK2QJd/ugP9vCfJrj2j5mdOlcLJKkDLezlJr7eKGnt50PLeUW5Pi6qorgP0AlKr3umeFnXZvUjoqY/qjH0MUBgfyiSkMH2AWewKEoW5wgCF6Q20A9KmV5IozJVJoDC9SUF4VZS44asIFKZvwCmM0LsvgcKYmDkl9l3KwkNfJKyxPBZAdqGeln7OGfZXb6l+Hj0t/aO8mVPCeH2j+KyNgGCyp6UfMCj7p2hPSz9ST8uAKHHDAwg9LQOAhYerA97TImx4NaGn5eqA97T0j6O3rtxrSGT+GgM9LUhkci25p0V8oDNz6gCXklYfSimgrP7A8xhouKdFV3eJ5FA+JPxxIOGuKAWUhQQObiQ4yLmAr1OR4CCP4tl1Ud7MKRl06KT7asAr8tL50HrPSpHvaWEFia79BgELr9cBLzygP9uz0j0t6rIHkWpR16sJ9noDBWEfyiQsCF8PDK4bSAXhGwwUhK8D2gFp0xtJBeEbk1AQvo4UhIOjxA0PJhSEhwS8ICz0HkIoCFuuFfWQfSgijqFFACUwfFD431ACgr6JVK4Rclkzp6Qt0OWfoUA/v5lk15uj5mZOCXuwZ07d4iS+W1XkeIsHNb81yp05xXCqW4AU69Z0b4u67FtIKGqY6pDDDFAZH8okpDLDgNlsOInKDDdAZW4F2gFp03wSlclPApW5lRSEt0WJG76NQGVuDziVEXrfTqYy6BsUadMR5Fc5nTYMOXOKAfNHgpEDe+aUhJ4oeeLcR5L9Hii7UC/THc7e71RRyR0evUx3RrkzpxgO+lrA+bd0ILTer6fIzKk7gEn4TmASBvqN/Tr4pehg0ZeuPe8g9a3dFSVu+C5CL8JdQMe6O+B9a8KGdxP61u4OeN/anXH01pV7D6lgd0+UP3PqTqCv3qvYQWdO1GvAmVPo5Oz2TcvCz5xSEayuPAlAQDbYJ+9eQv4AXu4FEPAo5zIarSLgUR6F4tFRXqE4nuF0A++NFOllQiabUcDi+OgoLtheA06TACYu+410L5O67FGk2uN9aqK5z8ADgA9lEj4A3AcM1PtJDwD3G3gAGA20A9KmY0gPAGOS8AAwmhSEY6PEDY8lPACMC/gDgNB7HLkQiu5lQiKOB9Iowddi+KDwvwcICPpBEoUXclkzp6Qt0I9mDwBj5iGSXR+Kmp859QCJno53kt4EFTWO96CnE6Lc7+dRFdV1gPFAmjYh3cOkLns8CT09rDrjwwYojA9lElKYh4FO/AiJwjxigMJMANoBadNHSRTm0SRQmAmkIHwsStzwYwQK83jAKYzQ+3EChTExc+pxMPSV442QsMbyWAj9xQ+3bSc6ZzhJvaUmevS0TIryZk494DgUeuYUAoLJ/ouJwKCcBIZgpvocJpL6HJ6IEjf8BKHP4QngO+CTAe9zEDZ8kvBO+WTA+xwmxdFbV+5TJDL/VJT//TxIZPI0MIbinL/WzKl4l5L4hTpjdZRLSavvZBLwPCaDLyX3mXj5oq4dJZJD+ZDwx8lR/MypB4CXJhI4uJHgFOcCfkZFglM8imfPRHkzp2TQoZPuvIBX5KXzofWenyIzp1hBomu/KcDC6zPAZAX0Z3t+uqdFXfYUUi3qWTXBPmugIOxDmYQF4WeBwfUcqSD8nIGC8DNAOyBt+jypIPx8EgrCz5CC8IUoccMvEArCUwNeEBZ6T43uNzBILnXmVFARx7QigBIYPij8bxoBQb9IKtcIuayZU9IW6PLPNKCfv0Sy60tR8zOnjsTJKkDLpztJ72UVNU73oOUvR7k9Laqiug4wHUitXk73tKjLnk5CTzNUZ5xhgML4UCYhhZkBzGIzSRRmpgEK8zLQDkibvkKiMK8kgcK8TArCV6PEDb9KoDCzAk5hhN6zCBTGxMwpse8jLTz0RcIay2MBZBfqaZntnOEc9Zaa7dHTMifKmzkljDcris/aCAgme1pmA4NyTor2tMwm9bS8FiVu+DVCT8trwMLD6wHvaRE2fJ3Q0/J6wHta5sTRW/v/Ok8i828Y6GlBIpM3yT0t4gOdmVMHuJS0+lCOBMqaAzyPuYZ7WnR1l0gO5UPCH+cS7oojgbKQwMGNBOc5F/B8FQnO8yiezY/yZk7JoEMn3XcCXpGXzofWe0GKfE8LK0i0e6GAhdf5wAsP6M/2gnRPi7rseaRa1Ftqgn3LQEHYhzIJC8JvAYPrbVJB+G0DBeH5QDsgbfoOqSD8ThIKwvNJQbggStzwAkJBeGHAC8JC74WEgrDlWlEP2Yci4lhUBFACwweF/y0iIOh3SeUaIZc1c0raAl3+WQT08/dIdn0vam7mlLAHe+bU+07i+0BFju97UPMPotyZUwyneh9IsT5I97aoy36fhKIWqw652ACV8aFMQiqzGJjNlpCozBIDVOYDoB2QNv2QRGU+TAKV+YAUhB9FiRv+iEBlPg44lRF6f0ymMugbFGnTT8ivcjptGHLmFAPmLwUjB/bMKQk9UfLEuS8l+z1QdqFepmXO3j9VUckyj16mT6PcmVMUHhpw/i0dCK33eykyc2oZMAl/CkzCQL+x30vRmVPLSH1rn0WJG/6M0IvwGdCxlge8b03YcDmhb215wPvWPo2jt67cz0kFu8+j/JlTnwJ99QvFDjpzot4Fzpx6L8VmTqkIVleeBCAgG+yT9wUhfwAv9wIIeIVzGa1UEfAKj0LxyiivUBzPcNq1vxTpZUImmxXA4vjKKC7Y3gVOkwAmLvv9dC+TuuwVpNrjl2qi+dLAA4APZRI+AHwJDNSvSA8AXxl4AFgJtAPSpqtIDwCrkvAAsJIUhKujxA2vJjwArAn4A4DQew25EIruZUIijrVplOBrMXxQ+N9aAoL+mkThhVzWzClpC/Sj2VpgzHxDsus3UfMzp9aS6Ok6J+mtV1HjOg96uj7K/X4eVVFdB1gHpGnr0z1M6rLXkdDTBtUZNxigMD6USUhhNgCdeCOJwmw0QGHWA+2AtOm3JArzbRIozHpSEH4XJW74OwKF+T7gFEbo/T2BwpiYOfU9GPrK8UZIWGN5LIT+4ofbtpucM9ys3lKbPHpaNkd5M6fWOg6FnjmFgGCy/2ITMCg3gyGYqT6HTaQ+hy1R4oa3EPoctgDfAX8IeJ+DsOEPhHfKHwLe57A5jt66cn8kkfkfo/zv50Eik5+AMRTn/LVmTsW7lMQv1Bmro1xKWn0nm4HnsRV8KbnPxMsXde0okRzKh4Q/bo3iZ06tBV6aSODgRoLbnAv4ZxUJbvMonv0c5c2ckkGHTrpLAl6Rl86H1vvDFJk5xQoSXfttAxZefwYmK6A/2x+me1rUZW8j1aJ+URPsLwYKwj6USVgQ/gUYXL+SCsK/GigI/wy0A9Kmv5EKwr8loSD8MykIf48SN/w7oSC8PeAFYaH39uh+A4PkUmdOBRVx7CgCKIHhg8L/dhAQ9E5SuUbIZc2ckrZAl392AP38D5Jd/4ianzl1FE5WAVr+p5P0/lJR458etPyvKLenRVVU1wH+BFKrv9I9Leqy/yShp79VZ/zbAIXxoUxCCvM3MIvtIlGYXQYozF9AOyBt+g+JwvyTBArzFykI/40SN/wvgcLsDjiFEXrvJlAYEzOnxL6PsvDQFwlrLI8FkF2op2WPc4Z71Vtqj0dPy94ob+aUMN7uKD5rIyCY7GnZAwzKvSna07KH1NPyX5S44f8IPS3/Id/jM4Pd07IvS2Tie1rceudpLobee+PorSs3lImFOTJBC7nsnhYkMglnAmPI8vZPnZlTB7iUtPpQjgLK2gs8j4xM7KXkPpM4vqilu0RyKB8S/ihsgL4rjgLKQgIHNxKMOD0K0UyrIOoTH+QrfxfN5M2ckkGHTrqfBLwiL50PrffSFPmeFlaQ6NovcvDgLGHhNQq88ID+bC9N97Soy46AQdr/jxs1wWZm8gvCPpRJWBDOBLKVrEyYMxRAwlmZ/IJwFGgHpE2zfdjUT0E4O9N8QThKCsKcTOKGczLxcmPkEkGe3tqndyxzv4FBcqnf0xJUxJFbBFACwweF/+USEHQxUrlGyGXNnJK2QJd/coF56DCSXQ/LNDdzStiDPXPqcCevHqEix8M9qPkRmdyZUwynOhxIsY4A17AOBSpzOAlFFVcdsrgBKuNDmYRUpjgwm5UgUZkSBqjMEUA7IG1akkRlSiaByhxBCsJSmcQNlyJQmSMDTmWE3keSqQz6BkXa9Cjyq5xOG4acOcWA+aXByIE9c0pCT5Q8ce6lyX4PlF2ol6mMs/ejVVQiPlB7mcQ/Ys6cYjjoZwHn39KB0HovT5GZU2WASfhoYBIG+o29PEVnTpXJxNX63Ps9JpO44WMIvQjHAB2rbMD71oQNyxL61soGvG/t6Dh668otRyrYlcvkz5w6Guir5RU76MyJ+gw4c2p5is2cUhGsrjwJQEA22CevPCF/AC/3Agi4gnMZVVQRcAWPQnHFTF6hOJ7hdAPv8xTpZUImmwrA4njFTFywfQacJgFMXPbn6V4mddkVSLXHY9VEc6yBBwAfyiR8ADgWGKiVSA8AlQw8AFQE2gFp08qkB4DKSXgAqEgKwiqZxA1XITwAVA34A4DQuyq5EIruZUIijmpplOBrMXxQ+F81AoI+jkThhVzWzClpC/SjWTVgzBxPsuvxmeZnTlUj0dPqTk6toaLG6h70tEYm9/t5VEV1HaA6kKbVSPcwqcuuTkJPNVVnrGmAwvhQJiGFqQl04lokClPLAIWpAbQD0qa1SRSmdhIoTA1SEJ6QSdzwCQQKUyfgFEboXYdAYUzMnKoDhr5yvBES1lgeC6G/+OG2bV3nDOupt1Rdj56Wepm8mVPVHIdCz5xCQDDZf1EXGJT1wBDMVJ9DXVKfQ14mccN5hD6HPOA7oB3wPgdhQ5vwTmkHvM+hXhy9deXWJ5H5+pn87+dBIpMGwBiKc/5aM6fiXUriF+qM1VEuJa2+k3rA82gIvpTcZ+Lli7p2lEgO5UPCHxtm4mdOVQNemkjg4EaCjZwLuLGKBBt5FM8aZ/JmTsmgQyfdlQGvyEvnQ+v9ZYrMnGIFia79GgELr42ByQroz/aX6Z4WddmNSLWoJmqCbWKgIOxDmYQF4SbA4GpKKgg3NVAQbgy0A9KmzUgF4WZJKAg3JgXhiZnEDZ9IKAg3D3hBWOjdPHO/gUFyqTOngoo4TioCKIHhg8L/TiIg6JNJ5RohlzVzStoCXf45Cejnp5Dsekqm+ZlTpXGyCtDyFk5OPVVFjS08aPmpmdyeFlVRXQdoAaRWp6Z7WtRltyChp5aqM7Y0QGF8KJOQwrQEZrFWJArTygCFORVoB6RNTyNRmNOSQGFOJQXh6ZnEDZ9OoDCtA05hhN6tCRTGxMwpse/SFuE7a4B2sDwWQHahnpY2zhm2VW+pNh49LW0zeTOnhPFaZ+KzNgKCyZ6WNsCgbJuiPS1tSD0tZ2QSN3wGoaflDGDh4cyA97QIG55J6Gk5M+A9LW3j6K0r9ywSmT/LQE8LEpmcTe5pER/ozJw6wKWk1YdSGiirLfA82hnuadHVXSI5lA8Jf2xHuCtKA2UhgYMbCbZ3LuAOKhJs71E865DJmzklgw6ddFcHvCIvnQ+t95oU+Z4WVpDo2q89sPDaAXjhAf3ZXpPuaVGX3Z5UizpHTbDnGCgI+1AmYUH4HGBwnUsqCJ9roCDcAWgHpE3PIxWEz0tCQbgDKQjPzyRu+HxCQbhjwAvCQu+OhIKw5Vro72kJKuLoVARQAsMHhf91IiDoC0jlGiGXNXNK2gJd/ukE9PMLSXa9MNPczClhD/bMqYucvHqxihwv8qDmF2dyZ04xnOoiIMW6ON3boi77IhKKukR1yEsMUBkfyiSkMpcAs1lnEpXpbIDKXAy0A9KmXUhUpksSqMzFpCC8NJO44UsJVOaygFMZofdlZCqDvkGRNr2c/Cqn04YhZ04xYH5XMHJQ+5i8XpU01v+Hnih54ty7kv0eKLtQL1M3Z+/dVVTSzaOXqXsmd+YUw0G/CTj/lg6E1ntdisyc6gZMwt2BSRjoN/a6FJ051Y3Ut9Yjk7jhHoRehB5Ax+oZ8L41YcOehL61npncRIxIHj0JibgXqWDXK5M/c6o70Fd7K3bQmRP1DXDm1LoUmzmlIlhdeRKAgGywT15vQv4AXu4FEHAf5zK6QkXAfTwKxVdk8grF8QynG3jrU6SXCZls+gCL41dk4oLtG+A0CWDistene5nUZfch1R6vVBPNlQYeAHwok/AB4EpgoF5FegC4ysADwBVAOyBt2pf0ANA3CQ8AV5CCsF8mccP9CA8A/QP+ACD07k8uhKJ7mZCIY0AaJfhaDB8U/jeAgKCvJlF4IZc1c0raAv1oNgAYM9eQ7HpNpvmZUwNI9PRaJ6cOVFHjtR70dGAm9/t5VEV1HeBaIE0bmO5hUpd9LQk9DVKdcZABCuNDmYQUZhDQia8jUZjrDFCYgUA7IG16PYnCXJ8ECjOQFIQ3ZBI3fAOBwtwYcAoj9L6RQGFMzJy6EQx95XgjJKyxPBZCf/HDbdvBzhkOUW+pwR49LUMyeTOnBjgOhZ45hYBgsv9iMDAoh4AhmKk+h8GkPoehmcQNDyX0OQwFvgPeFPA+B2HDmwjvlDcFvM9hSBy9deXeTCLzN2fyv58HiUxuAcZQnPPXmjkV71ISv1BnrI5yKWn1nQwBnset4EvJfSZevqhrR4nkUD4k/PHWTPzMqQHASxMJHNxIcJhzAQ9XkeAwj+LZ8EzezCkZdOik+23AK/LS+dB6f5ciM6dYQaJrv2HAwutwYLIC+rP9XbqnRV32MFItKl9NsPkGCsI+lElYEM4HBtdtpILwbQYKwsOBdkDa9HZSQfj2JBSEh5OCcEQmccMjCAXhkQEvCAu9R2buNzBILnXmVFARxx1FACUwfFD43x0EBH0nqVwj5LJmTklboMs/dwD9/C6SXe/KND9zqgxOVgFafreTU+9RUePdHrT8nkxuT4uqqK4D3A2kVveke1rUZd9NQk/3qs54rwEK40OZhBTmXmAWG0WiMKMMUJh7gHZA2nQ0icKMTgKFuYcUhPdlEjd8H4HC3B9wCiP0vp9AYUzMnBL7LmPhoS8S1lgeCyC7UE/LGOcMx6q31BiPnpaxmbyZU8J492fiszYCgsmeljHAoByboj0tY0g9LeMyiRseR+hpGQcsPDwQ8J4WYcMHCD0tDwS8p2VsHL115T5IIvMPGuhpQSKTh8g9LeIDnZlTB7iUtPpQygBljQWex3jDPS26ukskh/Ih4Y/jCXdFGaAsJHBwI8EJzgX8sIoEJ3gUzx7O5M2ckkGHTrqbA16Rl86H1ntLinxPCytIdO03AVh4fRh44QH92d6S7mlRlz2BVIt6RE2wjxgoCPtQJmFB+BFgcD1KKgg/aqAg/DDQDkibPkYqCD+WhILww6QgfDyTuOHHCQXhiQEvCAu9JxIKwpZrob+nJaiIY1IRQAkMHxT+N4mAoJ8glWuEXNbMKWkLdPlnEtDPnyTZ9clMczOnhD3YM6eecvLq0ypyfMqDmj+dyZ05xXCqp4AU6+l0b4u67KdIKGqy6pCTDVAZH8okpDKTgdlsConKTDFAZZ4G2gFp02dIVOaZJFCZp0lB+GwmccPPEqjMcwGnMkLv58hUBn2DIm36PPlVTqcNQ86cYsD8F8DIQe1j8npV0lj/H3qi5Ilzf4Hs90DZhXqZpjp7n6aikqkevUzTMrkzpxgO+lPA+bd0ILTeW1Nk5tRUYBKeBkzCQL+xt6bozKmppL61FzOJG36R0IvwItCxXgp435qw4UuEvrWXMrmJGJE8XiIk4umkgt30TP7MqWlAX31ZsYPOnKifgDOntqbYzCkVwerKkwAEZIN98l4m5A/g5V4AAc9wLqOZKgKe4VEonpnJKxTHM5xu4G1LkV4mZLKZASyOz8zEBdtPwGkSwMRlb0v3MqnLnkGqPb6iJppXDDwA+FAm4QPAK8BAfZX0APCqgQeAmUA7IG06i/QAMCsJDwAzSUE4O5O44dmEB4A5AX8AEHrPIRdC0b1MSMTxWhol+FoMHxT+9xoBQb9OovBCLmvmlLQF+tHsNWDMvEGy6xuZ5mdOvUaip286OXWuihrf9KCnczO538+jKqrrAG8CadrcdA+Tuuw3SehpnuqM8wxQGB/KJKQw84BOPJ9EYeYboDBzgXZA2vQtEoV5KwkUZi4pCN/OJG74bQKFeSfgFEbo/Q6BwpiYOfUOGPrK8UZIWGN5LIT+4ofbtgucM1yo3lILPHpaFmbyZk695jgUeuYUAoLJ/osFwKBcCIZgpvocFpD6HBZlEje8iNDnsAj4DvhuwPschA3fJbxTvhvwPoeFcfTWlfseicy/l8n/fh4kMnkfGENxzl9r5lS8S0n8Qp2xOsqlpNV3shB4Hh+ALyX3mXj5oq4dJZJD+ZDwxw8y8TOnXgNemkjg4EaCi50LeImKBBd7FM+WZPJmTsmgQyfdXwNekZfOh9b7txSZOcUKEl37LQYWXpcAkxXQn+3f0j0t6rIXk2pRH6oJ9kMDBWEfyiQsCH8IDK6PSAXhjwwUhJcA7YC06cekgvDHSSgILyEF4SeZxA1/QigILw14QVjovTRzv4FBcqkzp4KKOJYVAZTA8EHhf8sICPpTUrlGyGXNnJK2QJd/lgH9/DOSXT/LND9z6micrAK0fLmTUz9XUeNyD1r+eSa3p0VVVNcBlgOp1efpnhZ12ctJ6OkL1Rm/MEBhfCiTkMJ8AcxiK0gUZoUBCvM50A5Im64kUZiVSaAwn5OC8MtM4oa/JFCYrwJOYYTeXxEojImZU2LfR1t46IuENZbHAsgu1NOyyjnD1eottcqjp2V1Jm/mlDDeV5n4rI2AYLKnZRUwKFenaE/LKlJPy5pM4obXEHpa1gALD2sD3tMibLiW0NOyNuA9Lavj6K0r92sSmf/aQE8LEpl8Q+5pER/ozJw6wKWk1YdyNFDWauB5rDPc06Kru0RyKB8S/riOcFccDZSFBA5uJLjeuYA3qEhwvUfxbEMmb+aUDDp00t0R8Iq8dD603jtT5HtaWEGia7/1wMLrBuCFB/Rne2e6p0Vd9npSLWqjmmA3GigI+1AmYUF4IzC4viUVhL81UBDeALQD0qbfkQrC3yWhILyBFITfZxI3/D2hILwp4AVhofcmQkHYci3097QEFXFsLgIogeGDwv82ExD0FlK5RshlzZyStkCXfzYD/fwHkl1/yDQ3c0rYgz1z6kcnr/6kIscfPaj5T5ncmVMMp/oRSLF+Sve2qMv+kYSitqoOudUAlfGhTEIqsxWYzbaRqMw2A1TmJ6AdkDb9mURlfk4ClfmJFIS/ZBI3/AuByvwacCoj9P6VTGXQNyjSpr+RX+V02jDkzCkGzP8djBzUPiavVyWN9f+hJ0qeOPffyX4PlF2ol2m7s/cdKirZ7tHLtCOTO3OK4aB/BZx/SwdC6/13isyc2g5MwjuASRjoN/bfKTpzajupb21nJnHDOwm9CDuBjvVHwPvWhA3/IPSt/ZHJTcSI5PEHIRH/SSrY/ZnJnzm1A+irfyl20JkT9Rdw5tTfKTZzSkWwuvIkAAHZYJ+8vwj5A3i5F0DAfzuX0S4VAf/tUSjelckrFMcznG7g7UqRXiZksvkbWBzflYkLtr+A0ySAicvele5lUpf9N6n2+I+aaP4x8ADgQ5mEDwD/AAP1X9IDwL8GHgB2Ae2AtOlu0gPA7iQ8AOwiBeGeTOKG9xAeAPYG/AFA6L2XXAhF9zIhEcd/aZTgazF8UPjffwQEbWVxKLyQy5o5JW2BfjT7DxgzIZJdQ1nmZ079R6Kn4az/+29GllUQNYoP8pW/y8jiz5xCOkA4C0fTMoDOdKhQmHAWBz1FVGcUf8GmMD6USUhhIlm4fUWzYM5QIItFs/gUJgNoB6RNM33Y1A+FycwyT2EySEGYlUXccFYWXm420EFYemdn7TcwSK6RmVNi30joK8cbIWGN5bEQ+osfbtvmOGcYU28p8YHa0yL+EWvmlDCeOBj0zCkEBJP9FznAoIyBIZipPoecLE6fQ24WccNCOLrPIRd3gHYxcrZH2LBYFv6dslgWNmOi9Y7F0VtX7mEkMi/ksr+fB4lMDgfGUJzz15o5Fe9SEr9QZ6yOcilp9Z3EgOdxBPhSEsud5L1ysI4dJZJzy9NYtvDHI7LwM6f+AzYHIoGDGwkWdy7gEioSLO5RPCuRxZs5JYMOnXR3B7wiL50PrfeeFJk5xQoSXfsVBxZeSwAvPKA/23vSPS3qsouTalEl1QRb0kBB2IcyCQvCJYHBVYpUEC5loCBcAmgHpE2PJBWEj0xCQbgEKQiPyiJu+ChCQbh0wAvCQu/ShIKw5VromVNBRRxligBKYPig8L8yBAR9NKlcI+SyZk5JW6DLP2WAfn4Mya7HZJmfOXUMTlYBWl7WyanlVNRY1oOWlyP3tKiK6jpAWSC1KpfuaVGXXZaEnsqrzljeAIXxoUxCClMemMUqkChMBQMUphzQDkibViRRmIpJoDDlSEF4bBZxw8cSKEylgFMYoXclAoUxMXNK7PsYCw99kbDG8lgA2YV6Wio7Z1hFvaUqe/S0VMnizZwSxquUhc/aCAgme1oqA4OySor2tFQm9bRUzSJuuCqhp6UqsPBQLeA9LcKG1Qg9LdUC3tNSJY7eunKPI5H54wz0tCCRyfHknhbxgc7MqQNcSlp9KMcAZVUBnkd1wz0turpLJIfyIeGP1Ql3xTFAWUjg4EaCNZwLuKaKBGt4FM9qZvFmTsmgg/+/LY8MdkVeOh9a7xBYb7nQ39PCChJd+9UAFl5rIi883LnaSB85VArCNUi1qFpqgq1loCDsQ5mEBeFawOCqTSoI1zZQEK4JtAPSpieQCsInJKEgXJMUhHWyiBuuQygI1w14QVjoXZdQELZcC/09LUFFHPWKAEpg+KDwv3oEBJ1HKtcIuayZU9IW6PJPPaCf2yS72lnmZk4Je7BnTtV38moDFTnW96DmDbK4M6cYTlUfSLEapHtb1GXXJ6GohqpDNjRAZXwok5DKNARms0YkKtPIAJVpALQD0qaNSVSmcRKoTANSEDbJIm64CYHKNA04lRF6NyVTGfQNirRpM/KrnE4bhpw5xYD5J4KRA3vmlISeKHni3E8k+z1QdqFepubO3k9SUUlzj16mk7K4M6cYDhoJOP+WDoTWO0p6wULPnGoOTMInAZMw0G/sKPilyFTfWnNS39rJWcQNn0zoRTgZ6FinBLxvTdjwFELf2ikB71s7KY7eunJbkAp2LbL4M6dOAvrqqYoddOZEqclZRxY6Obt907LwM6dUBKsrTwIQkA32yTuVkD+Al3sBBNzSuYxaqQi4pUehuBWxUBzPcNrf35sivUzIZNMSWBxvlYULNnfi0pUFTFx2ZrqXSV12S1Lt8TQ10Zxm4AHAhzIJHwBOAwbq6aQHgNMNPAC0AtoBadPWpAeA1kl4AGhFCsI2WcQNtyE8ALQN+AOA0LstuRCK7mVCIo4z0ijB12L4oPC/MwgI+kwShRdyWTOnpC3Qj2ZnAGPmLJJdz8oyP3PqDBI9PdvJqe1U1Hi2Bz1tl8X9fh5VUV0HOBtI09qle5jUZZ9NQk/tVWdsb4DC+FAmIYVpD3TiDiQK08EAhWkHtAPSpueQKMw5SaAw7UhBeG4WccPnEijMeQGnMELv8wgUxsTMqfPA0FeON0LCGstjIfQXP9y2Pd85w47qLXW+R09LxyzezKkzHIdCz5xCQDDZf3E+MCg7giGYqT6H80l9Dp2yiBvuROhz6AR8B7wg4H0OwoYXEN4pLwh4n0PHOHrryr2QROYvzOJ/Pw8SmVwEjKE45681cyrepSR+oc5YHeVS0uo76Qg8j4vBl5L7TLx8UdeOEsmhfEj448VZ+JlTZwAvTSRwcCPBS5wLuLOKBC/xKJ51zuLNnJJBh066OQGvyEvnQ+sdM9TTEtQg0bXfJcDCa2dgsgL6sx1L97Soy76EVIvqoibYLgYKwj6USVgQ7gIMrktJBeFLDRSEOwPtgLTpZaSC8GVJKAh3JgXh5VnEDV9OKAh3DXhBWOjdNWu/gUFyqTOngoo4uhUBlMDwQeF/3QgIujupXCPksmZOSVugyz/dgH7eg2TXHlnmZ06VxckqQMt7Ojm1l4oae3rQ8l5Z3J4WVVFdB+gJpFa90j0t6rJ7ktBTb9UZexugMD6USUhhegOzWB8SheljgML0AtoBadMrSBTmiiRQmF6kILwyi7jhKwkU5qqAUxih91UECmNi5pTYd1kLD32RsMbyWADZhXpa+jpn2E+9pfp69LT0y+LNnBLGuyoLn7UREEz2tPQFBmW/FO1p6UvqaemfRdxwf0JPS39g4WFAwHtahA0HEHpaBgS8p6VfHL115V5NIvNXG+hpQSKTa8g9LeIDnZlTB7iUtPpQygJl9QOex7WGe1p0dZdIDuVDwh+vJdwVZYGykMDBjQQHOhfwIBUJDvQong3K4s2ckkGHTrqHBbwiL50PrffhKfI9Lawg0bXfQGDhdRDwwgP6s314uqdFXfZAUi3qOjXBXmegIOxDmYQF4euAwXU9qSB8vYGC8CCgHZA2vYFUEL4hCQXhQaQgvDGLuOEbCQXhwQEvCAu9BxMKwpZrob+nJaiIY0gRQAkMHxT+N4SAoIeSyjVCLmvmlLQFuvwzBOjnN5HselOWuZlTwh7smVM3O3n1FhU53uxBzW/J4s6cYjjVzUCKdUu6t0Vd9s0kFHWr6pC3GqAyPpRJSGVuBWazYSQqM8wAlbkFaAekTYeTqMzwJFCZW0hBmJ9F3HA+gcrcFnAqI/S+jUxl0Dco0qa3k1/ldNow5MwpBswfAUYO7JlTEnqi5IlzH0H2e6DsQr1MI52936GikpEevUx3ZHFnTjEctETA+bd0ILTeJVNk5tRIYBK+A5iEgX5jl0zRmVMjSX1rd2YRN3wnoRfhTqBj3RXwvjVhw7sIfWt3Bbxv7Y44euvKvZtUsLs7iz9z6g6gr96j2EFnTlQJ4Mypkik2c0pFsLryJAAB2WCfvHsI+QN4uRdAwPc6l9EoFQHf61EoHkUsFMcznG7glUqRXiZksrkXWBwflYULthLAaRLAxGWXSvcyqcu+l1R7HK0mmtEGHgB8KJPwAWA0MFDvIz0A3GfgAWAU0A5Im95PegC4PwkPAKNIQTgmi7jhMYQHgLEBfwAQeo8lF0LRvUxIxDEujRJ8LYYPCv8bR0DQD5AovJDLmjklbYF+NBsHjJkHSXZ9MMv8zKlxJHr6kJNTx6uo8SEPejo+i/v9PKqiug7wEJCmjU/3MKnLfoiEniaozjjBAIXxoUxCCjMB6MQPkyjMwwYozHigHZA2fYREYR5JAoUZTwrCR7OIG36UQGEeCziFEXo/RqAwJmZOPQaGvnK8ERLWWB4Lob/44bbt484ZTlRvqcc9elomZvFmTo1zHAo9cwoBwWT/xePAoJwIhmCm+hweJ/U5TMoibngSoc9hEvAd8ImA9zkIGz5BeKd8IuB9DhPj6K0r90kSmX8yi//9PEhk8hQwhuKcv9bMqXiXkviFOmN1lEtJq+9kIvA8ngZfSu4z8fJFXTtKJIfyIeGPT2fhZ06NA16aSODgRoKTnQt4iooEJ3sUz6Zk8WZOyaBDJ93SAa/IS+dD610mRWZOsYJE136TgYXXKcBkBfRnu0y6p0Vd9mRSLeoZNcE+Y6Ag7EOZhAXhZ4DB9SypIPysgYLwFKAdkDZ9jlQQfi4JBeEppCB8Pou44ecJBeEXAl4QFnq/kLXfwCC51JlTQUUcU4sASmD4oPC/qQQEPY1UrhFyWTOnpC3Q5Z+pQD9/kWTXF7PMz5wqh5NVgJa/5OTU6SpqfMmDlk/P4va0qIrqOsBLQGo1Pd3Toi77JRJ6ell1xpcNUBgfyiSkMC8Ds9gMEoWZYYDCTAfaAWnTmSQKMzMJFGY6KQhfySJu+BUChXk14BRG6P0qgcKYmDkl9l3OwkNfJKyxPBZAdqGellnOGc5Wb6lZHj0ts7N4M6eE8V7NwmdtBASTPS2zgEE5O0V7WmaRelrmZBE3PIfQ0zIHWHh4LeA9LcKGrxF6Wl4LeE/L7Dh668p9nUTmXzfQ04JEJm+Qe1rEBzozpw5wKWn1oZQDypoNPI83Dfe06OoukRzKh4Q/vkm4K8oBZSGBgxsJznUu4HkqEpzrUTybl8WbOSWDDp10ywa8Ii+dD05LUuR7WlhBomu/ucDC6zzghQf0Z7tcuqdFXfZcUi1qvppg5xsoCPtQJmFBeD4wuN4iFYTfMlAQnge0A9Kmb5MKwm8noSA8jxSE72QRN/wOoSC8IOAFYaH3AkJB2HIt9Pe0BBVxLCwCKIHhg8L/FhIQ9CJSuUbIZc2ckrZAl38WAv38XZJd380yN3NK2IM9c+o9J6++ryLH9zyo+ftZ3JlTDKd6D0ix3k/3tqjLfo+Eoj5QHfIDA1TGhzIJqcwHwGy2mERlFhugMu8D7YC06RISlVmSBCrzPikIP8wibvhDApX5KOBURuj9EZnKoG9QpE0/Jr/K6bRhyJlTDJj/CRg5sGdOSeiJkifO/ROy3wNlF+plWursfZmKSpZ69DIty+LOnGI4aMWA82/pQGi9j02RmVNLgUl4GTAJA/3GPjZFZ04tJfWtfZpF3PCnhF6ET4GO9VnA+9aEDT8j9K19FvC+tWVx9NaVu5xUsFuexZ85tQzoq58rdtCZE1UROHPq2BSbOaUiWF15EoCAbLBP3ueE/AG83Asg4C+cy2iFioC/8CgUryAWiuMZTjfwKqVILxMy2XwBLI6vyMIFW0XgNAlg4rIrpXuZ1GV/Qao9rlQTzUoDDwA+lEn4ALASGKhfkh4AvjTwALACaAekTb8iPQB8lYQHgBWkIFyVRdzwKsIDwOqAPwAIvVeTC6HoXiYk4liTRgm+FsMHhf+tISDotSQKL+SyZk5JW6AfzdYAY+Zrkl2/zjI/c2oNiZ5+4+TUdSpq/MaDnq7L4n4/j6qorgN8A6Rp69I9TOqyvyGhp/WqM643QGF8KJOQwqwHOvEGEoXZYIDCrAPaAWnTjSQKszEJFGYdKQi/zSJu+FsChfku4BRG6P0dgcKYmDn1HRj6yvFGSFhjeSyE/uKH27bfO2e4Sb2lvvfoadmUxZs5tcZxKPTMKQQEk/0X3wODchMYgpnqc/ie1OewOYu44c2EPofNwHfALQHvcxA23EJ4p9wS8D6HTXH01pX7A4nM/5DF/34eJDL5ERhDcc5fa+ZUvEtJ/EKdsTrKpaTVd7IJeB4/gS8l95l4+aKuHSWSQ/mQ8MefsvAzp9YAL00kcHAjwa3OBbxNRYJbPYpn27J4M6dk0KGTbtWAV+Sl86H1rpYiM6dYQaJrv63Awus2YLIC+rNdLd3Toi57K6kW9bOaYH82UBD2oUzCgvDPwOD6hVQQ/sVAQXgb0A5Im/5KKgj/moSC8DZSEP6WRdzwb4SC8O8BLwgLvX/P2m9gkFzqzKmgIo7tRQAlMHxQ+N92AoLeQSrXCLmsmVPSFujyz3agn+8k2XVnlvmZU+VxsgrQ8j+cnPqnihr/8KDlf2Zxe1pURXUd4A8gtfoz3dOiLvsPEnr6S3XGvwxQGB/KJKQwfwGz2N8kCvO3AQrzJ9AOSJvuIlGYXUmgMH+SgvCfLOKG/yFQmH8DTmGE3v8SKIyJmVNi3+UtPPRFwhrLYwFkF+pp2e2c4R71ltrt0dOyJ4s3c0oY798sfNZGQDDZ07IbGJR7UrSnZTepp2VvFnHDewk9LXuBhYf/At7TImz4H6Gn5b+A97TsiaO39hllc8i8kMvuaUEikxDODpSZUwe4lLT6UMoDZe0Bnkc4G3spuc8kji9q6S6RHMqHhD8KG6DvivJAWUjg4EaCGdn/999ItlUQ9YkP8pW/i2TzZk7JoEMn3eoBr8hL50PrXSNFvqeFFSS69svIxhVeI8ALD+jPdo10T4u67AwwSJMrqibYaDa/IOxDmYQF4Wg2bl+Z2TBnKICEM7P5BeEI0A5Im2b5sKmfgnBWtvmCcIQUhNnZxA1nZ+Pl5gAdhKV3TvZ+A4PkUr+nJaiII1YEUALDB4X/xQgIOpdUrhFyWTOnpC3Q5Z8YMA8VI9m1WLa5mVPCHuyZU4c5efVwFTke5kHND8/mzpxiONVhQIp1OLiGdShQmcNIKOoI1SGPMEBlfCiTkMocAcxmxUlUprgBKnM40A5Im5YgUZkSSaAyh5OCsGQ2ccMlCVSmVMCpjNC7FJnKoG9QpE2PJL/K6bRhyJlTDJh/FBg5sGdOSeiJkifO/Siy3wNlF+plKu3svYyKSsQHai+T+EfMmVMMB60dcP4tHQit9wkpMnOqNDAJlwEmYaDf2Cek6Myp0tm4Wp97v0dnEzd8NKEX4WigYx1DRnIIGx6Tje9bOyabm4gRyeMYQiIuSyrYlc3mz5wqA/TVcooddOZE1QbOnDohxWZOqQhWV54EICAb7JNXjpA/gJd7AQRc3rmMKqgIuLxHobgCsVAcz3C6gVcnRXqZkMmmPLA4XiEbF2y1gdMkgInLrpPuZVKXXZ5Ue6yoJpqKBh4AfCiT8AGgIjBQjyU9ABxr4AGgAtAOSJtWIj0AVErCA0AFUhBWziZuuDLhAaBKwB8AhN5VyIVQdC8TEnFUTaMEX4vhg8L/qhIQdDUShRdyWTOnpC3Qj2ZVgTFzHMmux2WbnzlVlURPj3dyanUVNR7vQU+rZ3O/n0dVVNcBjgfStOrpHiZ12ceT0FMN1RlrGKAwPpRJSGFqAJ24JonC1DRAYaoD7YC0aS0ShamVBApTnRSEtbOJG65NoDAnBJzCCL1PIFAYEzOnTgBDXzneCAlrLI+F0F/8cNu2jnOGddVbqo5HT0vdbN7MqaqOQ6FnTiEgmOy/qAMMyrpgCGaqz6EOqc+hXjZxw/UIfQ71gO+AeQHvcxA2zCO8U+YFvM+hbhy9deXaJDJvZ/O/nweJTOoDYyjO+WvNnIp3KYlfqDNWR7mUtPpO6gLPowH4UnKfiZcv6tpRIjmUDwl/bJCNnzlVFXhpIoGDGwk2dC7gRioSbOhRPGuUzZs5JYMOnXTzAl6Rl84Hv2xSZOYUK0h07dcQWHhthASNwNcqO93Toi67IakW1VhNsI0NFIR9KJOwINwYGFxNSAXhJgYKwo2AdkDatCmpINw0CQXhRqQgbJZN3HAzQkH4xIAXhIXeJ2bvNzBILnXmVFARR/MigBIYPij8rzkBQZ9EKtcIuayZU9IW6PJPc6Cfn0yy68nZ5mdOVcDJKkDLT3FyagsVNZ7iQctbZHN7WlRFdR3gFCC1apHuaVGXfQoJPZ2qOuOpBiiMD2USUphTgVmsJYnCtDRAYVoA7YC0aSsShWmVBArTghSEp2UTN3wagcKcHnAKI/Q+nUBhTMycEvuuYOGhLxLWWB4LILtQT0tr5wzbqLdUa4+eljbZvJlTwninZ+OzNgKCyZ6W1sCgbJOiPS2tST0tbbOJG25L6GlpCyw8nBHwnhZhwzMIPS1nBLynpU0cvXXlnkki82ca6GlBIpOzyD0t4gOdmVMHuJS0+lAqAGW1AZ7H2YZ7WnR1l0gO5UPCH88m3BUVgLKQwMGNBNs5F3B7FQm28yietc/mzZySQYdOug0DXpGXzofWu1GKfE8LK0h07dcOWHhtD7zwgP5sN0r3tKjLbkeqRXVQE2wHAwVhH8okLAh3AAbXOaSC8DkGCsLtgXZA2vRcUkH43CQUhNuTgvC8bOKGzyMUhM8PeEFY6H0+oSBsuRb6e1qCijg6FgGUwPBB4X8dCQi6E6lcI+SyZk5JW6DLPx2Bfn4Bya4XZJubOSXswZ45daGTVy9SkeOFHtT8omzuzCmGU10IpFgXpXtb1GVfSEJRF6sOebEBKuNDmYRU5mJgNruERGUuMUBlLgLaAWnTziQq0zkJVOYiUhB2ySZuuAuBylwacCoj9L6UTGXQNyjSppeRX+V02jDkzCkGzL8cjBzYM6ck9ETJE+d+OdnvgbIL9TJ1dfbeTUUlXT16mbplc2dOMRy0acD5t3QgtN7NUmTmVFdgEu4GTMJAv7GbpejMqa6kvrXu2cQNdyf0InQHOlaPgPetCRv2IPSt9Qh431q3OHrryu1JKtj1zObPnOoG9NVeih105kQ1Bc6capZiM6dUBKsrTwIQkA32yetFyB/Ay70AAu7tXEZ9VATc26NQ3IdYKI5nON3AOzFFepmQyaY3sDjeJxsXbE2B0ySAics+Md3LpC67N6n2eIWaaK4w8ADgQ5mEDwBXAAP1StIDwJUGHgD6AO2AtOlVpAeAq5LwANCHFIR9s4kb7kt4AOgX8AcAoXc/ciEU3cuERBz90yjB12L4oPC//gQEPYBE4YVc1swpaQv0o1l/YMxcTbLr1dnmZ071J9HTa5yceq2KGq/xoKfXZnO/n0dVVNcBrgHStGvTPUzqsq8hoaeBqjMONEBhfCiTkMIMBDrxIBKFGWSAwlwLtAPSpteRKMx1SaAw15KC8Pps4oavJ1CYGwJOYYTeNxAojImZUzeAoa8cb4SENZbHQugvfrhte6NzhoPVW+pGj56Wwdm8mVP9HYdCz5xCQDDZf3EjMCgHgyGYqT6HG0l9DkOyiRseQuhzGAJ8Bxwa8D4HYcOhhHfKoQHvcxgcR29duTeRyPxN2fzv50Eik5uBMRTn/LVmTsW7lMQv1Bmro1xKWn0ng4HncQv4UnKfiZcv6tpRIjmUDwl/vCUbP3OqP/DSRAIHNxK81bmAh6lI8FaP4tmwbN7MKRl06KR7csAr8tL50HqfkiIzp1hBomu/W4GF12HAZAX0Z/uUdE+LuuxbSbWo4WqCHW6gIOxDmYQF4eHA4MonFYTzDRSEhwHtgLTpbaSC8G1JKAgPIwXh7dnEDd9OKAiPCHhBWOg9Inu/gUFyqTOngoo4RhYBlMDwQeF/IwkI+g5SuUbIZc2ckrZAl39GAv38TpJd78w2P3OqIk5WAVp+l5NT71ZR410etPzubG5Pi6qorgPcBaRWd6d7WtRl30VCT/eozniPAQrjQ5mEFOYeYBa7l0Rh7jVAYe4G2gFp01EkCjMqCRTmblIQjs4mbng0gcLcF3AKI/S+j0BhTMycEvuuaOGhLxLWWB4LILtQT8v9zhmOUW+p+z16WsZk82ZOCePdl43P2ggIJnta7gcG5ZgU7Wm5n9TTMjabuOGxhJ6WscDCw7iA97QIG44j9LSMC3hPy5g4euvKfYBE5h8w0NOCRCYPkntaxAc6M6cOcClp9aFUBMoaAzyPhwz3tOjqLpEcyoeEPz5EuCsqAmUhgYMbCY53LuAJKhIc71E8m5DNmzklgw6ddFsGvCIvnQ+td6sU+Z4WVpDo2m88sPA6AXjhAf3ZbpXuaVGXPZ5Ui3pYTbAPGygI+1AmYUH4YWBwPUIqCD9ioCA8AWgHpE0fJRWEH01CQXgCKQgfyyZu+DFCQfjxgBeEhd6PEwrClmuhv6clqIhjYhFACQwfFP43kYCgJ5HKNUIua+aUtAW6/DMR6OdPkOz6RLa5mVPCHuyZU086efUpFTk+6UHNn8rmzpxiONWTQIr1VLq3RV32kyQU9bTqkE8boDI+lElIZZ4GZrPJJCoz2QCVeQpoB6RNp5CozJQkUJmnSEH4TDZxw88QqMyzAacyQu9nyVQGfYMibfoc+VVOpw1DzpxiwPznwciBPXNKQk+UPHHuz5P9Hii7UC/TC87ep6qo5AWPXqap2dyZUwwHbR1w/i0dCK13mxSZOfUCMAlPBSZhoN/YbVJ05tQLpL61adnEDU8j9CJMAzrWiwHvWxM2fJHQt/ZiwPvWpsbRW1fuS6SC3UvZ/JlTU4G+Ol2xg86cqNbAmVNtUmzmlIpgdeVJAAKywT550wn5A3i5F0DALzuX0QwVAb/sUSieQSwUxzOcbuC1TZFeJmSyeRlYHJ+RjQu21sBpEsDEZbdN9zKpy36ZVHucqSaamQYeAHwok/ABYCYwUF8hPQC8YuABYAbQDkibvkp6AHg1CQ8AM0hBOCubuOFZhAeA2QF/ABB6zyYXQtG9TEjEMSeNEnwthg8K/5tDQNCvkSi8kMuaOSVtgX40mwOMmddJdn092/zMqTkkevqGk1PfVFHjGx709M1s7vfzqIrqOsAbQJr2ZrqHSV32GyT0NFd1xrkGKIwPZRJSmLlAJ55HojDzDFCYN4F2QNp0PonCzE8ChXmTFIRvZRM3/BaBwrwdcAoj9H6bQGFMzJx6Gwx95XgjJKyxPBZCf/HDbdt3nDNcoN5S73j0tCzI5s2cmuM4FHrmFAKCyf6Ld4BBuQAMwUz1ObxD6nNYmE3c8EJCn8NC4DvgooD3OQgbLiK8Uy4KeJ/Dgjh668p9l0Tm383mfz8PEpm8B4yhOOevNXMq3qUkfqHOWB3lUtLqO1kAPI/3wZeS+0y8fFHXjhLJoXxI+OP72fiZU3OAlyYSOLiR4AfOBbxYRYIfeBTPFmfzZk7JoEMn3bMCXpGXzofW++wUmTnFChJd+30ALLwuBiYroD/bZ6d7WtRlf0CqRS1RE+wSAwVhH8okLAgvAQbXh6SC8IcGCsKLgXZA2vQjUkH4oyQUhBeTgvDjbOKGPyYUhD8JeEFY6P1J9n4Dg+RSZ04FFXEsLQIogeGDwv+WEhD0MlK5RshlzZyStkCXf5YC/fxTkl0/zTY/c6oeTlYBWv6Zk1OXq6jxMw9avjyb29OiKqrrAJ8BqdXydE+LuuzPSOjpc9UZPzdAYXwok5DCfA7MYl+QKMwXBijMcqAdkDZdQaIwK5JAYZaTgnBlNnHDKwkU5suAUxih95ckCsOAG18SoO5XJEgm5EZJ/iptgYa6SKSzimTXVY5dTULdShYH6q52Ym+Nii5We0DdNQagbiWgA6wGQt01aairLns16ZZdqzrjWgNQdzUQ6q4F3rpfk6Du1wag7hqgHZA2/YYEdb9JAtRdQwrCddnEDa8jQN31AYe6Qu/1BKhrYryq2HclCw99KwHtYHksgOxC7dsbnDPcqN5S4gO1fVv8I9Z41UrW/zkUOmtXAsiS7dsbgEG5EQzBTLVvbwA+ebn3+202ccPfZuPbt78FvrF9R872CBt+l41v3/4uG5sx0XpvjKO3rtzvSWReyGW3byORySZgDHmdv/hAZ7xqJSvupaTVcl0JKGsj8Dw2gy8l95nE8UUt3SWSQ/mQ8MfNhLuiElAWEji4keAW5wL+QUWCWzyKZz9k88arVrL+L+jQSbdDwJtPpPOh9T4nRb6SsBIpSHTttwVYeP0BeOEB/dk+J92+rS57C6kW9aOaYH80UBD2oUzCgvCPwOD6iVQQ/slAQfgHoB2QNt1KKghvTUJB+AdSEG7LJm54G6Eg/HPAC8JC758JBWHLtdBfSVjJCibi+KUIoASGDwr/+4WAoH8llWuEXNZ4VWkLdPnnF6Cf/0ay62/Z5sarCnvUc8lH6eNGz787eXW7ihx/96Dm27N535ovFGU41e9AirU93duiLvt3EoraoTrkDgNUxocyCanMDmA220miMjsNUJntQDsgbfoHicr8kQQqs50UhH9mEzf8J4HK/BVwKiP0/otMZdA3KNKmf5Nf5XTaMMSSKAQN83eBkQN7vKqEnih54tx3kf0eKLtQL9M/zt7/VVHJPx69TP/yeplsloOeH3D+LR0IrXfHFBmv+g8wCf8LTMJAv7E7puh41X9IfWu7s4kb3k3oRdgNdKw9Ae9bEzbcQ+hb2xPwvrV/4+itK3cvqWC3N5s/XvVfoK/+p9hBZyTq+cDxqh1TbLyqimB15UkAArLBPnn/EfIH8HIvgICtHOfMcqyCaFd8kK/8XSiHVyiOZzjdwOuUIr1MyGQjzu4gZSUsjodycMF2PnBwGjBx2Z3SvUzqst0+lKe5CjT0qolG/AX7AcCHMgkfAMI5uH1l5MCcoQA6ysjhPwCEgHZA2jTiw6Z+HgAiOeYfAEKkIIzmEDcczcHLzQQ6CEvvzJz9BgbJpfYyIRFHVhol+FoMHxT+l5WDR9DZ4CQkE6qQyxqvKm2BfjTLAuahHJJdc3LMj1fNAuriRs4xJ6fmqqgx5kFPc3O438+jKqrrADEgTcsFHsChQmFiJPRUTHXGYgYojA9lElKYYkAnPoxEYQ4zQGFygXZA2vRwEoU5PAkUJpcUhEfkEDd8BIHCFA84hRF6FydQGBPjVYuDoa+c5ImENZbHQugvfrhtW8I5w5LqLSU+UHtaxD9ijVfNchwKPV4VAcFk/0UJYFCWBEMwU30OJXI4fQ6lcogbLpWD73MohTtA+0hytkfY8Mgc/DvlkeCMida7ZBy9deUeRSLzQi77+3mQyKQ0MIbinL/WeNV4l5L4hToTJJVLSavvpCTwPMqALyX3mXj5oq4dJZJD+ZDwxzI5+PGqWcBLEwkc3EjwaOcCPkZFgkd7FM+OyeGNV5VBh066FwW8Ii+dD633xSkyXpUVJLr2OxpYeD0GmKyA/mxfnO5pUZd9NKkWVVZNsGUNFIR9KJOwIFwWGFzlSAXhcgYKwscA7YC0aXlSQbh8EgrCx5CCsEIOccMVCAXhigEvCAu9K0qjWhzEgR6vGlTEcWwRQAlCBiNGjiUg6Eqkco2QyxqvKm2BLv8cC/TzyiS7Vs4xP161Mk5WAVpexcmpVVXUWMWDllfN4fa0qIrqOkAVILWqmu5pUZddhYSeqqnOWM0AhfGhTEIKUw2YxY4jUZjjDFCYqkA7IG16PInCHJ8EClOVFITVc4gbrk6gMDUCTmGE3jUIFMbEzCmx78oWHvoiYY3lsQCyC/W01HTOsJZ6S9X06GmplcObOSWMVyMHn7UREEz2tNQEBmWtFO1pqUnqaamdQ9xwbUJPS21g4eGEgPe0CBueQOhpOSHgPS214uitK7cOiczXMdDTgkQmdck9LeIDnZlTB7iUtPpQKgNl1QKeRz3DPS26ukskh/Ih4Y/1CHdFZaAsJHBwI8E85wK2VSSY51E8s3N4M6dk0KGTbpeAV+Sl86H1vjRFvqeFFSS69ssDFl5t4IUH9Gf70nRPi7rsPFItqr6aYOsbKAj7UCZhQbg+MLgakArCDQwUhG2gHZA2bUgqCDdMQkHYJgVhoxzihhsRCsKNA14QFno3JhSELddCf09LUBFHkyKAEhg+KPyvCQFBNyWVa4Rc1swpaQt0+acJ0M+bkezaLMfczClhD/bMqROdvNpcRY4nelDz5jncmVMMpzoRSLGap3tb1GWfSEJRJ6kOeZIBKuNDmYRU5iRgNjuZRGVONkBlmgPtgLTpKSQqc0oSqExzUhC2yCFuuAWBypwacCqz76DIVAZ9gyJt2pL8KqfThiFnTjFgfiswcmDPnJLQEyVPnHsrst8DZRfqZTrN2fvpKio5zaOX6fQc7swphoN2DTj/lg6E1rtbisycOg2YhE8HJmGg39jdUnTm1GmkvrXWOcQNtyb0IrQGOlabgPetCRu2IfSttQl439rpcfTWlduWVLBrm8OfOXU60FfPUOygMyeqK3DmVLcUmzmlIlhdeRKAgGywT94ZhPwBvNwLIOAzncvoLBUBn+lRKD6LWCiOZzjdwOueIr1MyGRzJrA4flYOLti6AqdJABOX3T3dy6Qu+0xS7fFsNdGcbeABwIcyCR8AzgYGajvSA0A7Aw8AZwHtgLRpe9IDQPskPACcRQrCDjnEDXcgPACcE/AHAKH3OeRCKLqXCYk4zk2jBF+L4YPC/84lIOjzSBReyGXNnJK2QD+anQuMmfNJdj0/x/zMqXNJ9LSjk1M7qaixowc97ZTD/X4eVVFdB+gIpGmd0j1M6rI7ktDTBaozXmCAwvhQJiGFuQDoxBeSKMyFBihMJ6AdkDa9iERhLkoChelECsKLc4gbvphAYS4JOIURel9CoDAmZk5dAoa+crwREtZYHguhv/jhtm1n5wy7qLdUZ4+eli45vJlT5zoOhZ45hYBgsv+iMzAou4AhmKk+h86kPodLc4gbvpTQ53Ap8B3wsoD3OQgbXkZ4p7ws4H0OXeLorSv3chKZvzyH//08SGTSFRhDcc5fa+ZUvEtJ/EKdsTrKpaTVd9IFeB7dwJeS+0y8fFHXjhLJoXxI+GO3HPzMqXOBlyYSOLiRYHfnAu6hIsHuHsWzHjm8mVMy6NBJt1fAK/LS+dB6906RmVOsINHuCQIWXnsAkxXQn+3e6Z4WddndSbWonmqC7WmgIOxDmYQF4Z7A4OpFKgj3MlAQ7gG0A9KmvUkF4d5JKAj3IAVhnxzihvsQCsJXBLwgLPS+Ime/gUFyqTOngoo4riwCKIHhg8L/riQg6KtI5RohlzVzStoCXf65EujnfUl27ZtjfuZUFZysArS8n5NT+6uosZ8HLe+fw+1pURXVdYB+QGrVP93Toi67Hwk9DVCdcYABCuNDmYQUZgAwi11NojBXG6Aw/YF2QNr0GhKFuSYJFKY/KQivzSFu+FoChRkYcAoj9B5IoDAmZk6JfVex8NAXCWssjwWQXainZZBzhtept9Qgj56W63J4M6eE8Qbm4LM2AoLJnpZBwKC8LkV7WgaRelquzyFu+HpCT8v1wMLDDQHvaRE2vIHQ03JDwHtaroujt67cG0lk/kYDPS1IZDKY3NMiPtCZOXWAS0mrD6UKUNZ1wPMYYrinRVd3ieRQPiT8cQjhrqgClIUEDm4kONS5gG9SkeBQj+LZTTm8mVMy6NBJ98qAV+Sl88Er8inyPS2sING131Bg4fUm4IUH9Gf7qnRPi7rsoaRa1M1qgr3ZQEHYhzIJC8I3A4PrFlJB+BYDBeGbgHZA2vRWUkH41iQUhG8iBeGwHOKGhxEKwsMDXhAWeg8nFIQt10J/T0tQEUd+EUAJDB8U/pdPQNC3kco1Qi5r5pS0Bbr8kw/089tJdr09x9zMKWEP9sypEU5eHakixxEe1HxkDnfmFMOpRgAp1sh0b4u67BEkFHWH6pB3GKAyPpRJSGXuAGazO0lU5k4DVGYk0A5Im95FojJ3JYHKjCQF4d05xA3fTaAy9wScygi97yFTGfQNirTpveRXOZ02DDlzigHzR4GRA3vmlISeKHni3EeR/R4ou1Av02hn7/epqGS0Ry/TfTncmVMMB+0fcP4tHQit94AUmTk1GpiE7wMmYaDf2ANSdObUaFLf2v05xA3fT+hFuB/oWGMC3rcmbDiG0Lc2JuB9a/fF0VtX7lhSwW5sDn/m1H1AXx2n2EFnTlR/4MypASk2c0pFsLryJAAB2WCfvHGE/AG83Asg4Aecy+hBFQE/4FEofpBYKI5nOO3//1iK9DIhk80DwOL4gzm4YOsPnCYBTFz21eleJnXZD5Bqjw+pieYhAw8APpRJ+ADwEDBQx5MeAMYbeAB4EGgHpE0nkB4AJiThAeBBUhA+nEPc8MOEB4BHAv4AIPR+hFwIRfcyIRHHo2mU4GsxfFD436MEBP0YicILuayZU9IW6EezR4Ex8zjJro/nmJ859SiJnk50cuokFTVO9KCnk3K438+jKqrrABOBNG1SuodJXfZEEnp6QnXGJwxQGB/KJKQwTwCd+EkShXnSAIWZBLQD0qZPkSjMU0mgMJNIQfh0DnHDTxMozOSAUxih92QChTExc2oyGPrK8UZIWGN5LIT+4ofbtlOcM3xGvaWmePS0PJPDmzn1qONQ6JlTCAgm+y+mAIPyGTAEM9XnMIXU5/BsDnHDzxL6HJ4FvgM+F/A+B2HD5wjvlM8FvM/hmTh668p9nkTmn8/hfz8PEpm8AIyhOOevNXMq3qUkfqHOWB3lUtLqO3kGeB5TwZeS+0y8fFHXjhLJoXxI+OPUHPzMqUeBlyYSOLiR4DTnAn5RRYLTPIpnL+bwZk7JoEMn3YEBr8hL50PrPShFZk6xgkTXftOAhdcXgckK6M/2oHRPi7rsaaRa1Etqgn3JQEHYhzIJC8IvAYNrOqkgPN1AQfhFoB2QNn2ZVBB+OQkF4RdJQTgjh7jhGYSC8MyAF4SF3jNz9hsYJJc6cyqoiOOVIoASGD4o/O8VAoJ+lVSuEXJZM6ekLdDln1eAfj6LZNdZOeZnTlXFySpAy2c7OXWOihpne9DyOTncnhZVUV0HmA2kVnPSPS3qsmeT0NNrqjO+ZoDC+FAmIYV5DZjFXidRmNcNUJg5QDsgbfoGicK8kQQKM4cUhG/mEDf8JoHCzA04hRF6zyVQGBMzp8S+q1p46IuENZbHAsgu1NMyzznD+eotNc+jp2V+Dm/mlDDe3Bx81kZAMNnTMg8YlPNTtKdlHqmn5a0c4obfIvS0vAUsPLwd8J4WYcO3CT0tbwe8p2V+HL115b5DIvPvGOhpQSKTBeSeFvGBzsypA1xKWn0oVYGy5gPPY6HhnhZd3SWSQ/mQ8MeFhLuiKlAWEji4keAi5wJ+V0WCizyKZ+/m8GZOyaBDJ90bAl6Rl86H1vvGFPmeFlaQ6NpvEbDw+i7wwgP6s31juqdFXfYiUi3qPTXBvmegIOxDmYQF4feAwfU+qSD8voGC8LtAOyBt+gGpIPxBEgrC75KCcHEOccOLCQXhJQEvCAu9lxAKwpZrob+nJaiI48MigBIYPij870MCgv6IVK4Rclkzp6Qt0OWfD4F+/jHJrh/nmJs5JezBnjn1iZNXl6rI8RMPar40hztziuFUnwAp1tJ0b4u67E9IKGqZ6pDLDFAZH8okpDLLgNnsUxKV+dQAlVkKtAPSpp+RqMxnSaAyS0lBuDyHuOHlBCrzecCpjND7czKVQd+gSJt+QX6V02nDkDOnGDB/BRg5sGdOSeiJkifOfQXZ74GyC/UyrXT2/qWKSlZ69DJ9mcOdOcVw0KEB59/SgdB635QiM6dWApPwl8AkDPQb+6YUnTm1ktS39lUOccNfEXoRvgI61qqA960JG64i9K2tCnjf2pdx9NaVu5pUsFudw5859SXQV9codtCZEzUUOHPqphSbOaUiWF15EoCAbLBP3hpC/gBe7gUQ8FrnMvpaRcBrPQrFXxMLxfEMpxt4N6dILxMy2awFFse/zsEF21DgNAlg4rJvTvcyqcteS6o9fqMmmm8MPAD4UCbhA8A3wEBdR3oAWGfgAeBroB2QNl1PegBYn4QHgK9JQbghh7jhDYQHgI0BfwAQem8kF0LRvUxIxPFtGiX4WgwfFP73LQFBf0ei8EIua+aUtAX60exbYMx8T7Lr9znmZ059S6Knm5ycullFjZs86OnmHO7386iK6jrAJiBN25zuYVKXvYmEnraozrjFAIXxoUxCCrMF6MQ/kCjMDwYozGagHZA2/ZFEYX5MAoXZTArCn3KIG/6JQGG2BpzCCL23EiiMiZlTW8HQV443QsIay2Mh9Bc/3Lbd5pzhz+ottc2jp+XnHN7MqW8dh0LPnEJAMNl/sQ0YlD+DIZipPodtpD6HX3KIG/6F0OfwC/Ad8NeA9zkIG/5KeKf8NeB9Dj/H0VtX7m8kMv9bDv/7eZDI5HdgDMU5f62ZU/EuJfELdcbqKJeSVt/Jz8Dz2A6+lNxn4uWLunaUSA7lQ8Ift+fgZ059C7w0kcDBjQR3OBfwThUJ7vAonu3M4c2ckkGHTrrDAl6Rl86H1nt4isycYgWJrv12AAuvO4HJCujP9vB0T4u67B2kWtQfaoL9w0BB2IcyCQvCfwCD609SQfhPAwXhnUA7IG36F6kg/FcSCsI7SUH4dw5xw38TCsK7Al4QFnrvytlvYJBc6sypoCKOf4oASmD4oPC/fwgI+l9SuUbIZc2ckrZAl3/+Afr5bpJdd+eYnzlVDSerAC3f4+TUvSpq3ONBy/fmcHtaVEV1HWAPkFrtTfe0qMveQ0JP/6nO+J8BCuNDmYQU5j8kmopxKIyQm0+26V6gHZA2DfmwqR8KE4qZpzB7SUEYjhE3LISj5WbEgk1hhN4Zsf0GBsk1MnNK7LuahYe+SFhjeSyA7EI9LRHnDKMxq+AtJT5Qe1rEP2LNnBLGEweDztoICCZ7WiLAoIzGsEFjqqclEuP0tGTGiBsWwtE9LZm4A7SzyNkeYcOsGL6nJSuGzZhovaNx9NaVmx3DwhyZoIVcdk8LEpnkAGPI6/zFBzozpw5wKWn1oVQDyooCzyMGvpTcZxLHF7V0l0gO5UPCH2OEu6IaUBYSOLiRYK5zARdTkWBurHDxrFiMN3NKBh066d4e8Iq8dD603iNS5HtaWEGia7/cg5eVsPBaDHjhAf3ZHpHuaVGXnQsGaXIdpibYw2L8grAPZRIWhA8DBtfhpILw4QYKwsWAdkDa9AhSQfiIJBSEi5GCsHiMuOHihIJwiYAXhIXeJQgFYcu10N/TElTEUbIIoASGDwr/K0lA0KVI5RohlzVzStoCXf4pCfTzI0l2PTJmbuaUsAd75tRRTl4trSLHozyoeekYd+YUw6mOAlKs0uAa1qFAZY4ioagyqkOWMUBlfCiTkMqUAWazo0lU5mgDVKY00A5Imx5DojLHJIHKlCYFYdkYccNlCVSmXMCpjNC7HJnKoG9QpE3Lk1/ldNow5MwpBsyvAEYO7JlTEnqi5Ilzr0D2e6DsQr1MFZ29H6uikooevUzHxrgzpxgOemfA+bd0ILTed6XIzKmKwCR8LDAJA/3GvitFZ05VJPWtVYoRN1yJ0ItQCehYlQPetyZsWJnQt1Y54H1rx8bRW1duFVLBrkqMP3PqWKCvVlXsoDMn6k7gzKm7UmzmlIpgdeVJAAKywT55VQn5A3i5F0DA1ZzL6DgVAVfzKBQfRywUxzOcbuDdnSK9TMhkUw1YHD8uhgu2O4HTJICJy7473cukLrsaqfZ4vJpojjfwAOBDmYQPAMcDA7U66QGguoEHgOOAdkDatAbpAaBGEh4AjiMFYc0YccM1CQ8AtQL+ACD0rkUuhKJ7mZCIo3YaJfhaDB8U/lebgKBPIFF4IZc1c0raAv1oVhsYM3VIdq0TMz9zqjaJntZ1cmo9FTXW9aCn9WLc7+dRFdV1gLpAmlYv3cOkLrsuCT3lqc6YZ4DC+FAmIYXJAzqxTaIwtgEKUw9oB6RN65MoTP0kUJh6pCBsECNuuAGBwjQMOIURejckUBgTM6cagqGvHG+EhDWWx0LoL364bdvIOcPG6i3VyKOnpXGMN3OqtuNQ6JlTCAgm+y8aAYOyMRiCmepzaETqc2gSI264CaHPoQnwHbBpwPschA2bEt4pmwa8z6FxHL115TYjkflmMf738yCRyYnAGIpz/lozp+JdSuIX6ozVUS4lrb6TxsDzaA6+lNxn4uWLunaUSA7lQ8Ifm8fwM6dqAy9NJHBwI8GTnAv4ZBUJnuRRPDs5xps5JYMOnXRHBbwiL50PrffoFJk5xQoSXfudBCy8ngxMVkB/tkene1rUZZ9EqkWdoibYUwwUhH0ok7AgfAowuFqQCsItDBSETwbaAWnTU0kF4VOTUBA+mRSELWPEDbckFIRbBbwgLPRuFdtvYJBc6sypoCKO04oASmD4oPC/0wgI+nRSuUbIZc2ckrZAl39OA/p5a5JdW8fMz5w6DierAC1v4+TUtipqbONBy9vGuD0tqqK6DtAGSK3apnta1GW3IaGnM1RnPMMAhfGhTEIKcwYwi51JojBnGqAwbYF2QNr0LBKFOSsJFKYtKQjPjhE3fDaBwrQLOIURercjUBgTM6fEvo+z8NAXCWssjwWQXainpb1zhh3UW6q9R09Lhxhv5pQwXrsYPmsjIJjsaWkPDMoOKdrT0p7U03JOjLjhcwg9LecACw/nBrynRdjwXEJPy7kB72npEEdvXbnnkcj8eQZ6WpDI5HxyT4v4QGfm1AEuJa0+lOOAsjoAz6Oj4Z4WXd0lkkP5kPDHjoS74jigLCRwcCPBTs4FfIGKBDt5FM8uiPFmTsmgQyfdMQGvyEvnQ+s9NkW+p4UVJLr26wQsvF4AvPCA/myPTfe0qMvuRKpFXagm2AsNFIR9KJOwIHwhMLguIhWELzJQEL4AaAekTS8mFYQvTkJB+AJSEF4SI274EkJBuHPAC8JC786EgrDlWujvaQkq4uhSBFACwweF/3UhIOhLSeUaIZc1c0raAl3+6QL088tIdr0sZm7mlLAHe+bU5U5e7aoix8s9qHnXGHfmFMOpLgdSrK7p3hZ12ZeTUFQ31SG7GaAyPpRJSGW6AbNZdxKV6W6AynQF2gFp0x4kKtMjCVSmKykIe8aIG+5JoDK9Ak5lhN69yFQGfYMibdqb/Cqn04YhZ04xYH4fMHJgz5yS0BMlT5x7H7LfA2UX6mW6wtn7lSoqucKjl+nKGHfmFMNBHww4/5YOhNb7oRSZOXUFMAlfCUzCQL+xH0rRmVNXkPrWrooRN3wVoRfhKqBj9Q1435qwYV9C31rfgPetXRlHb125/UgFu34x/sypK4G+2l+xg86cqAeBM6ceSrGZUyqC1ZUnAQjIBvvk9SfkD+DlXgABD3Auo6tVBDzAo1B8NbFQHM9wuoE3PkV6mZDJZgCwOH51DBdsDwKnSQATlz0+3cukLnsAqfZ4jZporjHwAOBDmYQPANcAA/Va0gPAtQYeAK4G2gFp04GkB4CBSXgAuJoUhINixA0PIjwAXBfwBwCh93XkQii6lwmJOK5PowRfi+GDwv+uJyDoG0gUXshlzZyStkA/ml0PjJkbSXa9MWZ+5tT1JHo62MmpQ1TUONiDng6Jcb+fR1VU1wEGA2nakHQPk7rswST0NFR1xqEGKIwPZRJSmKFAJ76JRGFuMkBhhgDtgLTpzSQKc3MSKMwQUhDeEiNu+BYChbk14BRG6H0rgcKYmDl1Kxj6yvFGSFhjeSyE/uKH27bDnDMcrt5Swzx6WobHeDOnrnccCj1zCgHBZP/FMGBQDgdDMFN9DsNIfQ75MeKG8wl9DvnAd8DbAt7nIGx4G+Gd8raA9zkMj6O3rtzbSWT+9hj/+3mQyGQEMIbinL/WzKl4l5L4hTpjdZRLSavvZDjwPEaCLyX3mXj5oq4dJZJD+ZDwx5Ex/Myp64GXJhI4uJHgHc4FfKeKBO/wKJ7dGePNnJJBh066jwS8Ii+dD633oykyc4oVJLr2uwNYeL0TmKyA/mw/mu5pUZd9B6kWdZeaYO8yUBD2oUzCgvBdwOC6m1QQvttAQfhOoB2QNr2HVBC+JwkF4TtJQXhvjLjhewkF4VEBLwgLvUfF9hsYJJc6cyqoiGN0EUAJDB8U/jeagKDvI5VrhFzWzClpC3T5ZzTQz+8n2fX+mPmZU8fjZBWg5WOcnDpWRY1jPGj52Bi3p0VVVPsrc4HUamy6p0Vd9hgSehqnOuM4AxTGhzIJKcw4YBZ7gERhHjBAYcYC7YC06YMkCvNgEijMWFIQPhQjbvghAoUZH3AKI/QeT6AwJmZOiX0fb+GhLxLWWB4LILtQT8sE5wwfVm+pCR49LQ/HeDOnhPHGx/BZGwHBZE/LBGBQPpyiPS0TSD0tj8SIG36E0NPyCLDw8GjAe1qEDR8l9LQ8GvCelofj6K0r9zESmX/MQE8LEpk8Tu5pER/ozJw6wKWk1YdyPFDWw8DzmGi4p0VXd4nkUD4k/HEi4a44HigLCRzcSHCScwE/oSLBSR7FsydivJlTMujQSXdiwCvy0vnQek9Kke9pYQWJtv2AhdcngBce0J/tSemeFnXZk0i1qCfVBPukgYKwD2USFoSfBAbXU6SC8FMGCsJPAO2AtOnTpILw00koCD9BCsLJMeKGJxMKwlMCXhAWek8hFIQt10J/T0tQEcczRQAlMHxQ+N8zBAT9LKlcI+SyZk5JW6DLP88A/fw5kl2fi5mbOSXswZ459byTV19QkePzHtT8hRh35hTDqZ4HUqwX0r0t6rKfJ6GoqapDTjVAZXwok5DKTAVms2kkKjPNAJV5AWgHpE1fJFGZF5NAZV4gBeFLMeKGXyJQmekBpzJC7+lkKoO+QZE2fZn8KqfThiFnTjFg/gwwcmDPnJLQEyVPnPsMst8DZRfqZZrp7P0VFZXM9OhleiXGnTnFcNCnAs6/pQOh9X46RWZOzQQm4VeASRjoN/bTKTpzaiapb+3VGHHDrxJ6EV4FOtasgPetCRvOIvStzQp439orcfTWlTubVLCbHePPnHoF6KtzFDvozIl6Cjhz6ukUmzmlIlhdeRKAgGywT94cQv4AXu4FEPBrzmX0uoqAX/MoFL9OLBTHM5xu4E1OkV4mZLJ5DVgcfz2GC7angNMkgInLnpzuZVKX/Rqp9viGmmjeMPAA4EOZhA8AbwAD9U3SA8CbBh4AXgfaAWnTuaQHgLlJeAB4nRSE82LEDc8jPADMD/gDgNB7PrkQiu5lQiKOt9Iowddi+KDwv7cICPptEoUXclkzp6Qt0I9mbwFj5h2SXd+JmZ859RaJni5wcupCFTUu8KCnC2Pc7+dRFdV1gAVAmrYw3cOkLnsBCT0tUp1xkQEK40OZhBRmEdCJ3yVRmHcNUJiFQDsgbfoeicK8lwQKs5AUhO/HiBt+n0BhPgg4hRF6f0CgMCZmTn0Ahr5yvBES1lgeC6G/+OG27WLnDJeot9Rij56WJTHezKm3HIdCz5xCQDDZf7EYGJRLwBDMVJ/DYlKfw4cx4oY/JPQ5fAh8B/wo4H0OwoYfEd4pPwp4n8OSOHrryv2YROY/jvG/nweJTD4BxlCc89eaORXvUhK/UGesjnIpafWdLAGex1LwpeQ+Ey9f1LWjRHIoHxL+uDSGnzn1FvDSRAIHNxJc5lzAn6pIcJlH8ezTGG/mlAw6+P/LNuAVeel8aL2fS5GZU6wg0bXfMmDh9VNgsgL6s/1cuqdFXfYyUi3qMzXBfmagIOxDmYQF4c+AwbWcVBBebqAg/CnQDkibfk4qCH+ehILwp6Qg/CJG3PAXhILwioAXhIXeK2L7DQySS505FVTEsbIIoASGDwr/W0lA0F+SyjVCLmvmlLQFuvyzEujnX5Hs+lXM/Myp6jhZBWj5KienrlZR4yoPWr46xu1pURXVdYBVQGq1Ot3Toi57FQk9rVGdcY0BCuNDmYQUZg0wi60lUZi1BijMaqAdkDb9mkRhvk4ChVlNCsJvYsQNf0OgMOsCTmGE3usIFMbEzCmx7+oWHvoiYY3lsQCyC/W0rHfOcIN6S6336GnZEOPNnBLGWxfDZ20EBJM9LeuBQbkhRXta1pN6WjbGiBveSOhp2QgsPHwb8J4WYcNvCT0t3wa8p2VDHL115X5HIvPfGehpQSKT78k9LeIDnZlTB7iUtPpQqgNlbQCexybDPS26ukskh/Ih4Y+bCHdFdaAsJHBwI8HNzgW8RUWCmz2KZ1tivJlTMujQSXdqwCvy0vnQek9Lke9pYQWJrv02AwuvW4AXHtCf7WnpnhZ12ZtJtagf1AT7g4GCsA9lEhaEfwAG14+kgvCPBgrCW4B2QNr0J1JB+KckFIS3kIJwa4y44a2EgvC2gBeEhd7bCAVhy7XQ39MSVMTxcxFACQwfFP73MwFB/0Iq1wi5rJlT0hbo8s/PQD//lWTXX2PmZk4Je7BnTv3m5NXfVeT4mwc1/z3GnTnFcKrfgBTr93Rvi7rs30goarvqkNsNUBkfyiSkMtuB2WwHicrsMEBlfgfaAWnTnSQqszMJVOZ3UhD+ESNu+A8Clfkz4FRG6P0nmcqgb1CkTf8iv8rptGHImVMMmP83GDmwZ05J6ImSJ879b7LfA2UX6mXa5ez9HxWV7PLoZfonxp05xXDQ6QHn39KB0Hq/nCIzp3YBk/A/wCQM9Bv75RSdObWL1Lf2b4y44X8JvQj/Ah1rd8D71oQNdxP61nYHvG/tnzh668rdQyrY7YnxZ079A/TVvYoddOZETQfOnHo5xWZOqQhWV54EICAb7JO3l5A/gJd7AQT8n7yMcq2CaPc/j0Kx+Ef5yiGDNhXXcLqBNyNFepmQyeY/YHFcnPmpoGCbDpwmAUxc9ox0L5O67P9ItceQmmjEX7AfAHwok/ABIJSL21c4F+YMBdBROJf/AGAB7YC0aYYPm/p5AMjINf8AYOVygjCSS9xwJBcvNwp0EJbe0dz9BgbJpfYyIRFHZhol+FoMHxT+l5mLR9BZ4CQkE6qQy5o5JW2BfjTLBOahbJJds3PNz5zKBOriRs45Tk6NqagxJ7cwPY3lcr+fR1VU1wFyDl5WQpoWAx7AoUJhckjoKVd1xlwDFMaHMgkpTC7QiYuRKEwxAxQmBrQD0qaHkSjMYUmgMDFSEB6eS9zw4QQKc0TAKYzQ+wgChTExc+oIMPSV442QsMbyWAj9xQ+3bYs7Z1hCvaXEB2pPi/hHrJlTmY5DoWdOISCY7L8oDgzKEmAIZqrPoXgup8+hZC5xwyVz8X0OJXEHaJciZ3uEDUvl4t8pS4EzJlrvEnH01pV7JInMC7ns7+dBIpOjgDEU5/y1Zk7Fu5TEL9QZq6NcSlp9JyWA51EafCm5z8TLF3XtKJEcyoeEP5bOxc+cygRemkjg4EaCZZwL+GgVCZbxKJ4dncubOSWDDp10Xw14RV46H1rvWSkyc4oVJLr2KwMsvB4NTFZAf7ZnpXta1GWXIdWijlET7DEGCsI+lElYED4GGFxlSQXhsgYKwkcD7YC0aTlSQbhcEgrCR5OCsHwuccPlCQXhCgEvCAu9K+TuNzBILnXmVFARR8UigBIYPij8ryIBQR9LKtcIuayZU9IW6PJPRaCfVyLZtVKu+ZlTNXCyCtDyyk5OraKixsoetLxKLrenRVVU1wEqA6lVlXRPi7rsyiT0VFV1xqoGKIwPZRJSmKrALFaNRGGqGaAwVYB2QNr0OBKFOS4JFKYKKQiPzyVu+HgChakecAoj9K5OoDAmZk6Jfdew8NAXCWssjwWQXainpYZzhjXVW6qGR09LzVzezClhvOq5+KyNgGCyp6UGMChrpmhPSw1ST0utXOKGaxF6WmoBCw+1A97TImxYm9DTUjvgPS014+itK/cEEpk/wUBPCxKZ1CH3tIgPdGZOHeBS0upDqQGUVRN4HnUN97To6i6RHMqHhD/WJdwVNYCykMDBjQTrORdwnooE63kUz/JyeTOnZNChk+5rAa/IS+dD6/16inxPCytIdO1XD1h4zQNeeEB/tl9P97Soy65HqkXZaoK1DRSEfSiTsCBsA4OrPqkgXN9AQTgPaAekTRuQCsINklAQziMFYcNc4oYbEgrCjQJeEBZ6NyIUhC3XQn9PS1ARR+MigBIYPij8rzEBQTchlWuEXNbMKWkLdPmnMdDPm5Ls2jTX3MwpYQ/2zKlmTl49UUWOzTyo+Ym53JlTDKdqBqRYJ6Z7W9RlNyOhqOaqQzY3QGV8KJOQyjQHZrOTSFTmJANU5kSgHZA2PZlEZU5OApU5kRSEp+QSN3wKgcq0CDiVEXq3IFMZ9A2KtOmp5Fc5nTYMOXOKAfNbgpEDe+aUhJ4oeeLcW5L9Hii7UC9TK2fvp6mopJVHL9NpudyZUwwHnRtw/i0dCK33vBSZOdUKmIRPAyZhoN/Y81J05lQrUt/a6bnEDZ9O6EU4HehYrQPetyZs2JrQt9Y64H1rp8XRW1duG1LBrk0uf+bUaUBfbavYQWdO1FzgzKl5KTZzSkWwuvIkAAHZYJ+8toT8AbzcCyDgM5zL6EwVAZ/hUSg+k1gojmc43cCbnyK9TMhkcwawOH5mLi7Y5gKnSQATlz0/3cukLvsMUu3xLDXRnGXgAcCHMgkfAM4CBurZpAeAsw08AJwJtAPSpu1IDwDtkvAAcCYpCNvnEjfcnvAA0CHgDwBC7w7kQii6lwmJOM5JowRfi+GDwv/OISDoc0kUXshlzZyStkA/mp0DjJnzSHY9L9f8zKlzSPT0fCendlRR4/ke9LRjLvf7eVRFdR3gfCBN65juYVKXfT4JPXVSnbGTAQrjQ5mEFKYT0IkvIFGYCwxQmI5AOyBteiGJwlyYBArTkRSEF+USN3wRgcJcHHAKI/S+mEBhTMycuhgMfeV4IySssTwWQn/xw23bS5wz7KzeUpd49LR0zuXNnDrHcSj0zCkEBJP9F5cAg7IzGIKZ6nO4hNTn0CWXuOEuhD6HLsB3wEsD3ucgbHgp4Z3y0oD3OXSOo7eu3MtIZP6yXP738yCRyeXAGIpz/lozp+JdSuIX6ozVUS4lrb6TzsDz6Aq+lNxn4uWLunaUSA7lQ8Ifu+biZ06dA7w0kcDBjQS7ORdwdxUJdvMonnXP5c2ckkGHTrrvBLwiL50PrfeCFJk5xQoSXft1AxZeuwOTFdCf7QXpnhZ12d1ItageaoLtYaAg7EOZhAXhHsDg6kkqCPc0UBDuDrQD0qa9SAXhXkkoCHcnBWHvXOKGexMKwn0CXhAWevfJ3W9gkFzqzKmgIo4rigBKYPig8L8rCAj6SlK5RshlzZyStkCXf64A+vlVJLtelWt+5lRNnKwCtLyvk1P7qaixrwct75fL7WlRFdV1gL5AatUv3dOiLrsvCT31V52xvwEK40OZhBSmPzCLDSBRmAEGKEw/oB2QNr2aRGGuTgKF6UcKwmtyiRu+hkBhrg04hRF6X0ugMCZmTol917Tw0BcJayyPBZBdqKdloHOGg9RbaqBHT8ugXN7MKWG8a3PxWRsBwWRPy0BgUA5K0Z6WgaSelutyiRu+jtDTch2w8HB9wHtahA2vJ/S0XB/wnpZBcfTWlXsDiczfYKCnBYlMbiT3tIgPdGZOHeBS0psTBZQ1CHgegw33tOjqLpEcyoeEPw4m3BU1gbKQwMGNBIc4F/BQFQkO8SieDc3lzZySQYdOuu8GvCIvnQ+t93sp8j0trCDRtd8QYOF1KPDCA/qz/V66p0Vd9hBSLeomNcHeZKAg7EOZhAXhm4DBdTOpIHyzgYLwUKAdkDa9hVQQviUJBeGhpCC8NZe44VsJBeFhAS8IC72HEQrClmuhv6clqIhjeBFACQwfFP43nICg80nlGiGXNXNK2gJd/hkO9PPbSHa9LdfczClhD/bMqdudvDpCRY63e1DzEbncmVMMp7odSLFGpHtb1GXfTkJRI1WHHGmAyvhQJiGVGQnMZneQqMwdBqjMCKAdkDa9k0Rl7kwClRlBCsK7cokbvotAZe4OOJURet9NpjLoGxRp03vIr3I6bRhy5hQD5t8LRg7smVMSeqLkiXO/l+z3QNmFeplGOXsfraKSUR69TKNzuTOnGA66OOD8WzoQWu8lKTJzahQwCY8GJmGg39hLUnTm1ChS39p9ucQN30foRbgP6Fj3B7xvTdjwfkLf2v0B71sbHUdvXbljSAW7Mbn8mVOjgb46VrGDzpyoxcCZU0tSbOaUimB15UkAArLBPnljCfkDeLkXQMDjnMvoARUBj/MoFD9ALBTHM5xu4H2YIr1MyGQzDlgcfyAXF2yLgdMkgInL/jDdy6Quexyp9vigmmgeNPAA4EOZhA8ADwID9SHSA8BDBh4AHgDaAWnT8aQHgPFJeAB4gBSEE3KJG55AeAB4OOAPAELvh8mFUHQvExJxPJJGCb4WwweF/z1CQNCPkii8kMuaOSVtgX40ewQYM4+R7PpYrvmZU4+Q6OnjTk6dqKLGxz3o6cRc7vfzqIrqOsDjQJo2Md3DpC77cRJ6mqQ64yQDFMaHMgkpzCSgEz9BojBPGKAwE4F2QNr0SRKFeTIJFGYiKQifyiVu+CkChXk64BRG6P00gcKYmDn1NBj6yvFGSFhjeSyE/uKH27aTnTOcot5Skz16Wqbk8mZOPeI4FHrmFAKCyf6LycCgnAKGYKb6HCaT+hyeySVu+BlCn8MzwHfAZwPe5yBs+CzhnfLZgPc5TImjt67c50hk/rlc/vfzIJHJ88AYinP+WjOn4l1K4hfqjNVRLiWtvpMpwPN4AXwpuc/Eyxd17SiRHMqHhD++kIufOfUI8NJEAgc3EpzqXMDTVCQ41aN4Ni2XN3NKBh066X4S8Iq8dD603ktTZOYUK0h07TcVWHidBkxWQH+2l6Z7WtRlTyXVol5UE+yLBgrCPpRJWBB+ERhcL5EKwi8ZKAhPA9oBadPppILw9CQUhKeRgvDlXOKGXyYUhGcEvCAs9J6Ru9/AILnUmVNBRRwziwBKYPig8L+ZBAT9CqlcI+SyZk5JW6DLPzOBfv4qya6v5pqfOVULJ6sALZ/l5NTZKmqc5UHLZ+dye1pURXUdYBaQWs1O97Soy55FQk9zVGecY4DC+FAmIYWZA8xir5EozGsGKMxsoB2QNn2dRGFeTwKFmU0KwjdyiRt+g0Bh3gw4hRF6v0mgMCZmTol917Lw0BcJayyPBZBdqKdlrnOG89Rbaq5HT8u8XN7MKWG8N3PxWRsBwWRPy1xgUM5L0Z6WuaSelvm5xA3PJ/S0zAcWHt4KeE+LsOFbhJ6WtwLe0zIvjt66ct8mkfm3DfS0IJHJO+SeFvGBzsypA1xKWn0otYCy5gHPY4HhnhZd3SWSQ/mQ8McFhLuiFlAWEji4keBC5wJepCLBhR7Fs0W5vJlTMujQSfezgFfkpfOh9V6eIt/TwgoSXfstBBZeFwEvPKA/28vTPS3qsheSalHvqgn2XQMFYR/KJCwIvwsMrvdIBeH3DBSEFwHtgLTp+6SC8PtJKAgvIgXhB7nEDX9AKAgvDnhBWOi9mFAQtlwL/T0tQUUcS4oASmD4oPC/JQQE/SGpXCPksmZOSVugyz9LgH7+EcmuH+Wamzkl7MGeOfWxk1c/UZHjxx7U/JNc7swphlN9DKRYn6R7W9Rlf0xCUUtVh1xqgMr4UCYhlVkKzGbLSFRmmQEq8wnQDkibfkqiMp8mgcp8QgrCz3KJG/6MQGWWB5zKCL2Xk6kM+gZF2vRz8qucThuGnDnFgPlfgJEDe+aUhJ4oeeLcvyD7PVB2oV6mFc7eV6qoZIVHL9PKXO7MKYaDrgg4/5YOhNZ7ZYrMnFoBTMIrgUkY6Df2yhSdObWC1Lf2ZS5xw18SehG+BDrWVwHvWxM2/IrQt/ZVwPvWVsbRW1fuKlLBblUuf+bUSqCvrlbsoDMnagVw5tTKFJs5pSJYXXkSgIBssE/eakL+AF7uBRDwGucyWqsi4DUeheK1xEJxPMPpBt6XKdLLhEw2a4DF8bW5uGBbAZwmAUxc9pfpXiZ12WtItcev1UTztYEHAB/KJHwA+BoYqN+QHgC+MfAAsBZoB6RN15EeANYl4QFgLSkI1+cSN7ye8ACwIeAPAELvDeRCKLqXCYk4NqZRgq/F8EHhfxsJCPpbEoUXclkzp6Qt0I9mG4Ex8x3Jrt/lmp85tZFET793cuomFTV+70FPN+Vyv59HVVTXAb4H0rRN6R4mddnfk9DTZtUZNxugMD6USUhhNgOdeAuJwmwxQGE2Ae2AtOkPJArzQxIozCZSEP6YS9zwjwQK81PAKYzQ+ycChTExc+onMPSV442QsMbyWAj9xQ+3bbc6Z7hNvaW2evS0bMvlzZza6DgUeuYUAoLJ/outwKDcBoZgpvoctpL6HH7OJW74Z0Kfw8/Ad8BfAt7nsC8ZEN4pfwl4n8O2OHrryv2VROZ/zeV/Pw8SmfwGjKE45681cyrepSR+oc5YHeVS0uo72QY8j9/Bl5L7TLx8UdeOEsmhfEj44++5+JlTG4GXJhI4uJHgducC3qEiwe0exbMdubyZUzLo0El3dcAr8tL50HqvSZGZU6wg0bXfdmDhdQcwWQH92V6T7mlRl72dVIvaqSbYnQYKwj6USVgQ3gkMrj9IBeE/DBSEdwDtgLTpn6SC8J9JKAjvIAXhX7nEDf9FKAj/HfCCsND779z9BgbJpc6cCiri2FUEUALDB4X/7SIg6H9I5RohlzVzStoCXf7ZBfTzf0l2/TfX/Myp2jhZBWj5bien7lFR424PWr4nl9vToiqq6wC7gdRqT7qnRV32bhJ62qs6414DFMaHMgkpzF5gFvuPRGH+M0Bh9gDtgLSpVYxDYYTcfMsshdlDCsJQMeKGhXC03HCxYFMYoXe42H4Dg+QamTkl9l3bwkNfJKyxPBZAdqGelgznDCPFrIK3lPhA7WkR/4g1c0oYTxwMOmsjIJjsackABmWkGDZoTPW0ZBTj9LREixE3LISje1qiuAO0M8nZHmHDzGL4npbMYtiMidY7EkdvXblZxbAwRyZoIZfd04JEJtnAGPI6f/GBzsypA1xKWn0otYGyIsDzyAFfSu4zieOLWrpLJIfyIeGPOYS7ojZQFhI4uJFgzLmAc1UkGCtWuHiWW4w3c0oGHTrpfhPwirx0PrTe61Lke1pYQaJrv9jBy0pYeM0FXnhAf7bXpXta1GXHwCBNrmJqgi1WjF8Q9qFMwoJwMWBwHVYM5gwFkPBhxfgF4VygHZA2PZxUED48CQXhXFIQHlGMuOEjCAXh4gEvCAu9ixMKwpZrob+nJaiIo0QRQAkMHxT+V4KAoEuSyjVCLmvmlLQFuvxTAujnpUh2LVXM3MwpYQ/2zKkjnbx6lIocj/Sg5kcV486cYjjVkUCKdRS4hnUoUJkjSSiqtOqQpQ1QGR/KJKQypYHZrAyJypQxQGWOAtoBadOjSVTm6CRQmaNIQXhMMeKGjyFQmbIBpzJC77JkKoO+QZE2LUd+ldNpw5AzpxgwvzwYObBnTknoiZInzr082e+Bsgv1MlVw9l5RRSUVPHqZKhbjzpxiOOjGgPNv6UBovb9NkZlTFYBJuCIwCQP9xv42RWdOVSD1rR1bjLjhYwm9CMcCHatSwPvWhA0rEfrWKgW8b61iHL115VYmFewqF+PPnKoI9NUqih105kRtBM6c+jbFZk6pCFZXngQgIBvsk1eFkD+Al3sBBFzVuYyqqQi4qkehuBqxUBzPcLqB912K9DIhk01VYHG8WjFcsG0ETpMAJi77u3Qvk7rsqqTa43FqojnOwAOAD2USPgAcBwzU40kPAMcbeACoBrQD0qbVSQ8A1ZPwAFCNFIQ1ihE3XIPwAFAz4A8AQu+a5EIoupcJiThqpVGCr8XwQeF/tQgIujaJwgu5rJlT0hboR7NawJg5gWTXE4qZnzlVi0RP6zg5ta6KGut40NO6xbjfz6MqqusAdYA0rW66h0lddh0SeqqnOmM9AxTGhzIJKUw9oBPnkShMngEKUxdoB6RNbRKFsZNAYeqSgrB+MeKG6xMozP9r7zrApCia9nJwxNt05CgmVETcWS4aEBAQA0HBhCd6UVFBBXPEExUVE2YFA+aEmMCAiAkw5/gZMGHOOf8zZ88x29tbe7P91tzsfzvP04L9LrXd1VXVb3X3Tg/xeQpj9XsIQwrjxZ1TQ8DU177eCElrAooH0X/rP07dFokxLJZnqSLFmZbiAr47pwYKg0LfOYWgYPb5iyKgUxaDKZhX5xyKmM45lBQwNriE4ZxDCXAfsNTn5xwsHZYy7FOW+vycQ3GKfuvKLWNK5ssK+N/Pg2Qm5UAfSjH+WndOpZqUrC/UuVZHmpS0zp0UA8djK/Ck5BwTlS3q6tFmcigbsuxxqwL8nVMDgZMmkjg4meDWYgLeRmaCWysWz7Yp4LtzynY6dNBd6/MVedv40P3+NEvunOJyEl39bQ1ceN0GGKyA9mx8mjvTIj/G1kxrUdvKAXZbDxaEXXQm7YLwtkDnGsq0IDzUgwXhbYB6QOp0O6YF4e2aYUF4GyYnHFbA2WCGBeHhPl8Qtvo9vMChYIxc1jun/Mo4RrQAlsBhg5b9jWBg0NszLddYcrnunLJ1gV7+GQG085FMeh1Z4P2dU4NwshLS8lEipo6WWeMoRVo+uoD3TIvcUV0DGAVMrUbnzrTIjzGKiT3tIBvjDh6kMC46kzaF2QEYxcYwpTBjPEhhRgP1gNTpjkwpzI7NkMKMZnLCnQoYG7wTQwqzs89TGKvfOzOkMF7cOWW1e1AAT32RtCageACyk8607CLGcKw8S+2iONMytoDvzilLeTsX4KM2goLZZ1p2ATrl2Cw907IL05mWcQWMDR7HcKZlHHDhYbzPz7RYOhzPcKZlvM/PtIxN0W9duROYkvkJHpxpQTKTXZnPtFiAzp1TxKSkdQ5lEFDWWOB47ObxmRbdvttMDmVDlj3uxjBXDALKQhIHJxOcKCbgSTITnKhYPJtUwHfnlO106KD7hc9X5G3jQ/f7yyx5TwuXk+jqbyJw4XUScMID2rPxZe5Mi/wYE5nWonaXA+zuHiwIu+hM2gXh3YHOtQfTgvAeHiwITwLqAanTPZkWhPdshgXhSUxOuFcBY4P3YlgQ3tvnC8JWv/cuWKdgkFzW97T4lXFMbgEsgcMGLfubzMCg92FarrHkct05ZesCvfwzGWjnFUx6rSjw7s4pSx/cd07tK+LqFJk57qtIzacU8N45xWFU+wJTrCm5sy3yY+zLxKL2kw1yPw9SGRedSZvK7AeMZvszpTL7e5DKTAHqAanTSqZUprIZUpkpTE5YVcDY4CqGVKba56mM1e9q5lQGPYMidVrDvCuncwzDvnOKg+bXgpkD951TNvVEybPGvZbZ7oGyk84y1Ym2HyCzkjrFWaYDCnjvnOIw0G98nn/bBoTu97dZcudUHTAIHwAMwkC7Mb7N0jun6pjOrR1YwNjgAxnOIhwINKypPj+3ZulwKsO5takFvIEYETymMgTig5gW7A4q4L9z6gCgrR4s6UHnnqhvgHdOfZtld07JDFZXnk1AQDpokHcwQ/wATu4JDPgQMRlNkxnwIYqF4mmMC8WpFKfreN9lyVkmZLA5BLg4Pq0A52zfAG+TAAYu47vcWSb5MQ5hWnucLgea6R5sALjoTNoNgOlARz2UaQPgUA82AKYB9YDU6WFMGwCHNcMGwDQmJzy8gLHBhzNsAMzw+QaA1e8ZzAuh6LNMSMYxM8cSXD0cNmjZ30wGBn0EUwpvyeW6c8rWBXrTbCbQZ45k0uuRBd7fOTWTKT09SsTUo2XWeJQiPT26gPf9PHJHdQ3gKGCadnTuDJP8GEcxsadjZGM8xoMUxkVn0qYwxwCN+FimFOZYD1KYo4F6QOr0OKYU5rhmSGGOZnLC4wsYG3w8Qwpzgs9TGKvfJzCkMF7cOXUCmPra1xshaU1A8SD6b/3HqdsTxRieJM9SJyrOtJxUwHfn1ExhUOg7pxAUzD5/cSLQKU8CUzCvzjmcyHTO4eQCxgafzHDO4WTgPuAsn59zsHQ4i2GfcpbPzzmclKLfunJPYUrmTyngfz8PkpnUA30oxfhr3TmValKyvlDnWh1pUtI6d3IScDxOBU9KzjFR2aKuHm0mh7Ihyx5PLcDfOTUTOGkiiYOTCc4WE/BpMhOcrVg8O62A784p2+nQQfdHn6/I28aH7vdPWXLnFJeT6OpvNnDh9TRgsALas/FT7kyL/BizmdaiTpcD7OkeLAi76EzaBeHTgc51BtOC8BkeLAifBtQDUqdzmBaE5zTDgvBpTE54ZgFjg89kWBA+y+cLwla/zypYp2CQXNY7p/zKOM5uASyBwwYt+zubgUHPZVquseRy3Tll6wK9/HM20M7PYdLrOQXe3zm1BU5WQlp+roip58ms8VxFWn5eAe+ZFrmjugZwLjC1Oi93pkV+jHOZ2NP5sjGe70EK46IzaVOY84FR7AKmFOYCD1KY84B6QOp0HlMKM68ZUpjzmJzwwgLGBl/IkMJc5PMUxur3RQwpjBd3Tlnt3iKAp75IWhNQPADZSWdaLhZjeIk8S12sONNySQHfnVOW8i4qwEdtBAWzz7RcDHTKS7L0TMvFTGdaLi1gbPClDGdaLgUuPFzm8zMtlg4vYzjTcpnPz7RckqLfunIvZ0rmL/fgTAuSmVzBfKbFAnTunCImJa1zKFsAZV0CHI8rPT7Tott3m8mhbMiyxysZ5ootgLKQxMHJBOeLCXiBzATnKxbPFhTw3TllOx066P7q8xV52/jQ/f4tS97TwuUkuvqbD1x4XQCc8ID2bPyWO9MiP8Z8prWoq+QAe5UHC8IuOpN2QfgqoHNdzbQgfLUHC8ILgHpA6vQapgXha5phQXgBkxNeW8DY4GsZFoQX+nxB2Or3QoYF4YDjQb+nxa+M47oWwBI4bNCyv+sYGPT1TMs1llyuO6dsXaCXf64D2vkNTHq9ocC7O6csfXDfOXWjiKs3yczxRkVqflMB751THEZ1IzDFuil3tkV+jBuZWNTNskHe7EEq46IzaVOZm4HR7BamVOYWD1KZm4B6QOr0VqZU5tZmSGVuYnLC2woYG3wbQypzu89TGavftzOnMugZFKnTO5h35XSOYdh3TnHQ/EVg5sB955RNPVHyrHFfxGz3QNlJZ5nuFG1fLLOSOxVnmRYX8N45xWGgf/o8/7YNCN3vv7Lkzqk7gUF4MTAIA+3G+CtL75y6k+nc2l0FjA2+i+Eswl1Aw7rb5+fWLB3ezXBu7W6fn1tbnKLfunLvYVqwu6eA/86pxUBbvVfSg849UX8C75z6K8vunJIZrK48m4CAdNAg716G+AGc3BMY8H1iMloiM+D7FAvFSxgXilMpTtfx/s6Ss0zIYHMfcHF8SQHO2f4E3iYBDFzG37mzTPJj3Me09rhUDjRLPdgAcNGZtBsAS4GOej/TBsD9HmwALAHqAanTB5g2AB5ohg2AJUxO+GABY4MfZNgAeMjnGwBWvx9iXghFn2VCMo5lOZbg6uGwQcv+ljEw6IeZUnhLLtedU7Yu0Jtmy4A+s5xJr8sLvL9zahlTevqIiKkrZNb4iCI9XVHA+34euaO6BvAIME1bkTvDJD/GI0zs6VHZGB/1IIVx0Zm0KcyjQCN+jCmFecyDFGYFUA9InT7OlMI83gwpzAomJ3yigLHBTzCkME/6PIWx+v0kQwrjxZ1TT4Kpr329EZLWBBQPov/Wf5y6XSnGcJU8S61UnGlZVcB359QyYVDoO6cQFMw+f7ES6JSrwBTMq3MOK5nOOawuYGzwaoZzDquB+4BP+fycg6XDpxj2KZ/y+TmHVSn6rSv3aaZk/ukC/vfzIJnJM0AfSjH+WndOpZqUrC/UuVZHmpS0zp2sAo7Hs+BJyTkmKlvU1aPN5FA2ZNnjswX4O6eWASdNJHFwMsHnxAT8vMwEn1Msnj1fwHfnlO106KAb6OrvFXnb+ND9bgXut/2g75zichJd/T0HXHh9Hjnh4cbVQNrI/5cF4eeY1qJekAPsCx4sCLvoTNoF4ReAzvUi04Lwix4sCD8P1ANSpy8xLQi/1AwLws8zOeHLBYwNfplhQfgVny8IW/1+pWCdgkFyWe+c8ivjeLUFsAQOG7Ts71UGBv0a03KNJZfrzilbF+jln1eBdv46k15fL/D+zqnBOFkJafkbIqa+KbPGNxRp+ZsFvGda5I7qGsAbwNTqzdyZFvkx3mBiT2/JxviWBymMi86kTWHeAkaxt5lSmLc9SGHeBOoBqdP/MaUw/2uGFOZNJid8p4Cxwe8wpDDv+jyFsfr9LkMK48WdU1a7Bwfw1BdJawKKByA76UzLe2IM35dnqfcUZ1reL+C7c8pS3rsF+KiNoGD2mZb3gE75fpaeaXmP6UzLmgLGBq9hONOyBrjw8IHPz7RYOvyA4UzLBz4/0/J+in7ryv2QKZn/0IMzLUhm8hHzmRYL0LlzipiUtM6hDAbKeh84Hh97fKZFt+82k0PZkGWPHzPMFYOBspDEwckEPxET8FqZCX6iWDxbW8B355TtdOig28bnK/K28aH7ne/RmRYL96OT6OrvE+DC61rghAe0ZyM/d6ZFfoxPmNaiPpUD7KceLAi76EzaBeFPgc71GdOC8GceLAivBeoBqdPPmRaEP2+GBeG1TE74RQFjg79gWBD+0ucLwla/v2RYEA44HvR7WvzKOL5qASyBwwYt+/uKgUF/zbRcY8nlunPK1gV6+ecroJ1/w6TXbwq8u3PK0gf3nVPfirj6ncwcv1Wk5t8V8N45xWFU3wJTrO9yZ1vkx/iWiUV9Lxvk9x6kMi46kzaV+R4YzX5gSmV+8CCV+Q6oB6ROf2RKZX5shlTmOyYn/KmAscE/MaQyP/s8lbH6/TNzKoOeQZE6/YV5V07nGIZ95xQHzf8VzBy475yyqSdKnjXuvzLbPVB20lmm30Tbf5dZyW+Ks0y/F/DeOcVhoO19nn/bBoTudwemHSz0nVO/AYPw78AgDLQbowN4p8irc2u/MZ1b+6OAscF/MJxF+ANoWH/6/NyapcM/Gc6t/enzc2u/p+i3rty/mBbs/irgv3Pqd6Ct/i3pQeeeKDk468hCB2enbQYC+DunZAarK88mICAdNMj7myF+ACf3BAb8j5iM/pUZ8D+KheJ/GReKUylO1/E6ZslZJmSw+Qe4OP5vAc7ZnIFLVxYwcBkdc2eZ5Mf4h2ntMRAMJAYVq4J7A8BFZ9JuAFjtRbWrVRBmDAnsyJI7i1mn/yKZPFCneS506mYDIC/o/QbAv0xO2DrI2ODWQbzcNkAD4ep3m+A6BYPksp5lQjKO/GCOJbh5OGzQsr/8IJ5Btw1ig5AdUC25XHdO2bpAb5rlA+NQOya9tgt6f+dUPrAvTubcXsTUDjJrbB9MTk87BHnfzyN3VHtzpumy0qZpHYAD8P8lhWkf5GFPHWVj7OhBCuOiM2lTmI5AI+7ElMJ08iCF6QDUA1KnBUwpTEEzpDAdmJwwGGRscJAhhQn5PIWx+h1iSGG8uHMqBKa+9vVGSFoTUDyI/lv/ceo2LMYwIs9SFiCfabE+xHXnVL4wKPSdUwgKZp+/CAOdMgKmYF6dcwgHec45RIOMDY4G8eccorgBNAqZoz1Ch4VB/D5lIThiovsdSdFvXbmdmZJ5Sy73+3mQzKQL0IdSjL/WnVOpJiXrC3Wu1ZEmJa1zJxHgeHQFT0rOMVHZoq4ebSaHsiHLHrsG8XdO5QMnTSRxcDLBbmIC7i4zwW6KxbPuQb47p2ynQwfdoM9X5G3jQ/c7lCV3TnE5ia7+ugEXXrsDgxXQno1Q7kyL/BjdmNaiesgBtocHC8IuOpN2QbgH0Ll6Mi0I9/RgQbg7UA9InfZiWhDu1QwLwt2ZnLB3kLHBvRkWhPv4fEHY6nef4DoFg+Sy3jnlV8bRtwWwBA4btOyvLwOD7se0XGPJ5bpzytYFevmnL9DO12PS63rB9HdOoa9iCgNlrQeUBfwBd8JyQX8R69eX2Wx/xXLB+go2pjqgqNPRbBgAXYfpD0xF18+dAZIfoz8T29xAdpINPEj5XHQmbcq3ATDqb8iU8m3oQcq3PlAPSJ1uxJTybdQMKd/6TE64cZCxwRszpHwDfJ7yWf0ewJTycUT2AQypQWHzpkRpA/f6TP3uzLSpgA7YmyBPaQBTaaT+nAHb6u9JgcQnH6xTLhaq265NW9hYbyrGmpqcVTvuOn1BkkquiX6zIGPnNwMrYDPFBKrrCF6ue5wMlPVCG2AK34Fn3WOgGK/N5ZRuoGLdY3MP1j2yYQB0DXogcMbZPLfuIT/GQKZIPEh2kkEerHsMBEboQUB6sgXTuscWHqx7bA7UA1Kng5nWPQY3w7rH5kxOuGWQscFbMqx7xHy+7mH1O5Yl6x4DRVvR+X8Pn697bM7U755Zsu5hAHNh4FgbPZlyYau/0wKJD3rdg4uF6rYr3sLGOh5c98qKdg7fsR5gyh+3/mPHzybIi8ea8NhxCfwzR6OJthlrgj1BiUgsyBMvA7hxjlnTCZtsYx0Za/gJrT1Gpl6KzFJslhKzlJqlzCzlZtnKLFubZRuzbGuWoWbZztKjWYabZYScVVnC2kt1RYq6YkVdiaKuVFFXpqgrV9RtpajbWlG3jaJuW0XdUEXddoq6YYq64Yq6EaLO+XSRBtyvzqg7UQwJYvpo9tIoCuL0VQyR9Z++SvRlxW3dl+rKKlo3jmV6smJOmyjXkRVPtK+tMpcVk2116wxlldQl2/02mckqU/nQtpnIKlP741D3skpT+fZ2bmWVpo4Tw9zJilMxZ7gbWaV0/BoRxJExEDltkNUT/IsnRiLa0Gb7AEMT5aUlo/bBAM5TZ346ojgAKCugeDCyvSei25t6GWmWUWYZbZYdzDLGLDuaZSez7GyWXcwy1izjzDLeLBPMsqtZdpOJ6PYKwjVSUTdKUTdaUbeDom6Mom5HRd1OirqdFXW7KOrGKurGKerGK+omKOp2VdTtxkhE/X5SY3sgER0JJKKjgER0NJCI7gAkomOARHRHIBHdCUhEdwYS0V2ARHQskIiOAxLR8UAiOgFIRHcFEtHdcAQgDjwdFu8MJqIW8bQPADkfe64BfZcxJIgjJkUYWQ27QsUIWWJ/qURfVuNOVamuLMeeV5merITds3IdWdI+3FZMJBttu1sDbXcboO1uC7TdoUDb3Q5ou8OAtjscaLsjssR2twfa7kig7Y4C2u5ooO3uALTdMUDb3RFouztlie3uDLTdXYC2OxZou+OAtjseaLsTgLa7K9B2gbw85uS9E4P//TlJ/Lm7+HOPIKNxTwIb+CSwkU8CG/oksLFPAhv8JLDRTwIbvm2cQDtUvkKdg4RMBBORiUEsGZkYxBKSiUEsKZkYxBKTiUEsOZkYxBIUSx74eGsMZoMx6K5O0vFUpy/uKXx+L3n3xAKWS3V7OTqIPhu8fYpB0V3dL/bza6IcwQbd7xL/9jshKKL7XerXfkvBG93vMn/2O2mSQfe73I/9VkyG6H5v5b9+KydtdL+39lu/m0gudPu9DdNvPdroj7vzMYDzjgGM5UZZV9xYDM2SsQDGRgMYb4ytgWOxnYcvlNc5BbBnENfnvXCJhgHkxwYwRhlAHzO2A+9qe3W91Z7EOLuV7Wzv3kHGBlvC8yS5uo3fG2jwk4GOyKXDyU1YnXD7PZODvMQJEdQmB/XPKstykeO9D1CHzoUVS+7wQOKDJgPZsFWrOz7D/E7MsmhLWXcshjONRVB/LLJh6zu3Pe1KUsvbntb1zwqgrQLjrjHco5daxPQeA7jbY0wCjuu+QI6i2r3tIOkxXlRTUlUZK60rrawsq4sVVcVrzD9K6kpL64rjleVDqiuLSstqqmorq4ZUl8era+I1ZvNjxUNqh5SX1NYWVcu7t/HKqpLyotryWLxuSGWxURyvNqrKq+LlNUa8uLxmiFETG1JaVVpVW1cbqyqtM0qra4qKhpRXl1ZZ0qqG1Mq7t/Hakqq6klhVrDRWWhwrM0wBNbVFJeXF8draslJTTNwoKy8tqorVlQ2Jl8Vj5ZWVsTrz43WWtBqjTt69NUxpdaXmUMRr4kPK43WV5YZRZZhdN/tYXFtVWV5bW27+fUisqLKupLi8qLK8KlZZWVJebkkz2yzv3sZrimtj5WVVZfGqSrNnRUOqyssrzbEvMQxTZjxWUxSvKzZKSqrLTbnGkLqq4trKkuLKshJLWmVJjbx7+5/9FMVLq2uHxGuKyspKqmJmm2uHGEOqKo2aKvOfVJVVxU2bMjVaZpSWVZYaJUOKYzFLWrVhjFHIc3evTVGd414bY8ckeab9VsaLSmqLYyW1ZeVlteWmpZTGqivr6mpKY0XVVbGqqqKS2BCrr6XxWJVRbrpCeW1xwy05//00A+l7VhzcV5VvVZXVlBeVVNaWl5Uapu3FiktLi4uLTJcrq47XVJcX19RWm8NQXl1rmmBNdZFRYg5fcVEsVl1iWUQRcJHGs93gKYJc7SfvBk9R7Abvx7gbnGpQdIPjDkyTSwGj8eiuPE4BTi7OMdcN/M6VR11ZJUBZpUBZZUBZ5UBZWwFlbQ2UhVxB3iFLV32nMK367h9kbPD+DKu++wNn+Uqfr/paOqxkWPWt9Pmq736i3+lsJ90jy0WOdxXTqm+VYtW3naQHzYBag9wqdE7+mgSnOGHbUVPWNkBZQ4GytgNuc6MnMzmrtx9dP5QeY3eg/WVjRlUtJt0aOaOqVmRUNY4O2g96G4hrQHSzlGpgwK4BL4F5xfyqmZhfbZCxwbUMzK8WaKR1Pmd+lg7rGJhfnc+ZX43oN5r5Icf7ACbmd4BgftRMLL8wWpcJIgP/HrhlIL8y1KKaLGQbB4pAP1VmG1MVzAKdauQMLHMD02VPBwKD3tQsZU8HMrGng4KMDT6IgT0dBDT4g33OniwdHszAng72OXuaKvqNZk/I8T6EiT0dolg309QvGVBjmo+znR00x0t6ci8+cyWp5b34zE9LKZx+kHuJmhtJLe8lan4jxamyfvRBmj2yMIudJgj3dDmLnaZYM5+uyGzRRz33AGZq04BGOT1LM7VpTJnaoUHGBh/KkKkdCszUDvN5pmbp8DCGTO0wn2dq00W/0ZkacrwPZ8rUDm/COnfutY5uJeV+N+NOEva1jgoTZmFBM8RkNlNmQTMULGimggV11GtcUmNzjuVGUu4HaW6Z8QzghDYzS5nxDCZmfESQscFHMDDjI4DM+EifM2NLh0cyMOMjfc6MZ4p+o5kxcryPYmLGRzWBGevqRXqM6f4IsEmsR9F1FkZ1tAiCx8iM6mjhfM66YxSMCn0Wk2tAdGfio4HtOgZoKG6cxUdra0Y2OsuxwlmOk53lWIWzHNcEZ/HrgOg6y7FAZzkObCjoGdsKDMcG8ffJIgPO8Vm6UwM8PudZkDhBBIkT5SBxgmKN4kQPdmp2Bzr2CUCjPDFL89ETmPLRk4KMDT6JIR89CTj7nOzzfNTS4ckM+ejJPs9HTxT9RuejyPGexZSPzmqGnZrc5XFuJOUuj3P7KEyYhQWdIiazepkFnaJgQfUKFtRWr3FJDeQaEF1GdQowENYDJ2S/vr7OS6Z3ChPTOzXI2OBTGZjeqUDDmu1zpmfpcDYD05vtc6ZXL/qNZnrI8T6Niemd1gw7Dyf6I/A322Lq6SIIniEzhNMVi6lneLDzwDUgugzhdGC7zsjSnQfgWpGRjc4yRzjLmbKzzFE4y5ke7DxwDYius8wBOsuZPt95sALDHIadB2TAOYuZ9cT0noZt3eOD+LE5G6hDNylPTO8xzgYzLPuZG2Rs8NwgXu45zGlKTO9p6Pc5wXUKBsllaasVUM5icLJzmRbG0OwFaUvnASdejrHmCqjng8canc5ZYwy0R8Ma5/MZ/NuaTKy33LQOJD9oW/Dp5d/yU8Ym21g3CVp/2ptFF5h6mWeWC81ykVkuNsslZrnULJfJDN/6cHupbp6i7kJF3UWKuosVdZco6i5V1F0WXNcJ+0H/an0iMFheAJBVW2c9MWMeSJbVxwshsv7T10X6suJ29nSxrqyidZnYJXqyYs6s7lIdWfHEDPGyYHYG00m5YKoMppebernCLFeaZb5ZFpjlKrNcbZZr5GB6uSKoXaGou1JRN19Rt0BRd5Wi7mpF3TUeBFPkJUqXA4PpFcBgeiUwmM4HBtMFwGB6FTCYXg0MptcwBSX5DKSu7Q4A+kEMKOtaYMbg5TIRsN0Jy0QLg4wNXsiwTHSdz5eJrH5fx5RGOtvrfNAHmFcDZfXIx8k6sANOn3kO/V0vxusGmb1YwCyp7gZR53zyW+AA6Drf9U135Oo0sowbwCmGNc6qXdaAy3FO126nTHQgup5pxrhRdpIbg8lRCU0nXHTGSNeZG4EzyE1BmDEknI+5SRFk0Dq9AagHpE5vdqHTdN/l1OnNQqde0rYbmJzwliBjg29hoG23+py2Wf2+NUt2964XbUXv+FR3bdZ+pw3cNzD1u8ajy75123kbMHcFjrWB1J8zYFv9nRZIfPLBOuViobrtur2FjfXtYqxVC/zAneO49R87fjZBXjzWhMeOSyh/t9dZm2ibsSbYE5SI3BrkiZcB3DjHrOmETba0MRIRf7/D1Msis9xplsVmucssd5vlHrPca5b7zLLELEvNcr9ZHjDLg2Z5yCzL5KzqDsUGxiJF3Z2KusWKursUdXcr6u5R1N2rqLtPUbdEUbdUUXe/ou4BRd2DirqHFHXLgskbO12kAferM+pOFHcAN4kWATeJ7gRuEi0GbhLdBdwkuhu4SXQPcJPo3sxlJZ3vvi9DWSV1yXa/JDNZZSofWpqJrDK1P97vXlZpKt9+wK2s0tRx4kF3suJUzHnIjaxSOn4tC+LIGIicNsiqAf/s1SKe9r6L80G/g+COII6YLMLIakjG70TIEmn9Yn1ZjQsEd+nKciw13K0nK2HR4h4dWdLyx71MJBttu/cBbXcJ0HaXAm33fqDtPgC03QeBtvsQ0HaXMdmu5kJA0gLjKcBFlvos6fMMYJ/RL7i2n4fFQvxy8ecj4s8VQUalLAcrxm68RjuTHtUvgDmc4mGwYzyM31GKPczkcJpjRv6q+FFhE4/Jqz0WIL+k5zFHBzWVl3KQ0VsphzXvFlK6J6Uxat9dw7SFpPkr8qRs/lHgytNjwCABtBvj8Cx9+dGjhD51Xn70eJCxwZbwdDOQ2+95HGhYTzCfO0Do8IkmzI5uv+eJIG8gRgSPJ4L4lx8hx/tJoA6dE7sld3hA/fIjcMCPy2wuXlRTUlUZK60rrawsq4sVVcVrzD9K6kpL64rjleVDqiuLSstqqmorq4ZUl8era+I1pvhY8ZDaIeUltbVF1fVgdmjJqgDKWy7kJflTVVlNeVFJZW15WalhxItjxaWlxcVFpsrKquM11eXFNbXVxZVl5dW1pdU1NdVFRknlkNLiInN9sqTcMKqKHgvyTPABuZ0u+ytXOG1ppQj8q2S2uVLBNlfh2GZSIyuYWNcMn7PNCpEGovs9k4lttpP7D3QaXea6EhjYVwEDopO56soCMlcD6BvGzCxl1CuZGPXqIGODVzMw6tXAGfYpnzNqS4dPMTDqp3zOqFeJfqMZNXK8n2Zi1E8LRu185PdZawbnGuRyh3MC0pxkixOWTjRlOScgJDnzE+Hx8pWzjwBtJhszkGfERPmsnIE8o8hAnnV00H7Qr5zlGhBddvsMMMg+C96V84qtPcPE1p4LMjb4OQa29hzQSJ/3OVuzdPg8A1t73uds7VnRbzRbQ473C0xs7YVg+pe/y7/z0WVvyMC/Ard84FdWWfRsFrKNF0Wgf0lmGy8pmEW7nIG5bheXgemypxeBQe+lLGVPLzKxp5eDjA1+mYE9vQw0+Fd8zp4sHb7CwJ5e8Tl7ekn0G82ekOP9KhN7elWx1qWpXzKgxjQfZzvRb1vM/XDCjaSW98MJPy2lcPpB7kcYbiS1vB9h+I0Ue3Wd/YoszGJfE4T7dTmLfU2xZv66IrNFvw1yBTBTew1olK9naab2GlOm9kaQscFvMGRqbwAztTd9nqlZOnyTIVN70+eZ2uui3+hMDTnebzFlam8F3V9yqr1TDvQpjQDbbPc2vi2C4P/k2fNt4XzOuv81YcfZrwOiOxO/DXSg/wENxcvjGTP9wUaazVneEc7yruws7yic5V0PjmdwDYius7wDbNe7YENBz9hWYHgniL/kFBlw3svSfBS4SehZkHhfBIk1cpB4X5GPrvEgH30E6NjvA41yTZbmo+8z5aMfBBkb/AFDPvoBkKp96PN81NLhhwz56Ic+z0fXiH6j81HkeH/ElI9+1Az5KPC1OMYaMHOSH5Rsp14/FkHwE3n2/FhBsT/xIB/lGhDdmfhjoAN9kqX5aL0/2EizOcta4Syfys6yVuEsn3qQj3INiK6zrAW261Of56NWYFjLkI8iA85nzKwnpvc0LPa9F8SPzedAHXp5Lc/nYIZlP18EGRv8RRAv90vmNCWm9zT0+8vgOgWD5LK01QoonzE42VdMi0Zoqo+0pa+BLJVjrLkC6jfgsUYzVGuMgfZoWOP8DYN/e3lPvE9fRCk/nt8T/62pl+/M8r1ZfjDLj2b5ySw/m+UXmeFbH5av9fhOUfe9ou4HRd2PirqfFHU/K+p+CfLfE/8wMFh+C5BlXwHyHUiW1cfvIbL+09cP+rIarwD5UVeW4wqQn/RkJVwB8rOOLOkKkF+C2RlMl+eCqTKY/mrq5Tez/G6WP8zyp1n+MsvfZvlHDqa/KoLab4q63xV1fyjq/lTU/aWo+1tR948HwXQ5MJj+CgymvwGD6e/AYPoHMJj+CQymfwGD6d/AYPoPU1BCXxA6AOgHyAt7/wVmDF4uEwHbnbBMFAgxNtgSjpbbKuTvZSKr361C6/QLktt4KYXK2NDHWqKtcLIq83Gy7uqA02eeQ395YrxahwKJjMECZkl1rUWd88lvgQOg63x5TXfktNcdtw5hHa1h7AOpn6Z+V7p2O2WiA1FeiGfGaCM7SZtQclRC0wkXnUl7d3sb4AySH4IZQ8L5mHxFkEHrtDVQD0idtnWh03Tf5dRpW6FTL2lbayYnbBdibHA7BtrW3ue0zep3ewbaxtHWPNFW9I7PnOZ9h33awN2aqd9nMr3DHh2wO+CCiQEcawOpP2fAtvo7LZD45IN1ysVCddvVsYWNdUcx1qoFfuDOccPdzHb8bIK8eKwJjx2XUP5ur7M20TZjTbAnKBFpH+KJlwHcOMes6YRNtrQxEhF/72TqpcAsQbOEzBI2S8QsUbMUmqWzWbqYpatZupmlu1l6mKWnWXrJWZUlTN7AKFDUBRV1IUVdWFEXUdRFFXWFirrOirouirquirpuirruiroeirqeirpeoeSNnS7SgPvVGXUnik4hTB+tTaKCEE5fQYis//QV0pfVuEkU1pXl2CSK6MlK2CSK6siSNokKM5eVdL67c4aySuqS7b5LZrLKVD7UNRNZZWp/7OZeVmkq3+7uVlZp6jjRw52sOBVzerqRVUrHr14hHBkDkdMGWWeC7+awiKfzMnD7seca0HcZnUI4YlKAkdWQjAcRskRaH9KX1bhAENaV5VhqiOjJSli0iOrIkpY/CplINtp2OwNttwvQdrsCbbcb0Ha7A223B9B2ewJttxeT7WouBCivnkf5QX0wO/o8A9hn4AulYs55trdYiO8j/uwr/uwXYlRKnxBWMXbjNdqZ9Kh+AczhFL1DWMfojd9RivVmCjKaY0b+qng9YRP95dUeC5BfYNPf0UFN5aUcZPRWysU+vwa5nqnflzBtIYHvYDfWA6489QcGCaDdGJdk6RXB6xH61Hn50fohxgZbwtPNQG6/Z32gYW3AfO4AocMNmjA7uv2eDUK8gRgRPDYI4V9+hBzvDcGHd+yJ3ZI7PKB++RE44MdlNqd7L3w9mB1asiqAKUkfIS/JnzTvCOufhWxzIxH4N5bZ5kYKtrkxjm0mNbKCiXVd6nO2WSHSQHS/L2Nim/JFhEin0WWuGwED+8bAgOhkrrqygMzVAPqGcVmWMuqNmBj1gBBjgwcwMOoBwBl7E58zakuHmzAw6k18zqg3Fv1GM2rkeG/KxKg3DSVfRNhW0oPu7bXI5Q7nBKQ5yRYnLJ1oynJOQEhy5ifC4+VbNPsCbSYbM5DNxEQ5UM5ANlNkIAMdHbQf9Fs0uQZEl91uBgyyA0NYZ/GKrW3GxNY2DzE2eHMGtrY50EgH+ZytWTocxMDWBvmcrQ0U/UazNeR4b8HE1rYIpX/5u/w7H132hgz8/XDLB35llUUDs5BtDBaBfkuZbWypYBbtcgbmul1cBqbLngYDg96WWcqeBjOxp1iIscExBvYUAxq84XP2ZOnQYGBPhs/Z05ai32j2hBzvOBN7iivWujT1SwbUmObjbCf6bYu5H064kdTyfjjhp6UUTj/I/QjDjaSW9yMMv5Firy457ZeFWewQQbiL5Cx2iGLNvEiR2aLfBtkPmKkNARplUZZmakOYMrXiEGODixkytWJgplbi80zN0mEJQ6ZW4vNMrUj0G52pIce7lClTKw15f8kp8Cd5hkaAbbZ7G8tEECyXZ88y4XzOuvIm7Dj7dUB0Z+IyoAOVAw3Fy+MZM4PYQIfSgaLrLM6ylXCWrWVn2UrhLFt7cDyDa0B0nWUroLNsDTYU9IxtBYatQnBniyMDzjZZmo/2BbM1+clQNhkkthVBYqgcJLZV5KNDPchH+wIde1ugUQ7N0nx0W6Z8dLsQY4O3Y8hHtwPmo8N8no82DDpDPjrM5/noUNFvdD6KHO/hTPno8GbIR4GvxTGGgpmT/KBkO/U6QgTB7eXZc4SCYm/vQT7KNSC6M/EIoANtn6X5aH0QHOhAOlB0ncVZRgpnGSU7y0iFs4zyIB/lGhBdZxkJdJZRPs9HrcAwkiEfRQac0cysJ6b3NCz2bRPCj80OQB16eS3PDmCGZT9jQowNHhPCy92ROU2J6T0N/d4xtE7BILksbbUCymgGJ9uJadEITfWRtrQzMBXnGGuugLoLeKzRDNUaY6A9GtY478Lg317eE+/TF1HKj+f3xI819TLOLOPNMsEsu5plN7NMNMskmeFbH5av9RinqBuvqJugqNtVUbebom6iom5SiP+e+N7AYDkWIMu+AmQcSJbVx/EQWf/pa4K+rMYrQHbVleW4AmQ3PVkJV4BM1JElXQEyKZSdwbRPLpgqg+nupl72MMueZtnLLHubZbJZ9jFLhRxMd1cEtT0UdXsq6vZS1O2tqJusqNtHUVfhQTDtAwymuwOD6R7AYLonMJjuBQymewOD6WRgMN0HGEwrmIIS+oLQAcDlSuSFvfsCMwYvl4mA7U5YJpoSYmzwFIZlov18vkxk9Xs/pjTS2V7ngz7WMrkVTtat+ThZf3TA6TPPob/9xXhVyuzFAmZJdZWizvnkt8AB0HW+/ZvuyGmvO64EpxjWOKt2WQMuxzldu50y0YFof6YZo0p2kqpQclRC0wkXnUl7d3sVcAapDsGMIeF8TLUiyKB1WgnUA1KnNS50mu67nDqtETr1krZVMjlhbYixwbUMtK3O57TN6nddluzu7S/ait7xuaN532GfNnBXMvV7EdM77NEB+wBg7gocawOpP2fAtvo7LZD45IN1ysVCddt1YAsb6wPFWKsW+IE7xw13M9vxswny4rEmPHZcQvm7vc7aRNuMNcGeoESkLsQTLwO4cY5Z0wmbbGljJCL+PtXUy0FmOdgsh1j2bJbpZjnULIeZ5XCzzDDLTLMcYZYjzXKUWY42yzFyVjVVsYFxkKLuYEXdIYq6aYq66Yq6QxV1hynqDlfUzVDUzVTUHaGoO1JRd5Si7mhF3TGh5I2dLtKA+9UZdSeKqcBNooOAm0QHAzeJDgFuEk0DbhJNB24SHQrcJDosc1lJ57sPz1BWSV2y3c/ITFaZyodmZiKrTO2PR7iXVZrKt490K6s0dZw4yp2sOBVzjnYjq5SOX8eEcGQMRE4bZC0C381hEU/nZeD2Y881oO8ypoZwxOQgjKyGZPxghCyR1h+iL6txgWCarizHUsN0PVkJixaH6siSlj8OYyLZaNs9HGi7M4C2OxNou0cAbfdIoO0eBbTdo4G2ewyT7WouBCivnkf5AfDHrKx9ngHsM/CFUjHnPHusWIg/Tvx5vPjzhBCjUo4LYRVjN16jnUmP6hfAHE5xbAjrGMfid5RixzIFGc0xI39VfKKwiZPk1R4LkF9gc5Kjg5rKSznI6K2UB31+DXI9U78fYtpCAt/BbpwIXHk6CRgkgHZjPJSlVwSfSOhT5+VHJ4cYG2wJTzcDuf2ek4GGNYv53AFCh7OaMDu6/Z5ZId5AjAges0L4lx8hx/sU8OEde2K35A4PqF9+BA74cZnN6d4LXw9mh5asCmBKcpyQl+RPmneEnZSFbLNeBP5TZbZZr2Cbp+LYZlIjK5hY1zKfs80KkQai+/0wE9uULyJEOo0uc60HBvZTgQHRyVx1ZQGZqwH0DePhLGXU9UyMenaIscGzGRj1bOCMfZrPGbWlw9MYGPVpPmfUp4p+oxk1crxPZ2LUp4eSLyJsK+lB9/Za5HKHcwLSnGSLE5ZONGU5JyAkOfMT4fHyLZrHA20mGzOQM8REOUfOQM5QZCBzHB20H/RbNLkGRJfdngEMsnNCWGfxiq2dwcTWzgwxNvhMBrZ2JtBIz/I5W7N0eBYDWzvL52xtjug3mq0hx/tsJrZ2dij9y9/l3/nosjdk4D8Bt3zgV1ZZNCcL2cZcEejPkdnGOQpm0S5nYK7bxWVguuxpLjDonZOl7GkuE3s6N8TY4HMZ2NO5QIM/z+fsydLheQzs6Tyfs6dzRL/R7Ak53uczsafzFWtdmvolA2pM83G2E/22xdwPJ9xIank/nPDTUgqnH+R+hOFGUsv7EYbfSLFXl5yekIVZ7AWCcM+Ts9gLFGvm8xSZLfptkCcAM7ULgEY5L0sztQuYMrULQ4wNvpAhU7sQmKld5PNMzdLhRQyZ2kU+z9TmiX6jMzXkeF/MlKldHPL+klPgT/IMjQDbbPc2XiKC4KXy7HmJcD5n3aVN2HH264DozsSXAB3oUqCheHk8Y2YQG+hQOlB0ncVZLhPOcrnsLJcpnOVyD45ncA2IrrNcBnSWy8GGgp6xrcBwWQh/ySky4FyRpfno8WC2Jj8ZyiaDxJUiSMyXg8SVinx0vgf56PFAx74SaJTzszQfvZIpH10QYmzwAoZ8dAEwH73K5/mopcOrGPLRq3yej84X/Ubno8jxvpopH726GfJR4GtxjPlg5iQ/KNlOvV4jguC18ux5jYJiX+tBPso1ILoz8TVAB7o2S/PR+iA20KF0oOg6i7MsFM5ynewsCxXOcp0H+SjXgOg6y0Kgs1zn83zUCgwLGfJRZMC5npn1xPSehsW+K0L4sbkBqEMvr+W5Acyw7OfGEGODbwzh5d7EnKbE9J6Gft8UWqdgkFyWtloB5XoGJ7uZadEITfWRtnQLMBXnGGuugHoreKzRDNUaY6A9GtY438rg317eE+/TF1HKj+f3xN9m6uV2s9xhlkVmudMsi81yl1nulhm+9WH5Wo/bFXV3KOoWKeruVNQtVtTdpai7O8R/T/yxwGB5G0CWfQXI7SBZVh/vgMj6T1+L9GU1XgFyp64sxxUgi/VkJVwBcpeOLOkKkLtD2RlMj8sFU2UwvcfUy71muc8sS8yy1Cz3m+UBszwoB9N7FEHtXkXdfYq6JYq6pYq6+xV1DyjqHvQgmB4HDKb3AIPpvcBgeh8wmC4BBtOlwGB6PzCYPgAMpg8yBSX0BaEDgMuVyAt7HwJmDF4uEwHbnbBMtCzE2OBlDMtED/t8mcjq98NMaaSzvc4HfazlulY4WT/m42Rt3xGnzzyH/paL8XpEZi8WMEuqe0TUOZ/8FjgAus63vOmOnPa640fAKYY1zqpd1oDLcU7XbqdMdCBazjRjrJCdZEUoOSqh6YSLzqS9u30FcAZ5NAQzhoTzMY8qggxap48A9YDU6WMudJruu5w6fUzo1Eva9giTEz4eYmzw4wy07Qmf0zar309kye7ectFW9I7Py837Dvu0gfsRpn6/wvQOe3TAfhKYuwLH2kDqzxmwrf5OCyQ++WCdcrFQ3XatbGFjvVKMtWqBH7hz3HA3sx0/myAvHmvCY8cllL/b66xNtM1YE+wJSkSeCPHEywBunGPWdMImW9oYiYi/rzL1stosT5nlabM8Y5ZnzfKcWZ43ywtmedEsL5nlZbO8YpZXzfKaWV6Xs6pVig2M1Yq6pxR1TyvqnlHUPauoe05R97yi7gVF3YuKupcUdS8r6l5R1L2qqHtNUfd6KHljp4s04H51Rt2JYhVwk2g1cJPoKeAm0dPATaJngJtEzwI3iZ4DbhI9n7mspPPdL2Qoq6Qu2e5fzExWmcqHXspEVpnaH192L6s0lW+/4lZWaeo48ao7WXEq5rzmRlYpHb9eD+HIGIicNsh6BXw3h0U8nZeB248914C+y1gVwhGT1RhZDcn4UwhZIq1/Wl9W4wLBM7qyHEsNz+rJSli0eE5HlrT88TwTyUbb7gtA230RaLsvAW33ZaDtvgK03VeBtvsa0HZfZ7JdzYUA5dXzKD8A/piVtc8zgH0GvlAq5pxn3xAL8W+KP98Sf74dYlTKmyGsYuzGa7Qz6VH9ApjDKd4IYR3jDfyOUuwNpiCjOWbkr4r/J2ziHXm1xwLkF9i84+igpvJSDjJ6K+V9n1+DXM/U7zVMW0jgO9iN/wFXnt4BBgmg3RhrsvSK4P8R+tR5+dG7IcYGW8LTzUBuv+ddoGG9x3zuAKHD95owO7r9nvdCvIEYETzeC+FffoQc7/fBh3fsid2SOzygfvkROODHZTaney98PZgdWrIqgCnJm0Jekj9p3hH2ThayzTUi8H8gs801Crb5AY5tJjWygol1feBztlkh0kB0vz9kYpvyRYRIp9FlrmuAgf0DYEB0MlddWUDmagB9w/gwSxn1GiZG/WGIscEfMjDqD4Ez9kc+Z9SWDj9iYNQf+ZxRfyD6jWbUyPH+mIlRfxxKvoiwraQH3dtrkcsdzglIc5ItTlg60ZTlnICQ5MxPhMfLt2i+BbSZbMxAPhET5Vo5A/lEkYGsdXTQftBv0eQaEF12+wkwyK4NYZ3FK7b2CRNb+zTE2OBPGdjap0Aj/cznbM3S4WcMbO0zn7O1taLfaLaGHO/Pmdja56H0L3+Xf+ejy96Qgf9t3PKBX1ll0dosZBtfiED/pcw2vlQwi3Y5A3PdLi4D02VPXwCD3pdZyp6+YGJPX4UYG/wVA3v6CmjwX/ucPVk6/JqBPX3tc/b0peg3mj0hx/sbJvb0jWKtS1O/ZECNaT7OdqLftpj74YQbSS3vhxN+Wkrh9IPcjzDcSGp5P8LwGyn26pLTt7Mwi/1WEO7v5Cz2W8Wa+XeKzBb9Nsi3gZnat0Cj/C5LM7VvmTK170OMDf6eIVP7Hpip/eDzTM3S4Q8MmdoPPs/UvhP9RmdqyPH+kSlT+zHk/SWnwJ/kGRoBttnubfxJBMGf5dnzJ+F8zrqfm7Dj7NcB0Z2JfwI60M9AQ/HyeMbMIDbQoXSg6DqLs/winOVX2Vl+UTjLrx4cz+AaEF1n+QXoLL+CDQU9Y1uB4ZcQ/pJTZMD5LUvz0bfAbE1+MpRNBonfRZD4Qw4Svyvy0T88yEffAjr270Cj/CNL89HfmfLRP0OMDf6TIR/9E5iP/uXzfNTS4V8M+ehfPs9H/xD9RuejyPH+mykf/bsZ8lHga3GMP8DMSX5Qsp16/UcEwX/l2fMfBcX+14N8lGtAdGfif4AO9G+W5qP1QWygQ+lA0XUWZwmE//ujlfWn0zEsQHYW60PDpEah81GuAdF1lkAY1y6nHmPuHk/y0YYIGsbno8iAkxeGtYvlh+hW7v1bCD82rYF26OW1PK2B4+Vsb5swY4PbhPFy84EDyNXv/PA6BYPksrTVCih5YbyTtQUHF/tBU32kLbXD9dngGGuugNoePNZohmqNMdAeDWuc2zP4t5f3xPv0RZTy4/k98R3Mce1olk5mKTBL0Cwhs4TNEpEZvvVh+VqPjoq6Toq6AkVdUFEXUtSFFXWRMP898W8A2WcHQOC1rwDpCJJl9bETRNZ/+irQl9V4BUhQV5bjCpCQnqyEK0DCOrKkK0Ai4ewMpm/mgqkymEbN8Sw0S2ezdDFLV7N0M0t3s/SQg2lUEdQKFXWdFXVdFHVdFXXdFHXdFXU9PAimbwKDaRQYTAuBwbQzMJh2AQbTrsBg2g0YTLsDg2kPpgwMfUHoAOByJfLC3p7AjMHLZSJguxOWiXqFGRvci2GZqLfPl4msfvdmSiOd7XU+6GMtX7XCydqmLU7W3I44feY59NdHjFdfmb1YwCyprq+ocz75LXAAdJ2vT9MdOe11x33BKYY1zqpd1oDLcU7XbqdMdCDqwzRj9JOdpF84OSqh6YSLzqS9u70fcAZZLwwzhoTzMespggxap32BekDqtL8Lnab7LqdO+wudeknb+jI54fphxgavz0DbNvA5bbP6vUGW7O71EW1F7/j82rzvsE8buPsy9fs3pnfYowP2hsDcFTjWBlJ/zoBt9XdaIPHJB+uUi4XqtmujFjbWG4mxVi3wA3eOG+5mtuNnE+TFY0147LiE8nd7nbWJthlrgj1BicgGYZ54GcCNc8yaTthkSxsjEfH3jU29DDDLJmbZ1CybmWWgWTY3yyCzbGGWwWbZ0iwxsxhmiZtliFmK5KxqY8UGxgBF3SaKuk0VdZsp6gYq6jZX1A1S1G2hqBusqNtSURdT1BmKuriiboiiriicvLHTRRpwvzqj7kSxMXCTaABwk2gT4CbRpsBNos2Am0QDgZtEmwM3iQZlLivpfPcWGcoqqUu2+8GZySpT+dCWmcgqU/tjzL2s0lS+bbiVVZo6TsTdyYpTMWeIG1mldPwqCuPIGIicNsj6DXw3h0U8nZeB248914C+y9g4jCMmAzCyGpLxTRCyRFq/qb6sxgWCzXRlOZYaBurJSli02FxHlrT8MYiJZKNtdwug7Q4G2u6WQNuNAW3XANpuHGi7Q4C2W8Rku5oLAcqr50HtNIA/ZmXt8wxgn4EvlIo559lisRBfIv4sFX+WhRmVUhLGKsZuvEY7kx7VL4A5nKI4jHWMYvyOUqyYKchojhn5q+JyYRNbyas9FiC/wGYrRwc1lZdykNFbKW26+XvrrJ6p3/ndeIwRfAe7UQ5cedoKGCSAdmMgx8LLlx+VE/rUefnR1mHGBlvC081Abr9na6BhbcN87gChw22aMDu6/Z5twryBGBE8tgnjX36EHO9twYd37Indkjs8oH75ETjgx2U2p3svfD2YHVqyKoApSYmQl+RPmneEbZWFbHOoCPzbyWxzqIJtbodjm0mNrGBiXW19zjYrRBqI7nc7JrYpX0SIdBpd5joUGNi3AwZEJ3PVlQVkrgbQN4x2WcqohzIx6mFhzgYzMOphwBl7uM8ZtaXD4QyMerjPGfV2ot9oRo0c7xFMjHpEOPkiwraSHnRvr0UudzgnIM1Jtjhh6URTlnMCQpIzPxEeL9+iWQq0mWzMQLYXE+VIOQPZXpGBjHR00H7Qb9HkGhBddrs9MMiODGOdxSu2tj0TWxsVZmzwKAa2NgpopKN9ztYsHY5mYGujfc7WRop+o9kacrx3YGJrO4TTv/xd/p2PLntDBv4y3PKBX1ll0cgsZBtjRKDfUWYbOyqYRbucgbluF5eB6bKnMcCgt2OWsqcxTOxppzBjg3diYE87AQ1+Z5+zJ0uHOzOwp519zp52FP1GsyfkeO/CxJ52Uax1aeqXDKgxzcfZTvTbFnM/nHAjqeX9cMJPSymcfpD7EYYrSS3uRxh+I8VeXXJaloVZ7FhBuMfJWexYxZr5OEVmi34bZBkwUxsLNMpxWZqpjWXK1MaHGRs8niFTGw/M1Cb4PFOzdDiBIVOb4PNMbZzoNzpTQ473rkyZ2q5h7y85Bf4kz9AIsM12b+NuIghOlGfP3YTzOesmNmHH2a8DojsT7wZ0oIlAQ/HyeMbMIDbQoXSg6DqLs0wSzrK77CyTFM6yuwfHM7gGRNdZJgGdZXewoaBnbCswTArjLzlFBpw9sjQfLQWzNfnJUDYZJPYUQWIvOUjsqchH9/IgHy0FOvaeQKPcK0vz0T2Z8tG9w4wN3pshH90bmI9O9nk+aulwMkM+Otnn+eheot/ofBQ53vsw5aP7NEM+CnwtjrEXmDnJD0q2U68VIgjuK8+eFQqKva8H+SjXgOjOxBVAB9o3S/PR+iA20KF0oOg6i7NMEc6yn+wsUxTOsp8H+SjXgOg6yxSgs+zn83zUCgxTGPJRZMDZn5n1xPSehsW+PcL4sakE6tDLa3kqwQzLfqrCjA2uCuPlVjOnKTG9p6Hf1eF1CgbJ5Xnbg9nO/RmcrIZp0QhN9ZG2VAtMxTnGmiug1oHHGs1QrTEG2qNhjXMdg397eU+8T19EKT+e3xN/gKmXA80y1SwHmeVgsxxilmlmmS4zfOvD8rUeByrqpirqDlLUHayoO0RRN01RNz3Mf098MTBYHgCQZV8BciBIltXHqRBZ/+nrIH1ZjVeAHKwry3EFyCF6shKuAJmmI0u6AmR6ODuDaUkumCqD6aGmXg4zy+FmmWGWmWY5wixHmuUoOZgeqghqhynqDlfUzVDUzVTUHaGoO1JRd5QHwbQEGEwPBQbTw4DB9HBgMJ0BDKYzgcH0CGAwPRIYTI9iCkroC0IHAJcrkRf2Hg3MGLxcJgK2O2GZ6JgwY4OPYVgmOtbny0RWv49lSiOd7XU+6GMtxXk4Wae1xcl6rSNOn3kO/R0nxut4mb1YwCyp7nhR53zyW+AA6DrfcU135LTXHR8PTjGscVbtsgZcjnO6djtlogPRcUwzxgmyk5wQTo5KaDrhojNp724/ATiDnBiGGUPC+ZgTFUEGrdPjgXpA6vQkFzpN911OnZ4kdOolbTueyQlPDjM2+GQG2jbL57StYVbPkt2940Rb0Ts+fZr3HfZpA/fxTP3uy/QOe3TAPgWYuwLH2kDqzxmwrf5OCyQ++WCdcrFQ7bORLWys68VYqxb4gTvHDXcz2/GzCfLisSY8dlxC+bu9ztpE24w1wZ6gRGRWmCdeBnDjHLOmEzbZ0sZIRPz9VFMvs81ymllON8sZZpljljPNcpZZzjbLXLOcY5ZzzXKeWc43ywVmmSdnVacqNjBmK+pOU9Sdrqg7Q1E3R1F3pqLuLEXd2Yq6uYq6cxR15yrqzlPUna+ou0BRNy+cvLHTRRpwvzqj7kRxKnCTaDZwk+g04CbR6cBNojOAm0RzgJtEZwI3ic7KXFbS+e6zM5RVUpds93Mzk1Wm8qFzMpFVpvbHc93LKk3l2+e5lVWaOk6c705WnIo5F7iRVUrHr3lhHBkDkdMGWX3Bd3NYxNN5Gbj92HMN6LuMU8M4YjIbI6shGT8NIUuk9afry2pcIDhDV5ZjqWGOnqyERYszdWRJyx9nMZFstO2eDbTduUDbPQdou+cCbfc8oO2eD7TdC4C2O4/JdjUXApRXz6P8APhjVtY+zwD2GfhCqZhznr1QLMRfJP68WPx5SZhRKReFsYqxG6/RzqRH9QtgDqe4MIx1jAvxO0qxC5mCjOaYkb8qvlTYxGXyao8FyC+wuczRQU3lpRxk9FbKZj6/Brmeqd8DmbaQwHewG5cCV54uAwYJoN0YA7P0iuBLCX3qvPzo8jBjgy3h6WYgt99zOdCwrmA+d4DQ4RVNmB3dfs8VYd5AjAgeV4TxLz9CjveV4MM79sRuyR0eUL/8CBzw4zKb070Xvh7MDi1ZFcCU5CIhL8mfNO8IuywL2eZ8EfgXyGxzvoJtLsCxzaRGVjCxrs19zjYrRBqI7vcgJrYpX0SIdBpd5jofGNgXAAOik7nqygIyVwPoG8agLGXU85kY9VVhxgZfxcCorwLO2Ff7nFFbOryagVFf7XNGvUD0G82okeN9DROjviacfBFhW0kPurfXIpc7nBOQ5iRbnLB0oinLOQEhyZmfCI+Xb9G8GGgz2ZiBXCsmyoVyBnKtIgNZ6Oig/aDfosk1ILrs9lpgkF0YxjqLV2ztWia2dl2YscHXMbC164BGer3P2Zqlw+sZ2Nr1PmdrC0W/0WwNOd43MLG1G8LpX/4u/85Hl70hA/8luOUDv7LKooVZyDZuFIH+Jplt3KRgFu1yBua6XVwGpsuebgQGvZuylD3dyMSebg4zNvhmBvZ0M9Dgb/E5e7J0eAsDe7rF5+zpJtFvNHtCjvetTOzpVsVal6Z+yYAa03yc7US/bTH3wwk3klreDyf8tJTC6Qe5H2G4kdTyfoThN1Ls1SWnl2RhFnubINy3y1nsbYo189sVmS36bZCXADO124BGeXuWZmq3MWVqd4QZG3wHQ6Z2BzBTW+TzTM3S4SKGTG2RzzO120W/0ZkacrzvZMrU7gx7f8kp8Cd5hkaAbbZ7GxeLIHiXPHsuFs7nrLurCTvOfh0Q3Zl4MdCB7gIaipfHM2YGsYEOpQNF11mc5W7hLPfIznK3wlnu8eB4BteA6DrL3UBnuQdsKOgZ2woMd4fxl5wiA869WZqPXgxma/KToWwySNwngsQSOUjcp8hHl3iQj14MdOz7gEa5JEvz0fuY8tGlYcYGL2XIR5cC89H7fZ6PWjq8nyEfvd/n+egS0W90Pooc7weY8tEHmiEfBb4Wx1gCZk7yg5Lt1OuDIgg+JM+eDyoo9kMe5KNcA6I7Ez8IdKCHsjQfrQ9iAx1KB4quszjLMuEsD8vOskzhLA97kI9yDYiusywDOsvDPs9HrcCwjCEfRQac5cysJ6b3NCz23RvGj80jQB16eS3PI2CGZT8rwowNXhHGy32UOU2J6T0N/X40vE7BILksbbUCynIGJ3uMadEITfWRtvQ4MBXnGGuugPoEeKzRDNUaY6A9GtY4P8Hg317eE+/TF1HKj+f3xD9p6mWlWVaZZbVZnjLL02Z5xizPygzf+rB8rcdKRd0qRd1qRd1TirqnFXXPKOqeDfPfE38hMFg+CZBlXwGyEiTL6uMqiKz/9LVaX1bjFSBP6cpyXAHytJ6shCtAntGRJV0B8mw4O4PpRblgqgymz5l6ed4sL5jlRbO8ZJaXzfKKWV6Vg+lziqD2vKLuBUXdi4q6lxR1LyvqXlHUvepBML0IGEyfAwbT54HB9AVgMH0RGExfAgbTl4HB9BVgMH2VKSihLwgdAFyuRF7Y+xowY/BymQjY7oRlotfDjA1+nWGZ6A2fLxNZ/X6DKY10ttf5oI+1nJSHk/V8W5ysfp1w+sxz6O9NMV5vyezFAmZJdW+JOueT3wIHQNf53my6I6e97vgtcIphjbNqlzXgcpzTtdspEx2I3mSaMd6WneTtcHJUQtMJF51Je3f728AZ5H9hmDEknI/5nyLIoHX6FlAPSJ2+40Kn6b7LqdN3hE69pG1vMTnhu2HGBr/LQNve8zlts/r9Xpbs7r0p2ore8RnevO+wTxu432Lq9wimd9ijA/b7wNwVONYGUn/OgG31d1og8ckH65SLheq2a00LG+s1YqxVC/zAneOGu5nt+NkEefFYEx47LqH83V5nbaJtxppgT1Ai8l6YJ14GcOMcs6YTNtnSxkhE/P0DUy8fmuUjs3xslk/MstYsn5rlM7N8bpYvzPKlWb4yy9dm+cYs35rlOzmr+kCxgfGhou4jRd3HirpPFHVrFXWfKuo+U9R9rqj7QlH3paLuK0Xd14q6bxR13yrqvgsnb+x0kQbcr86oO1F8ANwk+hC4SfQRcJPoY+Am0SfATaK1wE2iT4GbRJ9lLivpfPfnGcoqqUu2+y8yk1Wm8qEvM5FVpvbHr9zLKk3l21+7lVWaOk58405WnIo537qRVUrHr+/CODIGIqcNskaA7+awiKfzMnD7seca0HcZH4RxxORDjKyGZPwjhCyR1n+sL6txgeATXVmOpYa1erISFi0+1ZElLX98xkSy0bb7OdB2vwDa7pdA2/0KaLtfA233G6Dtfgu03e+YbFdzIUB59TzKD4A/ZmXt8wxgn4EvlIo559nvxUL8D+LPH8WfP4UZlfJDGKsYu/Ea7Ux6VL8A5nCK78NYx/gev6MU+54pyGiOGfmr4p+FTfwir/ZYgPwCm18cHdRUXspBRm+ljPP5Ncj1TP0ez7SFBL6D3fgZuPL0CzBIAO3GGJ+lVwT/TOhT5+VHv4YZG2wJTzcDuf2eX4GG9RvzuQOEDn9rwuzo9nt+C/MGYkTw+C2Mf/kRcrx/Bx/esSd2S+7wgPrlR+CAH5fZnO698PVgdmjJqgCmJD8IeUn+pHlH2C9ZyDb/EIH/T5lt/qFgm3/i2GZSIyuYWNcEn7PNCpEGovu9KxPblC8iRDqNLnP9AxjY/wQGRCdz1ZUFZK4G0DeMXbOUUf/BxKj/CjM2+C8GRv0XcMb+2+eM2tLh3wyM+m+fM+o/Rb/RjBo53v8wMep/wskXEbaV9KB7ey1yucM5AWlOssUJSyeaspwTEJKc+YnwePkWzR+BNpONGci/9kRpHZF0Ouy/igzE+tAwqVHot2hyDYguu/0XOalGspOt/cvE1lpFGBtsCUeztVa4ATTyIv5ma5YOrTai2VpeBBst0f22nDQvgmdryPFuDdShM9BbclOtf9qP/DsfXfaGDPw/4ZYP/MoqiwKR7GMbbUSgz5fZRr6CWbTLGZjbh83AdNlTG2DQy89S9tQmwsOe2kYYG9yWgT21BbKndj5nT5YO2zGwp3Y+Z0/5ot9o9oQc7/ZM7Kl9JHmtS1O/ZECNaT7OdqLftpj74YQbSS3vhxN+Wkrh9IPcjzDcSGp5P8LwGyn26pLTn7JwzbyDINwd5SzWAuQ1846KzBb9NsifgOvcHYAEq2OWZmodmDK1ThHGBndiyNQ6ATO1Ap9napYOCxgytQKfZ2odRb/RmRpyvINMmVow4v0lp8Cf5BkaAbbZ7m0MiSAYlmfPkHA+Z124CTvOfh0Q3Zk4BHSgMNBQvDyeMTOIDXQoHSi6zuIsEeEsUdlZIgpniXpwPINrQHSdJQJ0lijYUNAzthUYIhG4s8WRAacwS/PRH7MwH+0sgkQXOUh0VuSjXTzIR38E5qOdgUbZJUvz0c5M+WjXCGODuzLko12B+Wg3n+ejlg67MeSj3Xyej3YR/Ubno8jx7s6Uj3ZvhnwU+FocowuYOckPSrZTrz1EEOwpz549FBS7pwf5KNeA6M7EPYAO1DNL89H6IDbQoXSg6DqLs/QSztJbdpZeCmfp7UE+yjUgus7SC+gsvX2ej1qBoRdDPooMOH2YWU9M72lY7CuM4MemL1CHXl7L0xfMsOynX4Sxwf0ieLnrMacpMb2nod/rRdYpGCSXpa1WQOnD4GT9wcHFftBUH2lL6wNTcY6x5gqoG4DHGs1QrTEG2qNhjfMGDP7t5T3xPn0Rpfx4fk/8hua4bmSWjc0ywCybmGVTs2xmloEyw7c+LF/rsZGibmNF3QBF3SaKuk0VdZsp6gZG+O+J/x54Om9DQOC1rwDZCCTL6uPGEFn/6WuAvqzGK0A20ZXluAJkUz1ZCVeAbKYjS7oCZGAkO4PpD7lgqgymm5vjOcgsW5hlsFm2NEvMLIZZ4nIw3VwR1AYp6rZQ1A1W1G2pqIsp6gxFXdyDYPoDMJhuDgymg4DBdAtgMB0MDKZbAoNpDBhMDWAwjTNlYOgLQgcAlyuRF/YOAWYMXi4TAdudsExUFGFscBHDMlGxz5eJrH4XM6WRzvY6H/SxllV5OFnd2+FkHdAJp888h/5KxHiVyuzFAmZJdaWizvnkt8AB0HW+kqY7ctrrjkvBKYY1zqpd1oDLcU7XbqdMdCAqYZoxymQnKYskRyU0nXDRmbR3t5cBZ5DyCMwYEs7HlCuCDFqnpUA9IHW6lQudpvsup063Ejr1kraVMjnh1hHGBm/NQNu28Tlts/q9TZbs7pWItqJ3fOqa9x32aQN3KVO/D2B6hz06YG8LzF2BY20g9ecM2FZ/pwUSn3ywTrlYqG67hrawsR4qxlq1wA/cOW64m9mOn02QF4814bHjEsrf7XXWJtpmrAn2BCUi20R44mUAN84xazphky1tjNi0YTtLL2YZbpYRZtneLCPNMsoso82yg1nGmGVHs+xklp3NsotZxpplnJxVbafYwBimqBuuqBuhqNteUTdSUTdKUTdaUbeDom6Mom5HRd1OirqdFXW7KOrGKurGRZI3drpIA+5XZ9SdKLYDbhINA24SDQduEo0AbhJtD9wkGgncJBoF3CQanbmspPPdO2Qoq6Qu2e7HZCarTOVDO2Yiq0ztjzu5l1Wayrd3diurNHWc2MWdrDgVc8a6kVVKx69xERwZA5HTBlkHgO/msIin8zJw+7HnGtB3GdtFcMRkGEZWQzI+HCFLpPUj9GU1LhBsryvLsdQwUk9WwqLFKB1Z0vLHaCaSjbbdHYC2OwZouzsCbXcnoO3uDLTdXYC2OxZou+OYbFdzIUB59TzKD4A/ZmXt8wxgn4EvlIo559nxIqOeIP7cVfy5W4RRKRMiWMXYjddoZ9Kj+gUwh1OMj2AdYzx+Ryk2ninIaI4Z+aviicImJsmrPRYgv8BmkqODmspLOcjorZSZPr8GuZ6p30cwbSGB72A3JgJXniYhAyZwi+KILL0ieCKhT52XH+0eYWywJTzdDOT2e3YHGtYezOcOEDrcowmzo9vv2SPCG4gRwWOPCP7lR8jx3hOoQ+fEbskdHlC//Agc8OMym9O9F74ezA4tWRXAlGSCkJfkT5p3hE3KQra5lwj8e8tscy8F29wbxzaTGlnBxLqO9DnbrBBpILrfRzGxTfkiQqTT6DLXvYCBfW9gQHQyV11ZQOZqAH3DOCpLGfVeTIx6coSxwZMZGPVk4Iy9j88ZtaXDfRgY9T4+Z9R7i36jGTVyvCuYGHVFJPkiwraSHnRvr0UudzgnIM1Jtjhh6URTlnMCQpIzPxEeL9+iuSvQZrIxA9lXTJRT5AxkX0UGMsXRQftBv0WTa0B02e2+wCA7JYJ1Fq/Y2r5MbG2/CGOD92Nga/sBjXR/n7M1S4f7M7C1/X3O1qaIfqPZGnK8K5nYWmUk/cvf5d/56LI3ZODfDbd84FdWWTQlC9lGlQj01TLbqFYwi3Y5A3PdLi4D02VPVcCgV52l7KmKiT3VRBgbXMPAnmqABl/rc/Zk6bCWgT3V+pw9VYt+o9kTcrzrmNhTnWKtS1O/ZECNaT7OdqLftpj74YQbSS3vhxN+Wkrh9IPcjzDcSGp5P8LwGyn26pLT3bIwiz1AEO4D5Sz2AMWa+YGKzBb9NsjdgJnaAUCjPDBLM7UDmDK1qRHGBk9lyNSmAjO1g3yeqVk6PIghUzvI55nagaLf6EwNOd4HM2VqB0e8v+QU+JM8QyPANtu9jYeIIDhNnj0PEc7nrJvWhB1nvw6I7kx8CNCBpgENxcvjGTOD2ECH0oGi6yzOMl04y6Gys0xXOMuhHhzP4BoQXWeZDnSWQ8GGgp6xrcAwPYK/5BQZcA7L0nx0VzBbk58MZZNB4nARJGbIQeJwRT46w4N8dFegYx8ONMoZWZqPHs6Uj86MMDZ4JkM+OhOYjx7h83zU0uERDPnoET7PR2eIfqPzUeR4H8mUjx7ZDPko8LU4xgwwc5IflGynXo8SQfBoefY8SkGxj/YgH+UaEN2Z+CigAx2dpflofRAb6FA6UHSdxVmOEc5yrOwsxyic5VgP8lGuAdF1lmOAznKsz/NRKzAcw5CPIgPOccysJ6b3NCz2HRbBj83xQB16eS3P8WCGZT8nRBgbfEIEL/dE5jQlpvc09PvEyDoFg+SytNUKKMcxONlJTItGaKqPtKWTgak4x1hzBdRZ4LFGM1RrjIH2aFjjPIvBv728J96nL6KUH8/viT/F1Eu9WU41y2yznGaW081yhlnmyAzf+rB8rUe9ou5URd1sRd1pirrTFXVnKOrmRPjviR8PDJanAGTZV4DUg2RZfTwVIus/fc3Wl9V4BchpurIcV4Ccricr4QqQM3RkSVeAzIlkZzCdkAumymB6pqmXs8xytlnmmuUcs5xrlvPMcr4cTM9UBLWzFHVnK+rmKurOUdSdq6g7T1F3vgfBdAIwmJ4JDKZnAYPp2cBgOhcYTM8BBtNzgcH0PGAwPZ8pKKEvCB0AXK5EXth7ATBj8HKZCNjuhGWieRHGBs9jWCa60OfLRFa/L2RKI53tdT7oYy2R1jhZ+7fDyVrcCafPPIf+LhLjdbHMXixgllR3sahzPvktcAB0ne+ipjty2uuOLwanGNY4q3ZZAy7HOV27nTLRgegiphnjEtlJLokkRyU0nXDRmbR3t18CnEEujcCMIeF8zKWKIIPW6cVAPSB1epkLnab7LqdOLxM69ZK2XczkhJdHGBt8OQNtu8LntM3q9xUMtI2jrReJtqJ3fM5u3nfYpw3cFzP1ey7TO+zRAftKYO4KHGsDqT9nwLb6Oy2Q+OSDdcrFQnXbNb+FjfV8MdaqBX7gznHD3cx2/GyCvHisCY8dl1D+bq+zNtE2Y02wJygRuSLCEy8DuHGOWdMJm2xpY8SmDQvMv1xllqvNco1ZrjXLQrNcZ5brzXKDWW40y01mudkst5jlVrPcZpbb5axqgWID4ypF3dWKumsUddcq6hYq6q5T1F2vqLtBUXejou4mRd3NirpbFHW3KupuU9TdHkne2OkiDbhfnVF3olgA3CS6CrhJdDVwk+ga4CbRtcBNooXATaLrgJtE12cuK+l89w0ZyiqpS7b7GzOTVabyoZsykVWm9seb3csqTeXbt7iVVZo6TtzqTlacijm3uZFVSsev2yM4MgYipw2y5oLv5rCIp/MycPux5xrQdxkLIjhichVGVkMyfjVClkjrr9GX1bhAcK2uLMdSw0I9WQmLFtfpyJKWP65nItlo270BaLs3Am33JqDt3gy03VuAtnsr0HZvA9ru7Uy2q7kQoLx6HuUHwB+zsvZ5BrDPwBdKxZzz7B0io14k/rxT/Lk4wqiURRGsYuzGa7Qz6VH9ApjDKe6IYB3jDvyOUuwOpiCjOWbkr4rvEjZxt7zaYwHyC2zudnRQU3kpBxm9lXKZz69Brmfq9+VMW0jgO9iNu4ArT3cDgwTQbozLs/SK4LsIfeq8/OieCGODLeHpZiC333MP0LDuZT53gNDhvU2YHd1+z70R3kCMCB73RvAvP0KO931AHTondkvu8ID65UfggB+X2ZzuvfD1YHZoyaoApiSLhLwkf9K8I+zuLGSbS0TgXyqzzSUKtrkUxzaTGlnBxLqu8DnbrBBpILrfVzKxTfkiQqTT6DLXJcDAvhQYEJ3MVVcWkLkaQN8wrsxSRr2EiVHfH2Fs8P0MjPp+4Iz9gM8ZtaXDBxgY9QM+Z9RLRb/RjBo53g8yMeoHI8kXEbaV9KB7ey1yucM5AWlOssUJSyeaspwTEJKc+YnwePkWzTuBNpONGchDYqJcJmcgDykykGWODtoP+i2aXAOiy24fAgbZZRGss3jF1h5iYmsPRxgb/DADW3sYaKTLfc7WGgIBA1tb7nO2tkz0G83WkOP9CBNbeySS/uXv8u98dNkbMvAvxi0f+JVVFi3LQraxQgT6R2W28aiCWbTLGZjrdnEZmC57WgEMeo9mKXtawcSeHoswNvgxBvb0GNDgH/c5e7J0+DgDe3rc5+zpUdFvNHtCjvcTTOzpCcVal6Z+yYAa03yc7US/bTH3wwk3klreDyf8tJTC6Qe5H2G4kdTyfoThN1Ls1SWni7Mwi31SEO6Vchb7pGLNfKUis0W/DXIxMFN7EmiUK7M0U3uSKVNbFWFs8CqGTG0VMFNb7fNMzdLhaoZMbbXPM7WVot/oTA053k8xZWpPRby/5BT4kzxDI8A2272NT4sg+Iw8ez4tnM9Z90wTdpz9OiC6M/HTQAd6BmgoXh7PmBnEBjqUDhRdZ3GWZ4WzPCc7y7MKZ3nOg+MZXAOi6yzPAp3lObChoGdsKzA8G8FfcooMOM9naT56J5ityU+Gsskg8YIIEi/KQeIFRT76ogf56J1Ax34BaJQvZmk++gJTPvpShLHBLzHkoy8B89GXfZ6PWjp8mSEffdnn+eiLot/ofBQ53q8w5aOvNEM+CnwtjvEimDnJD0q2U6+viiD4mjx7vqqg2K95kI9yDYjuTPwq0IFey9J8tD6IDXQoHSi6zuIsrwtneUN2ltcVzvKGB/ko14DoOsvrQGd5w+f5qBUYXmfIR5EB501m1hPTexoW+56P4MfmLaAOvbyW5y0ww7KftyOMDX47gpf7P+Y0Jab3NPT7f5F1CgbJZWmrFVDeZHCyd5gWjdBUH2lL7wJTcY6x5gqo74HHGs1QrTEG2qNhjfN7DP7t5T3xPn0Rpfx4fk/8+6Ze1pjlA7N8aJaPzPKxWT4xy1qZ4Vsflq/1WKOo+0BR96Gi7iNF3ceKuk8UdWsj/PfE3wEMlu8DZNlXgKwBybL6+AFE1n/6+lBfVuMVIB/pynJcAfKxnqyEK0A+0ZElXQGyNpKdwXRRLpgqg+mnpl4+M8vnZvnCLF+a5SuzfG2Wb+Rg+qkiqH2mqPtcUfeFou5LRd1XirqvFXXfeBBMFwGD6afAYPoZMJh+DgymXwCD6ZfAYPoVMJh+DQym3zAFJfQFoQOAy5XIC3u/BWYMXi4TAdudsEz0XYSxwd8xLBN97/NlIqvf3zOlkc72Oh/0sZa9W+Nk3dIOJ+v3Tjh95jn094MYrx9l9mIBs6S6H0Wd88lvgQOg63w/NN2R0153/CM4xbDGWbXLGnA5zuna7ZSJDkQ/MM0YP8lO8lMkOSqh6YSLzqS9u/0n4AzycwRmDAnnY35WBBm0Tn8E6gGp019c6DTddzl1+ovQqZe07UcmJ/w1wtjgXxlo228+p21Wv39joG0cbf1BtBW947O4ed9hnzZw/8jU77uY3mGPDti/A3NX4FgbSP05A7bV32mBxCcfrFMuFqrbrj9a2Fj/IcZatcAP3DluuJvZjp9NkBePNeGx4xLK3+111ibaZqwJ9gQlIr9FeOJlADfOMWs6YZMtbYzYtOFP8y9/meVvs/xjln8tIGp+xix5ZmltljZmyTdLW7O0M0t7s3QwS8doIDGr+lOxgfGXou5vRd0/irp/FXVW4+S6Voq6PEVda0VdG0VdvqKuraKunaKuvaKug6KuYzR5Y6eLNOB+dUbdieJP4CbRX8BNor+Bm0T/ADeJ/gVuEln+oyErYZOolY4saZMoL3NZSee7W2coq6Qu2e7bZCarTOVD+ZnIKlP7Y1v3skpT+XY7t7JKU8eJ9u5kxamY08GNrFI6fnWM4sgYiJw2yLoLfDeHRTydl4Hbjz3XgL7L+DOCIyZ/YWQ1JON/I2SJtP4ffVmNCwT/6spyLDUE9Gw5YdGilY4safkjL4qzZU7bbR3F2W6bKM5286M4220bxdluuyjOdtsDbbcD0HY7Mtmu5kKA8up5lB8Af8zK2ucZwD4DXygVc86znaL//Vkg/gyKP0NRRqUURLGKsRuv0c6kR/ULYA6n6BTFOoYlD7wLEuvEFGQ0x4z8VXFY2EREXu2xAPkFNhFHBzWVl3KQ0VspD/v8GuR6pn4vZ9pCAt/BboSjuD5HgEECaDfG8iy9IjhM6FPn5UfRKGODLeHpZiC33xMFGlYh0OC5dFjYhNnR7fcURnkDMSJ4FEbxLz9CjndnoA6dE7sld3hA/fIjcMCPy2xO9174ejA7tGRVAFOSAiEvyZ807wiLZCHb7CICf1eZbXZRsM2uOLaZ1MgKJtb1iM/ZZoVIA9H9XsHENuWLCJFOo8tcuwADe1dgQHQyV11ZQOZqAH3DWJGljLoLE6PuFmVscDcGRt0NOGN39zmjtnTYnYFRd/c5o+4q+o1m1Mjx7sHEqHtEky8ibCvpQff2WuRyh3MC0pxkixOWTjRlOScgJDnzE+Hx8i2aQaDNZGMG0lNMlL3kDKSnIgPp5eig/aDfosk1ILrsticwyPaKYp3FK7bWk4mt9Y4yNrg3A1vrDTTSPj5na5YO+zCwtT4+Z2u9RL/RbA053n2Z2FrfaPqXv8u/89Flb8jAH8ItH/iVVRb1ykK20U8E+vVktrGeglm0yxmY63ZxGZgue+oHDHrrZSl76sfEnvpHGRvcn4E99Qca/Po+Z0+WDtdnYE/r+5w9rSf6jWZPyPHegIk9baBY69LULxlQY5qPs53oty3mfjjhRlLL++GEn5ZSOP0g9yMMN5Ja3o8w/EaKvbrkNJSFWeyGgnBvJGexGyrWzDdSZLbot0GGgJnahkCj3ChLM7UNmTK1jaOMDd6YIVPbGJipDfB5pmbpcABDpjbA55naRqLf6EwNOd6bMGVqm0S9v+QU+JM8QyPANtu9jZuKILiZPHtuKpzPWbdZE3ac/TogujPxpkAH2gxoKF4ez5gZxAY6lA4UXWdxloHCWTaXnWWgwlk29+B4BteA6DrLQKCzbA42FPSMbQWGgVG4s8WRAWdQluajQTBbk58MZZNBYgsRJAbLQWILRT462IN8NAh07C2ARjk4S/PRLZjy0S2jjA3ekiEf3RKYj8Z8no9aOowx5KMxn+ejg0W/0fkocrwNpnzUaIZ8FPhaHGMwmDnJD0q2U69xEQSHyLNnXEGxh3iQj3INiO5MHAc60JAszUfrg9hAh9KBousszlIknKVYdpYihbMUe5CPcg2IrrMUAZ2l2Of5qBUYihjyUWTAKWFmPTG9p2Gxb1AUPzalQB16eS1PKZhh2U9ZlLHBZVG83HLmNCWm9zT0uzy6TsEguSxttQJKCYOTbcW0aISm+khb2hqYinOMNVdA3QY81miGao0x0B4Na5y3YfBvL++J9+mLKOXH83vitzX1MtQs21n6sZYezDLCLNubZaTM8K0Py9d6DFXUbaeoG6aoG66oG6Go215RNzLKf098J2Cw3BYgy74CZChIltXH7SCy/tPXMH1ZjVeADNeV5bgCZISerIQrQLbXkSVdATIymp3BtCAXTJXBdJSpl9Fm2cEsY8yyo1l2MsvOZtlFDqajFEFttKJuB0XdGEXdjoq6nRR1OyvqdvEgmBYAg+koYDAdDQymOwCD6RhgMN0RGEx3AgbTnYHBdBemoIS+IHQAcLkSeWHvWGDG4OUyEbDdCctE46KMDR7HsEw03ufLRFa/xzOlkc72Oh/0sZaFrXGyfmiHkzWiAKfPPIf+Jojx2lVmLxYwS6rbVdQ5n/wWOAC6zjeh6Y6c9rrjXcEphjXOql3WgMtxTtdup0x0IJrANGPsJjvJbtHkqISmEy46k/bu9t2AM8jEKMwYEs7HTFQEGbROdwXqAanTSS50mu67nDqdJHTqJW3blckJd48yNnh3Btq2h89pm9XvPbJkd2+CaCt6x+e15n2HfdrAvStTv19neoc9OmDvCcxdgWNtIPXnDNhWf6cFEp98sE65WKhuu/ZqYWO9lxhr1QI/cOe44W5mO342QV481oTHjksof7fXWZtom7Em2BOUiOwR5YmXAdw4x6zphE22tDESEX/f29TLZLPsY5YKs+xrlilm2c8s+5ul0ixVZqk2S41Zas1SZ5YDzHKgnFXtrdjAmKyo20dRV6Go21dRN0VRt5+ibn9FXaWirkpRV62oq1HU1Srq6hR1ByjqDowmb+x0kQbcr86oO1HsDdwkmgzcJNoHuElUAdwk2he4STQFuEm0H3CTaP/MZSWd767MUFZJXbLdV2Umq0zlQ9WZyCpT+2ONe1mlqXy71q2s0tRxos6drDgVcw5wI6uUjl8HRnFkDEROG2S9Dr6bwyKezsvA7ceea0DfZewdxRGTyRhZDcn4PghZIq2v0JfVuECwr64sx1LDFD1ZCYsW++nIkpY/9mci2WjbrQTabhXQdquBtlsDtN1aoO3WAW33AKDtHshku5oLAcqr51F+APwxK2ufZwD7DHyhVMw5z04VC/EHiT8PFn8eEmVUykFRrGLsxmu0M+lR/QKYwymmRrGOMRW/oxSbyhRkNMeM/FXxNGET0+XVHguQX2Az3dFBTeWlHGT0VsqHPr8GuZ6p3x8xbSGB72A3pgFXnqYDgwTQboyPsvSK4GmEPnVefnRolLHBlvB0M5Db7zkUaFiHMZ87QOjwsCbMjm6/57AobyBGBI/DoviXHyHH+3Dw4R17YrfkDg+oX34EDvhxmc3p3gtfD2aHlqwKYEpykJCX5E+ad4RNz0K2OUME/pky25yhYJszcWwzqZEVTKzrY5+zzQqRBqL7/QkT25QvIkQ6jS5znQEM7DOBAdHJXHVlAZmrAfQN45MsZdQzmBj1EVHGBh/BwKiPAM7YR/qcUVs6PJKBUR/pc0Y9U/QbzaiR430UE6M+Kpp8EWFbSQ+6t9cilzucE5DmJFucsHSiKcs5ASHJmZ8Ij5dv0TwYaDPZmIEcLSbKY+QM5GhFBnKMo4P2g36LJteA6LLbo4FB9pgo1lm8YmtHM7G1Y6OMDT6Wga0dCzTS43zO1iwdHsfA1o7zOVs7RvQbzdaQ4308E1s7Ppr+5e/y73x02Rsy8B+CWz7wK6ssOiYL2cYJItCfKLONExXMol3OwFy3i8vAdNnTCcCgd2KWsqcTmNjTSVHGBp/EwJ5OAhr8yT5nT5YOT2ZgTyf7nD2dKPqNZk/I8Z7FxJ5mKda6NPVLBtSY5uNsJ/pti7kfTriR1PJ+OOGnpRROP8j9CMONpJb3Iwy/kWKvLjk9JAuz2FME4a6Xs9hTFGvm9YrMFv02yEOAmdopQKOsz9JM7RSmTO3UKGODT2XI1E4FZmqzfZ6pWTqczZCpzfZ5plYv+o3O1JDjfRpTpnZa1PtLTmcif9IYxc1wiq6zzJ6niyB4hjx7ni6cz1l3RhN2nP06ILoz8elABzoDaCheHs+YGcQGOpQOFF1ncZY5wlnOlJ1ljsJZzvTgeAbXgOg6yxygs5wJNhT0jG0FhjlR/CWnyIBzVpbmoweD2Zr8ZCibDBJniyAxVw4SZyvy0bke5KMHAx37bKBRzs3SfPRspnz0nChjg89hyEfPAeaj5/o8H7V0eC5DPnquz/PRuaLf6HwUOd7nMeWj5zVDPgp8LY4xF8yc5Acl26nX80UQvECePc9XUOwLPMhHuQZEdyY+H+hAF2RpPlofxAY6lA4UXWdxlnnCWS6UnWWewlku9CAf5RoQXWeZB3SWC32ej1qBYR5DPooMOBcxs56Y3tOw2HdWFD82FwN16OW1PBeDGZb9XBJlbPAlUbzcS5nTlJje09DvS6PrFAySy9JWK6BcxOBklzEtGqGpPtKWLgem4hxjzRVQrwCPNZqhWmMMtEfDGucrGPzby3viffoiSvnx/J74K029zDfLArNcZZarzXKNWa41y0KZ4Vsflq/1mK+oW6Cou0pRd7Wi7hpF3bWKuoVR/nvipwKD5ZUAWfYVIPNBsqw+LoDI+k9fV+nLarwC5GpdWY4rQK7Rk5VwBci1OrKkK0AWRrMzmB6UC6bKYHqdqZfrzXKDWW40y01mudkst5jlVjmYXqcIatcr6m5Q1N2oqLtJUXezou4WRd2tHgTTg4DB9DpgML0eGExvAAbTG4HB9CZgML0ZGExvAQbTW5mCEvqC0AHA5Urkhb23ATMGL5eJgO1OWCa6PcrY4NsZlonu8PkykdXvO5jSSGd7nQ/6WMuXrXGytm6Pk3V2AU6feQ79LRLjdafMXixgllR3p6hzPvktcAB0nW9R0x057XXHd4JTDGucVbusAZfjnK7dTpnoQLSIacZYLDvJ4mhyVELTCRedSXt3+2LgDHJXFGYMCedj7lIEGbRO7wTqAanTu13oNN13OXV6t9Cpl7TtTiYnvCfK2OB7GGjbvT6nbVa/782S3b1Foq3oHZ8/mvcd9mkD951M/f6T6R326IB9HzB3BY61gdSfM2Bb/Z0WSHzywTrlYqG67VrSwsZ6iRhr1QI/cOe44W5mO342QV481oTHjksof7fXWZtom7Em2BOUiNwb5YmXAdw4x6zphE22tDESEX9faurlfrM8YJYHzfKQWZaZ5WGzLDfLI2ZZYZZHzfKYWR43yxNmedIsK+WsaqliA+N+Rd0DiroHFXUPKeqWKeoeVtQtV9Q9oqhboah7VFH3mKLucUXdE4q6JxV1K6PJGztdpAH3qzPqThRLgZtE9wM3iR4AbhI9CNwkegi4SbQMuEn0MHCTaHnmspLOdz+SoaySumS7X5GZrDKVDz2aiawytT8+5l5WaSrfftytrNLUceIJd7LiVMx50o2sUjp+rYziyBiInDbI+hN8N4dFPJ2XgduPPdeAvstYGsURk/sxshqS8QcQskRa/6C+rMYFgod0ZTmWGpbpyUpYtHhYR5a0/LGciWSjbfcRoO2uANruo0DbfQxou48DbfcJoO0+CbTdlUy2q7kQoLx6HuUHwB+zsvZ5BrDPwBdKxZzz7CqxEL9a/PmU+PPpKKNSVkexirEbr9HOpEf1C2AOp1gVxTrGKvyOUmwVU5DRHDPyV8XPCJt4Vl7tsQD5BTbPOjqoqbyUg4zeSmnX3d9bZ/VM/W7fnccYwXewG88AV56eBQYJoN0YyLHw8uVHzxD61Hn50XNRxgZbwtPNQG6/5zmgYT3PfO4AocPnmzA7uv2e56O8gRgRPJ6P4l9+hBzvF8CHd+yJ3ZI7PKB++RE44MdlNqd7L3w9mB1asiqAKclqIS/JnzTvCHs2C9nmiyLwvySzzRcVbPMlHNtMamQFE+vq4HO2WSHSQHS/OzKxTfkiQqTT6DLXF4GB/SVgQHQyV11ZQOZqAH3D6JiljPpFJkb9cpSxwS8zMOqXgTP2Kz5n1JYOX2Fg1K/4nFG/JPqNZtTI8X6ViVG/Gk2+iLCtpAfd22uRyx3OCUhzki1OWDrRlOWcgJDkzE+Ex8u3aD4FtJlszEBeExPl63IG8poiA3nd0UH7Qb9Fk2tAdNnta8Ag+3oU6yxesbXXmNjaG1HGBr/BwNbeABrpmz5na5YO32Rga2/6nK29LvqNZmvI8X6Lia29FU3/8nf5dz667A0Z+J/GLR/4lVUWvZ6FbONtEej/J7ON/ymYRbucgbluF5eB6bKnt4FB739Zyp7eZmJP70QZG/wOA3t6B2jw7/qcPVk6fJeBPb3rc/b0P9FvNHtCjvd7TOzpPcVal6Z+yYAa03yc7US/bTH3wwk3klreDyf8tJTC6Qe5H2G4kdTyfoThN1Ls1SWnT2dhFvu+INxr5Cz2fcWa+RpFZot+G+TTwEztfaBRrsnSTO19pkztgyhjgz9gyNQ+AGZqH/o8U7N0+CFDpvahzzO1NaLf6EwNOd4fMWVqH0W9v+QU+JM8QyPANtu9jR+LIPiJPHt+LJzPWfdJE3ac/TogujPxx0AH+gRoKF4ez5gZxAY6lA4UXWdxlrXCWT6VnWWtwlk+9eB4BteA6DrLWqCzfAo2FPSMbQWGtVH8JafIgPNZluajT4HZmvxkKJsMEp+LIPGFHCQ+V+SjX3iQjz4FdOzPgUb5RZbmo58z5aNfRhkb/CVDPvolMB/9yuf5qKXDrxjy0a98no9+IfqNzkeR4/01Uz76dTPko8DX4hhfgJmT/KBkO/X6jQiC38qz5zcKiv2tB/ko14DozsTfAB3o2yzNR+uD2ECH0oGi6yzO8p1wlu9lZ/lO4Szfe5CPcg2IrrN8B3SW732ej1qB4TuGfBQZcH5gZj0xvadhse+zKH5sfgTq0MtreX4EMyz7+SnK2OCfoni5PzOnKTG9p6HfP0fXKRgkl6WtVkD5gcHJfmFaNEJTfaQt/QpMxTnGmiug/gYeazRDtcYYaI+GNc6/Mfi3l/fE+/RFlPLj+T3xv5t6+cMsf5rlL7P8bZZ/zPKvNd6FgUQ2b31YvtbjD0Xdn4q6vxR1fyvq/lHU/auosxrHfU/8KmCw/B0gy74C5A+QLKuPf0Jk/aevv/RlNV4B8reuLMcVIP/oyUq4AuRfHVnSFSCWDYNs1dNgujoXTJXBtJU5nnlmaW2WNmbJN0tbs7SzYpUcTFsVJge1PEVda0VdG0VdvqKuraKunaKuvQfBdDUwmLYqxAXTPJAsq4+tIbL+01ebQlwwzS/EBdO2hbhg2q4QF0zbF/IEJfQFoQOAy5XIC3s74PRneLlMBGx3wjJRx0LGBlvC0XI7FeKMgavfnQrXKRgkt/FSCpWxoY+1FLXByZrdHifr1QKcPvMc+isQ4xWU2YsFzJLqgqLO+eS3wAHQdb6Cpjty2uuOg+AUo4GlBlI/Tf2udO12ykQHogKmGSMkO0moMDkqoemEi86kvbs9BJxBwoUwY0g4HxNWBBm0ToNAPSB1GnGh03Tf5dRpROjUS9oWZHLCaCFjg6MMtK3Q57TN6nchA23jaGuBaCt6x2e95n2HfdrAHWTqd3+md9ijA3ZnYO4KHGsDqT9nwLb6Oy2Q+OSDdcrFQnXb1aWFjXUXMdaqBX7gznHD3cx2/GyCvHisCY8dl1D+bq+zNtE2Y02wJygRKSzkiZcB3DjHrOmETba0MRIRf+9q6qWbWbqbpYdZepqll1l6m6WPWfqapZ9Z1jNLf7Osb5YNzLKhWTaSs6quig2Mboq67oq6Hoq6noq6Xoq63oq6Poq6voq6foq69RR1/RV16yvqNlDUbaio26gweWOnizTgfnVG3YmiK3CTqBtwk6g7cJOoB3CTqCdwk6gXcJOoN3CTqE/mspLOd/fNUFZJXbLd98tMVpnKh9bLRFaZ2h/7u5dVmsq313crqzR1nNjAnaw4FXM2dCOrlI5fGxXiyBiInDbI6g++m8Mins7LwO3HnmtA32V0LcQRk24YWQ3JeHeELJHW99CX1bhA0FNXlmOpoZeerIRFi946sqTljz5MJBttu32BttsPaLvrAW23P9B21wfa7gZA290QaLsbMdmu5kKA8up5lB8Af8zK2ucZwD4DXygVc86zG4uF+AHiz03En5sWMiplQCFWMXbjNdqZ9Kh+AczhFBsXYh1jY/yOUmxjpiCjOWbkr4o3EzYxUF7tsQD5BTYDHR3UVF7KQUZvpQzy+TXI9Uz93oJpCwl8B7uxGXDlaSAwSADtxtgiS68I3ozQp87LjzYvZGywJTzdDOT2ezZHGhbzuQOEDgc1YXZ0+z2DCnkDMSJ4DCrEv/wIOd5bgA/v2BO7JXd4QP3yI3DAj8tsTvde+HowO7RkVQBTkgFCXpI/ad4RNjAL2eZgEfi3lNnmYAXb3BLHNpMaWcHEugb7nG1WiDQQ3e8tmdimfBEh0ml0metgYGDfEhgQncxVVxaQuRpA3zC2zFJGPZiJUccKGRscY2DUMeCMbficUVs6NBgYteFzRr2l6DeaUSPHO87EqOOFyRcRtpX0oHt7LXK5wzkBaU6yxQlLJ5qynBMQkpz5ifB4+RbNTYA2k40ZyBAxURbJGcgQRQZS5Oig/aDfosk1ILrsdggwyBYVYp3FK7Y2hImtFRcyNriYga0VA420xOdszdJhCQNbK/E5WysS/UazNeR4lzKxtdLC9C9/l3/no8vekIF/U9zygV9ZZVFRFrKNMhHoy2W2Ua5gFu1yBua6XVwGpsueyoBBrzxL2VMZE3vaqpCxwVsxsKetgAa/tc/Zk6XDrRnY09Y+Z0/lot9o9oQc722Y2NM2irUuTf2SATWm+TjbiX7bYu6HE24ktbwfTvhpKYXTD3I/wnAjqeX9CMNvpNirS043zcIsdltBuIfKWey2ijXzoYrMFv02yE2Bmdq2QKMcmqWZ2rZMmdp2hYwN3o4hU9sOmKkN83mm1jDoDJnaMJ9nakNFv9GZGnK8hzNlasMLvb/kFPiTPEMjwDbbvY0jRBDcXp49Rwjnc9Zt34QdZ78OiO5MPALoQNsDDcXL4xkzg+BAB9KBousszjJSOMso2VlGKpxllAfHM7gGRNdZRgKdZRTYUNAzthUYRhbCnS2ODDijszQf3QTM1uQnQ9lkkNhBBIkxcpDYQZGPjvEgH90E6Ng7AI1yTJbmozsw5aM7FjI2eEeGfHRHYD66k8/zUUuHOzHkozv5PB8dI/qNzkeR470zUz66czPko8DX4hhjwMxJflCynXrdRQTBsfLsuYuCYo/1IB/lGhDdmXgXoAONzdJ8tD6IDXQoHSi6zuIs44SzjJedZZzCWcZ7kI9yDYius4wDOst4n+ejVmAYx5CPIgPOBGbWE9N7Ghb7Rhfix2ZXoA69vJZnVzDDsp/dChkbvFshXu5E5jQlpvc09Hti4ToFg+SytNUKKBMYnGwS06IRmuojbWl3YCrOMdZcAXUP8FijGao1xkB7NKxx3oPBv728J96nL6KUH8/vid/T1MteZtnbLJPNso9ZKsyyr1mmyAzf+rB8rcdeirq9FXWTFXX7KOoqFHX7KuqmFPLfE78xMFjuCZBlXwGyF0iW1ce9IbL+09dkfVmNV4DsoyvLcQVIhZ6shCtA9tWRJV0BMqUwO4PpgFwwVQbT/Uy97G+WSrNUmaXaLDVmqTVLnRxM91MEtf0VdZWKuipFXbWirkZRV6uoq/MgmA4ABtP9gMF0f2AwrQQG0ypgMK0GBtMaYDCtBQbTOqaghL4gdABwuRJ5Ye8BwIzBy2UiYLsTlokOLGRs8IEMy0RTfb5MZPV7KlMa6Wyv80EfazmxDU7Wc+1xsvoCL/nIc+jvIDFeB8vsxQJmSXUHizrnk98CB0DX+Q5quiOnve74YHCKYY2zapc14HKc07XbKRMdiA5imjEOkZ3kkMLkqISmEy46k/bu9kOAM8i0QpgxJJyPmaYIMmidHgzUA1Kn013oNN13OXU6XejUS9p2MJMTHlrI2OBDGWjbYT6nbVa/D8uS3b2DRFvROz4jm/cd9mkD98FM/R7F9A57dMA+HJi7AsfaQOrPGbCt/k4LJD75YJ1ysVDdds1oYWM9Q4y1aoEfuHPccDezHT+bIC8ea8JjxyWUv9vrrE20zVgT7AlKRA4r5ImXAdw4x6zphE22tDESEX+faerlCLMcaZajzHK0WY4xy7FmOc4sx5vlBLOcaJaTzHKyRUjNcopZ6uWsaqZiA+MIRd2RirqjFHVHK+qOUdQdq6g7TlF3vKLuBEXdiYq6kxR1JyvqZinqTlHU1Rcmb+x0kQbcr86o/aNu4CbREcBNoiOBm0RHATeJjgZuEh0D3CQ6FrhJdFzmspLOdx+foaySumS7PyEzWWUqHzoxE1llan88yb2s0lS+fbJbWaWp48Qsd7LiVMw5xY2sUjp+1RfiyBiInDbIGgW+m8Mins7LwO3HnmtA32XMLMQRkyMwshqS8SMRskRaf5S+rMYFgqN1ZTmWGo7Rk5WwaHGsjixp+eM4JpKNtt3jgbZ7AtB2TwTa7klA2z0ZaLuzgLZ7CtB265lsV3MhQHn1PMoPgD9mZe3zDGCfgS+Uijnn2VPFQvxs8edp4s/TCxmVMrsQqxi78RrtTHpUvwDmcIpTC7GOcSp+Ryl2KlOQ0Rwz8lfFZwibmCOv9liA/AKbOY4Oaiov5SDDf4Xp82uQ65n6vRvTFhL4DnbjDODK0xxgkADajbFbll4RfAahT52XH51ZyNhgS3i6Gcjt95wJNKyzmM8dIHR4VhNmR7ffc1YhbyBGBI+zCvEvP0KO99ngwzv2xG7JHR5Qv/wIHPDjMpvTvRe+HswOLVkVwJRktpCX5E+ad4TNyUK2OVcE/nNktjlXwTbPwbHNpEZWMLGuiT5nmxUiDUT3exIT25QvIkQ6jS5znQsM7OcAA6KTuerKAjJXA+gbxqQsZdRzmRj1uYWMDT6XgVGfC5yxz/M5o7Z0eB4Doz7P54z6HNFvNKNGjvf5TIz6/MLkiwjbSnrQvb0WudzhnIA0J9nihKUTTVnOCQhJzvxEeLx8i+ZpQJvJxgzkAjFRzpMzkAsUGcg8RwftB/0WTa4B0WW3FwCD7LxCrLN4xdYuYGJrFxYyNvhCBrZ2IdBIL/I5W7N0eBEDW7vI52xtnug3mq0hx/tiJrZ2cWH6l7/Lv/PRZW/IwH86bvnAr6yyaF4Wso1LRKC/VGYblyqYRbucgbluF5eB6bKnS4BB79IsZU+XMLGnywoZG3wZA3u6DGjwl/ucPVk6vJyBPV3uc/Z0qeg3mj0hx/sKJvZ0hWKtS1O/ZECNaT7OdqLftpj74YQbSS3vhxN+Wkrh9IPcjzDcSGp5P8LwGyn26pLT07Mwi71SEO75chZ7pWLNfL4is0W/DfJ0YKZ2JdAo52dppnYlU6a2oJCxwQsYMrUFwEztKp9napYOr2LI1K7yeaY2X/Qbnakhx/tqpkzt6kLvLzkF/iTP0AiwzXZv4zUiCF4rz57XCOdz1l3bhB1nvw6I7kx8DdCBrgUaipfHM2YGsYEOpQNF11mcZaFwlutkZ1mocJbrPDiewTUgus6yEOgs14ENBT1jW4FhYSH+klNkwLk+S/PR08BsTX4ylE0GiRtEkLhRDhI3KPLRGz3IR08DOvYNQKO8MUvz0RuY8tGbChkbfBNDPnoTMB+92ef5qKXDmxny0Zt9no/eKPqNzkeR430LUz56SzPko8DX4hg3gpmT/KBkO/V6qwiCt8mz560Kin2bB/ko14DozsS3Ah3otizNR+uD2ECH0oGi6yzOcrtwljtkZ7ld4Sx3eJCPcg2IrrPcDnSWO3yej1qB4XaGfBQZcBYxs56Y3tOw2Hd9IX5s7gTq0Mtree4EMyz7WVzI2ODFhXi5dzGnKTG9p6HfdxWuUzBILktbrYCyiMHJ7mZaNEJTfaQt3QNMxTnGmiug3gseazRDtcYYaI+GNc73Mvi3l/fE+/RFlPLj+T3x95l6WWKWpWa53ywPmOVBszxklmUyw7c+LF/rsURRt1RRd7+i7gFF3YOKuocUdcsK+e+JPxUYLO8DyLKvAFkCkmX1cSlE1n/6ul9fVuMVIA/oynJcAfKgnqyEK0Ae0pElXQGyrDA7g+nsXDBVBtOHrc02szxilhVmedQsj5nlcbM8IQfThxVBbbmi7hFF3QpF3aOKuscUdY8r6p7wIJjOBgbTh4HBdDkwmD4CDKYrgMH0UWAwfQwYTB8HBtMnmIIS+oLQAcDlSuSFvU8CMwYvl4mA7U5YJlpZyNjglQzLRKt8vkxk9XsVUxppOWleIPWD6oOlk0LW7ygxmOSWZpfc0jhTe4uzTL9M9lBalGX6ZWpvPMbU3homuXXZpV82e6jmkTukkkeuw87aiKJK1bFf+t+EFRayIpJsvcypru4Ck8leFwTJq40Z83Dyaq2+X4iSV/ufLi/CyDPsjOVihLwhjhdCaMurqXNmVJfqyjMSM7TLtOSV1ckHLC7XkFdSm0R6jSsyl1eqINHGlZnKK1WScmN+ZvJKUpB8Y0Em8kpSJg3GVe7lGUQSYlztVl4JmdQY1wh5chyMacbYC1Cn9cxlxXkYWQ2Hfi5EyBLHhy7Sl9V4EOliXVmOI02X6MlKOBx1qY4s6ZjVZZnLSjqwdXmmsozkqisyk2WoKq/MRJahrp7vXpaRCljgVpaRGrrKnSyDAq92I8ug4WtwJ4RjaF74rXW1TwjHC7/DyWvghd+j5Ale+ANGXiMv/BEhz8ELf9KWl8gLf9aVJ/HCX7TkJfPCXzXkqXjhb5nLU/LC3zOVl4IX/pGZvJS88M9M5BG88C/38khe+LdbeWl44T9CHpoXfgvkhd8BeeH3QF74A5AX/gjkhT8BeeHPQF74C5AX/grkhb8BeeHvQF74B5AX/gnkhX8BeeHfQF74j4954Vgzxu4H5IXjcPIaeOF4lDzBCydg5DXywl0R8hy8cDdteYm8cKKuPIkXTtKSl8wLd9eQp+KFe2QuT8kL98xUXgpeuFdm8lLywr0zkUfwwsnu5ZG8cB+38tLwwgohD80Lx4ZwvHBcCMcLx4dwvHBCCMcLdw3heOFuIRwvnBjC8cJJIRwv3D2E44V7hHC8cM8QjhfuFcLxwr1DOF44OYTjhfuEcLywAhVzYnheeJvZtoeBvPB2nLwGXngHSp7ghYsw8hp54Z0IeQ5euFhbXiIvvEtXnsQL79aSl8wL79GQp+KF92YuT8kL78tUXgpeuCQzeSl54dJM5BG88H738khe+IBbeWl44YNCHpoX3gbkhbcDeeEdQF64CMgL7wTywsVAXngXkBfeDeSF9wB54b1AXngfkBcuAfLCpUBeeD+QFz4A5IUP+pgXdggHAr3DOF7YESevgRd2QskTvLAAI6+RFwYR8hy8MKQtL5EXhnXlSbwwoiUvmRdGNeSpeGFh5vKUvLBzpvJS8MIumclLyQu7ZiKP4IXd3MsjeWF3t/LS8MIeQh6aF3YI43hhxzCOF3YK43hhQRjHC4NhHC8MhXG8MBzG8cJIGMcLo2EcLywM43hh5zCOF3YJ43hh1zCOF3YL43hh9zCOF/ZAxZwYnhceYLbtWCAvPBAnr4EXTkXJE7zwIIy8Rl54MEKegxceoi0vkRdO05Un8cLpWvKSeeGhGvJUvPCwzOUpeeHhmcpLwQtnZCYvJS+cmYk8ghce4V4eyQuPdCsvDS88SshD88IDgLzwQCAvnArkhQcBeeHBQF54CJAXTgPywulAXngokBceBuSFhwN54QwgL5wJ5IVHAHnhkUBeeJSPeeGTZtveAPLClTh5DbxwFUqe4IWrMfIaeeFTCHkOXvi0trxEXviMrjyJFz6rJS+ZFz6nIU/FC5/PXJ6SF76QqbwUvPDFzOSl5IUvZSKP4IUvu5dH8sJX3MpLwwtfFfLQvPBJIC9cCeSFq4C8cDWQFz4F5IVPA3nhM0Be+CyQFz4H5IXPA3nhC0Be+CKQF74E5IUvA3nhK0Be+KqPeeGGpsDiCI4XboST18ALN0bJE7xwAEZeIy/cBCHPwQs31ZaXyAs305Un8cKBWvKSeeHmGvJUvHBQ5vKUvHCLTOWl4IWDM5OXkhdumYk8ghfG3MsjeaHhVl4aXhgX8tC8cMMIjhduFMHxwo0jOF44IILjhZtEcLxw0wiOF24WwfHCgREcL9w8guOFgyI4XrhFBMcLB0dwvHDLCI4XxiI4XmhEcLwwjoo5MTwvPMUUeCGQF9bj5DXwwlNR8gQvnI2R18gLT0PIc/DC07XlJfLCM3TlSbxwjpa8ZF54poY8FS88K3N5Sl54dqbyUvDCuZnJS8kLz8lEHsELz3Uvj+SF57mVl4YXni/koXnhKUBeWA/khacCeeFsIC88DcgLTwfywjOAvHAOkBeeCeSFZwF54dlAXjgXyAvPAfLCc4G88DwgLzzfx7zwfVPg90BeuAYnr4EXfoCSJ3jhhxh5jbzwI4Q8By/8WFteIi/8RFeexAvXaslL5oWfashT8cLPMpen5IWfZyovBS/8IjN5KXnhl5nII3jhV+7lkbzwa7fy0vDCb4Q8NC98H8gL1wB54QdAXvghkBd+BOSFHwN54SdAXrgWyAs/BfLCz4C88HMgL/wCyAu/BPLCr4C88GsgL/zGx7xw22ggMD6K44VDcfIaeOF2KHmCFw7DyGvkhcMR8hy8cIS2vEReuL2uPIkXjtSSl8wLR2nIU/HC0ZnLU/LCHTKVl4IXjslMXkpeuGMm8gheuJN7eSQv3NmtvDS8cBchD80Lt43ieOHQKI4XbhfF8cJhURwvHB7F8cIRURwv3D6K44UjozheOCqK44WjozheuEMUxwvHRHG8cMcojhfuFMXxwp2jOF64CyrmxPC88EqzbXcAeeF8nLwGXrgAJU/wwqsw8hp54dUIeQ5eeI22vEReeK2uPIkXLtSSl8wLr9OQp+KF12cuT8kLb8hUXgpeeGNm8lLywpsykUfwwpvdyyN54S1u5aXhhbcKeWheeCWQF84H8sIFQF54FZAXXg3khdcAeeG1QF64EMgLrwPywuuBvPAGIC+8EcgLbwLywpuBvPAWIC+81ce88HezbZ0KcbzwD5y8Bl74J0qe4IV/YeQ18sK/EfIcvPAfbXmJvPBfXXkSLwwU6shL5oWtNOSpeGFe5vKUvLB1pvJS8MI2mclLyQvzM5FH8MK27uWRvLCdW3lpeGF7IQ/NC38H8sI/gLzwTyAv/AvIC/8G8sJ/gLzwXyAvDBTieGGrQhwvzCvE8cLWhThe2KYQxwvzC3G8sG0hjhe2K8TxwvaF2v7Y+KB54Z5m26YCeeFeOHkNvHBvlDzBCydj5DXywn0Q8hy8sEJbXiIv3FdXnsQLp2jJS+aF+2nIU/HC/TOXp+SFlZnKS8ELqzKTl5IXVmcij+CFNe7lkbyw1q28NLywTshD88I9C3G8cK9CHC/cuxDHCycX4njhPoU4XlhRiOOF+xbieOEUIC/cD8gL9wfywkogL6wC8sJqIC+sAfLCWiAvrPMxL7zPbNsqIC9cgpPXwAuXouQJXng/Rl4jL3wAIc/BCx/UlpfICx/SlSfxwmVa8pJ54cMa8lS8cHnm8pS88JFM5aXghSsyk5eSFz6aiTyCFz7mXh7JCx93Ky8NL3xCyEPzwvuAvHAJkBcuBfLC+4G88AEgL3wQyAsfAvLCZUBe+DCQFy4H8sJHgLxwBZAXPgrkhY8BeeHjQF74BJAXBhxPHjg29g82WVaaHsdi6wcZ+tzKLG1soQ5FtBLKaC3wfLO0NUs7s7Q3SwezdDRLJ7MUmMVsWyBklnDgvwnG3Huw9gwCnc3SxSxdzdLNLN3N0sMsPc3Syyy9zdLHLH3N0s8s65mlv1nWN8sGZtnQLBuZZWOzDDDLJmbZ1CybmWWgWTY3yyCzbGGWwWbZMpD8rM1P7Jf1XH1Lv/t6f5w32fm5PAJrR2AdCCxEYBECKySwzgTWg8B6EdhAAtucwOIEVkRgWxHYNgQ2lMC2I7CRBDaawPYmsMkEtj+BVRHYgQR2EIEdQmDTCGwGgR1BYLMJ7DQCm0tg5xLYRQR2CYFdRmCXE9hVBHYNgS0msLsI7H4Ce5DAVhDYYwT2BIE9SWBPE9izBPY+ga0hsLUE9hmBfUNg3xHYDwT2I4H9RmB/EFjHVqmxTgRWSGBdCKwXgfUhsH4Eth6BbURgAwishMBKCWwogQ0jsNEENobAdiKwnQlsAoHtRmC1BFZHYIcQ2HQCO4LAjiKwYwjsWAI7icBmEdj5BHYBgV1GYFcQ2DUEtpDAriewGwjsVgK7ncCWEdjDBPYEga0ksGcJ7HkCe5HAXiKw1wnsTQL7ksC+IrAfCOwnAvuDwP4isH8I7F8Ca5OXGmtLYN0IrDuB9SOw/gQ2gMA2JbCBBLY5gcUILE5gIwhsewLbicB2IbDdCGwSge1BYHsSWAWBTSGwwwlsBoEdQ2DHEdgsAqsnsNkEdhqBnUVgcwlsPoEtILDrCexGArudwBYR2GICu4vAlhDY/QS2msCeIrAXCexlAnuTwN4msHcI7F0C+5DAPiawXwnsNwL7h8AaFu9SYG0JrD2BdSSwTgQWIbBCAtuAwDYksIEENojA4gRWRGAlBFZKYNsQ2FACG0dg4wlsDwLbi8CmENj+BFZFYNUEdiCBHURgJxLYSQQ2m8BOJ7C5BHYugZ1PYBcQ2CUEdhmB3UxgtxDYYgK7m8DuJ7AHCWwZgT1MYI8R2BME9iqBvUZg7xDYewT2MYGtJbDPCOxzAvuGwL4jsNZtUmNtCKwjgRUQWCGBdSGwbgTWncD6EFg/AhtMYFsSWAmBlRHYUAIbRmAjCGx7AhtDYDsR2GQC24fAqgishsAOIrBDCGw6gR1KYEcQ2FEEdiaBnUVg5xPYPAK7jMCuILD5BLaAwBYS2PUEdi+B3UdgywhsOYE9QWArCWw1gT1FYM8T2IsEtobAPiCwzwjsCwL7jsB+ILCfCOxnAvuDwP4isHB+aixCYN0IrAeB9SOw/gS2AYFtSGCbEthAAtuKwLYmsBEENpLAdiKwXQhsHIGNJ7BJBLYHgdUR2AEENp3ADiOwowjsGAI7jsCOJ7BZBFZPYBcT2CUENp/AriKw6wnsRgK7mcBuIbBFBLaYwFYQ2KMEtprAniawFwnsZQJ7lcBeI7C3CewdAvuKwL4msJ8I7BcC+4vA/iGwhsNpKbBWBNaWwNoTWG8C60NgGxDYRgQ2kMAGEdhgAtuSwIoIrITARhPYDgQ2jsAmENgeBLYXgU0msH0IbH8CqyKwGQQ2k8COI7ATCKyewGYT2OkEdgaBzSWwcwnsWgJbSGA3E9itBLaYwO4msHsJ7D4Ce5DAlhHYswT2HIG9SmCvE9g7BPYega0hsA8IbC2BfUZgvxHY7wRmH+BVYXkE1p7AOhJYAYEFCayQwLoQ2CYEtimBDSawGIGVEFgZgW1FYFsT2DACG0FguxHYRAKbTGAVBFZFYDUEVkdgBxDYIQQ2ncBOIrCTCex0AptDYOcS2PkENo/ALiSwywjsCgK7g8AWEdi9BLaEwJYR2HICW0FgjxLYSgJbTWBvEthbBLaGwD4ksM8I7AsC+4rAviawHwjsJwL7ncD+JLC/CewfAmvdPjWWT2BdCawbgfUlsPUIbGMC24TANiOwgQS2JYEZBDaSwEYR2M4ENpbAJhLY7gS2J4HtRWD7Eth+BHYogR1GYEcT2LEEdjKBnUJgpxLYbAI7k8DOJrArCWw+gV1HYDcQ2G0EdgeB3UlgiwnsPgJbSmBPE9gzBPYSgb1CYG8R2P8I7F0Ce4/APiKwTwjsZwL7hcD+JrB/qTmgQ2qsHYF1ILCOBBYmsCiBrU9gGxDYZgS2OYEZBDaEwIoJrITAtiawbQlsAoHtSmB7EtjeBLYfgVUSWDWB1RDYVAI7mMCOJ7ATCOxUAjuNwM4msHMI7DwCO5/ALiawSwnsJgK7mcDuJLC7CGwpgT1AYA8R2DICe5TAHiew1wnsDQJ7l8DeJ7BPCOxTAvucwL4gsG8J7HsCa9UxNZZHYB0IrBOBRQmsM4F1JbBuBNabwPoS2BYENpjAigmslMC2JbDtCGw4gY0gsB0IbEcCqyCwfQmsmsBqCexgAptGYIcS2GEEdiSBHU1gZxDYHAI7j8AuILBLCexyAruSwOYT2LUEdh2B3UNg9xLYQwT2MIE9TmBPEtgqAltNYM8R2AsE9iGBfURgnxPYlwT2PYH9SGA/E9gvBPYngf1NYMFOqbEQgXUlsO4E1pfA1iOw9QlsAwLbhMA2I7ByAtuKwIYT2PYEtiOB7UxgYwlsHIFNJLDdCexAAptKYIcS2OEEdjSBHUtgxxPYCQR2CoGdSmAXEthFBHYlgS0gsOsI7AYCu4nAbiawOwjsTgJ7hMBWENgqAnuKwF4gsJcI7BUCe5XA3iKw/xHYNwT2LYH9TGC/EtjfBPYvgbUqSI3lEVg7AutAYD0JrBeBrU9gGxLYZgS2OYFtQWCDCWwIgRUT2CgCG01gYwlsPIHtTmB7EtjeBDaZwPYjsEoCO4LAjiSw4wnsRAI7lcBOI7AzCGwOgZ1DYOcR2NUEdg2B3URgtxDYnQR2F4HdQ2D3EtgDBPYQgT1DYM8S2CsE9hqB/Y/A3iWw9wlsDYF9QmCfEtgfBPYngbUKpsZaE1gHAutEYEECCxFYZwLrSmAbE9gAAtuCwLYksGICKyWwcgLbisC2I7DhBLYrge1GYHsT2D4EVklg1QRWS2B1BHYwgU0jsFkEdgqBnUFgZxLYeQR2AYFdSGAXEdjlBHYlgd1GYLcT2D0Edh+BPURgDxPYIwS2gsCeJLBVBPYGgb1JYO8T2AcE9imBfU5gXxLYVwT2PYH9SGBtQ6mxdgQWJLAwgXUlsO4E1pPAehHYegS2PoEZBBYnsHIC25rAhhPY9gQ2isBGE9jOBDaWwPYlsCkEVktgBxDYNAI7lMAOJ7AZBHY0gR1LYHMJ7BwCu5DALiawKwlsAYFdTWDXENgNBHYTgS0lsPsJ7BECe5TAVhHYUwT2DIE9S2AvEdgrBPYRgX1MYF8S2NcE9iOB/UxgvxLYbwT2N4H9S2CF4dRYZwLrSWC9CWx9AtuQwDYmsAEEtjmBbUFg2xLYUAIbRWA7ENhYAhtPYLsS2G4EtieB7U1gUwnsIAI7nMBmEtixBHY8gZ1IYCcR2KkEdhqBXUZglxPY1QR2LYHdRGC3ENhtBHY7gd1FYPcQ2OME9gSBPUNgzxHYKwT2GoG9QWBvEti7BPY+gX1MYGsJ7DMC+5zAviGw7wjMvkxEhbUisPYE1pHAIgRWSGBdCKwrgfUisD4EtiWBxQishMDKCGwogQ0jsBEEtj2BjSGwnQhsMoHtQ2BVBFZDYAcR2CEENp3ADiWwIwjsKAI7ncDOILBzCex8AruEwC4jsCsI7EoCu4bAFhLYfQS2hMCWEdhyAnuCwFYS2GoCe4rAniewFwlsDYF9QGCfEdgXBPYdgf1AYD8R2M8E9geB/UVgBdHUWJDAuhBYNwLrQ2D9CKw/ga1PYAMIbFMC25rAtiGwEQQ2ksB2IrBdCGwcgY0nsEkEtgeB1RHYAQQ2ncAOI7CjCOwYAjuOwI4nsFkEVk9g8wjsQgK7gsDmE9hCAruewG4ksJsI7HYCW0RgjxLYYwS2msCeJrAXCexlAnuVwF4jsLcJ7B0C+4rAviawnwjsFwL7i8D+ITD7gkNlvkJgbQmsPYH1ILCeBNafwDYgsE0JbCCBDSKwLQgsTmBFBLYDgY0hsHEENoHA9iCwvQhsMoHtQ2D7E1gVgc0gsJkEdhyBnUBg9QQ2m8BOJ7AzCGwugZ1LYFcR2NUEdiOB3UxgiwhsMYHdTWD3ENj9BPYggT1HYM8T2KsE9jqBvUNg7xHYGgL7gMDWEthnBPYbgf1OYPYltyosj8DaE1hHAisgsCCBFRJYFwLbiMA2JrBBBDaYwIoIrITAygisnMCGEtgwAptIYJMIbDKBVRBYFYHVEFgdgR1AYIcQ2HQCO4nATiaw0wlsDoGdS2DnE9g8AruQwC4jsCsI7FYCu43A7iawewnsQQJbRmDLCewRAnuCwFYS2FsE9jaBrSGwDwnsMwL7gsC+IrCvCewHAvuJwNp0SY3lE1gBgYUIrAuBdSOwHgTWk8D6EVh/AosRmEFgZQS2FYENI7ARBDaSwEYR2E4EtguB7Udg+xNYHYEdSGDTCewwAptBYDMJ7BgCO47AziKwswlsHoFdRGBXENh8AruKwK4msOsJ7EYCW0JgSwlsOYGtILCVBLaawJ4msGcI7EUCe5nAPiGwtQT2FYF9Q2A/EdgvBPYbgf1OYP8QWKBraixCYFEC60FgvQisP4FtQGAbEdjGBDaQwAYR2DYEti2BjSSw0QS2C4GNI7AJBLYrge1BYHsR2MEEdgiBzSCwIwjsOAI7gcBOIrCTCWw2gZ1OYJcQ2KUEdhWBXUNgNxLYzQR2K4HdRmCLCexuAnuMwB4nsKcJ7FkCe5nAXiWw1wnsDQJ7h8DeI7DvCewHAvuNwP4gsEC31FgegbUhsHwC60hgBQTWh8D6EthGBDaAwAYR2GACixGYQWAlBFZGYGMIbEcCm0BguxHYXgQ2mcAqCGxfAqsisBoCO5rAjiGwkwhsFoGdTmBzCOwsAjubwM4nsHkEtpDAriOwWwnsdgK7m8DuJbAlBLaUwJYR2HICe57AXiCw1wnsTQJ7j8DWENiHBPYRgX1GYF8Q2N8E9g81P3RPjbUlsAICCxFYhMCiBNaNwHoQ2KYEthmBxQgsTmBlBLYVgW1DYNsS2AgCG0lgkwhsdwKrILApBFZDYHUEdiCBTSWw6QR2GIGdSmCzCewsAptLYPMI7CICu4TALiWw+QR2FYEtIrA7CWwJgd1PYMsJbAWBPUZgjxPYagJ7msBeIrBXCOw1gW17+cMjaq6beLITe4P4d28S2LsE9j6BrSWwz6g43+O/P5+56IWVN8+prHFiMQIbIbCuHw/vefjTN41yYvN7pP6+BQS2kMCuJ7DbCOwOAnuU6N+bBPYF0fd4z9TfN4TAyghsKwIbTmDbE9iePVP3bzqBzeqZuu+rie97isCeJ7AXCewNAnuLwL4m+temV2qsW6/UfZ/SK/X37UdgNQRWR2DTCOxQAjuV6N8VBHY70fefiO/7mcD+ILC/CKx179RYPoH17J26fzECG9E7dd/PIr7vbAI7n8DmEdjlBHYlgd1J9G8lgb1J9L1/n9Tftz6BDSCwTQlsSwIzCGxUn9T9qyCw6X1S930J8X1LCWwZgS0nsCcJbBWB/Y/o3w8E1qZvIGXfd+mb+vvGEthuBDaJwPYhsH0J7PC+qfs3h8CuIPr+IfF9HxHYZwT2BYF9T2A/Eli7fqn714/AYv1S9/2Yfqm/71gCO4nAZhHYGQR2JoEtIPp3L4GtJPoeWi/194UJrAuBdSOwvgS2HoENWS91/3YisIr1Uvf9euL7biCwWwnsdgK7h8DuI7CniP6tIbAfiL5v1T/1921NYMMIbASB7UhgOxPYfv1T9+8oApsjMLnv4nqxwEbiT3GdTCBP/NnKLK2tfor/j+k99tVcDXLR8stiRaUdAokPuP0N14e1YtaPLZNBvn3Nc2DkrHXy5b5YT1D8fyuHLu1/Y9mMeH1Rw98jjn9jPaMcsltJ2GjF93L22bSJYlt+Gwb55hPvrGh/G0ffrGf7WYHGJ8PvNeSKTkL/Yjpr+H65Ha2kNrUOpB7zgKKulUJOnvTZVim+39nv1oHkMUjVNpUeA4o6Vdtap2lbG0XbZLl5RD9SfY+zTbZ+goFkXbeSMFXbrXG17abNrER8mKiPaTylZbFYo16E/PxAsh04vz9f+vyG4v87Otrv1MWwDNtZV1pp1A2prKssrqypKaquLJTkBxz6tPS0gfh7bt4inyHM80qcOcYq5y1VnKDmLdkfrceeq9LNac55y5bNyQVMmyhhHjOjcyD1XODFvNVnneiEMcwPpJ5z8qXPii2PQFuzdEkhry0hLxhIbUvWv+vl0IcsQ0MnSTpStaOVoh3ZPm+sL/6/ueeNAgFk+bxR7dW8kc8jv8iW35ZHvnLecPbF/t5M5w3Zb61ntIQ5OecOArPin/jpWsPfuzraYT1jZq1ro5xD7ejA8iRsJwfWWsJ2dmDO/IRrfE37LGMe36LOgdRj6sUc9rekR6c/ZvhdSY/dLztm5geS5wrn91r/30n6bBvFZ23bEleuJMTAjoQs+/M/ij8tfdtzeWvpMzK/cOZ5nRz19udTyeiUQkZQqk/3PUHF9wSJ72ml0EEbRftsGbYdhBzfM0z8GdN7Gjl2GC/byJf6GRN/WmO7iaOfVokodOHUYYEDd35+kEPmQPH3oELvYcfnBhOfCxGfU9mv9bk48bkOis+1lvrgjMeynTntwf58KhkFKWREHfWtm/A9UcX3RInvkX3eOYYRhVzZ50eKPy0dbR1I1EmhQmZUoZN86fPDHDKHir8HFe132sUI4nMh4nOqmGN9bjTxuQ6Kz6XqU0dFe2U/2Nkhb0eiHx0dnxtLfK6T4nM21llqQ4GiX/nSZz93yJsgyesm/RuZ1zo/2136rDwPBBwyxFGrhM90I2TZn3/f0dbdxd/tONlL+r5h4v9jLp8y6f/tNvd2tEkVB3tJbbY/P8XR5r3F34OKPneQsO4E1sOBtZKwng4sz/HdJwXWPc72yuufTp+yY0wfxb+T41RvR70z1w8oZMhyekuf7Zvi+61HXpuV1xVSrSdb/2+vnecp2hRK095+jv/vJX22F/Fv5b70Vfw7WZeqfx9Q1OUHUo9PvvTZQ8SfFo9tLYzG9p3+jn+P4+vxxnWO9QPJj41t4Phu2ZY3dGDyGs5GDqy3hG3swJy6kR/VXkj/wDo9yXma83NyP5xjuYGEOcd8Qwlz2tVGEraeA9tYwpyxQ14vcsaOvhLmjB39JMwZO+zvVsUOeyzyFG2RY0dvxb+T7T1VLAgoZMhyUvlea4U8OXbIcUc1B8lYnqJNcuzoLrXXKVfeT8sj/q3cl+6KfyfrMlUf5Lp8om350mfnij+dsUPVpp4p2pSXok1N6VcrRdvaKP5dUGq7/fkrxZ+WHc9zfN45hqnmdFlX9ucvdci8WPxdtf/n5LCXE58LEZ9r5ficcz5fQHyug+JzKl07Y0GqPDvdeMk5eatA8nioxkvOOezP3+5o+3WOz6car6iirfJ43eyQeaP4e1DRfud43Up8LkR8zjmuQcfnFhGf66D4nPxdKg4u5xz2Z+9xyLuL6Ecrx+fuIz6Xp/icjck6Dyr6JceT1xzy7pfkyWtbvRT9bS39v/PfUbbsXEsJKGTIcoIp2tZaIU+eW8LSv+1GyOmWoj3OfnRQyFLJz1d8XrYT+7OPiz+tuN62Ver2O/vnjBuqvsl9aC31NZzi36U6E0KNmWoOk7+vWxNl2W2X57CA4v9bEX1pnaJvqn6q/n1AUZcfUNuGE7M/+6L40xrTDmJMVXOEbdtUPLKxkAOTz4w5468zfr4dSP3dvYjv7kZ8dw/iu3sS3+1cB2klYZ0dmJxjdHFgIQnr6sCiju/+mPjuMPHdHYjv7kB8dwfiu53rUwUS5lzz6ixhzrXBLhLm3Gvt6vjub4jv7kB8dwfiu1sR351HfLdzf6ijhDn3pjpJWDsHFpGw9g6s0PHdvxHf3YH47g7Ed3cgvrsD8d3OuNlOwpwxqL2EOX0zX8Kcvmm3PxvOHuQJAc199gD9/SVFJUZZWWVZdUl1XXlRdZXX319UXFlaXVlqGOVFRm2RUez199eWxoqrhpitiBvVZeW1Q9J9v52fZffZj+IsPzNoDPHLmcHW0ufkf+P8zCjHZ0Y5PuOUPdrxmdEpPrOD4zM7pPjMGMdnxqT4zI6Oz+yY4jM7OT6zU4rP7Oz4zM4pPrOL4zO7pPjMWMdnxqb4zDjHZ8al+Mx4x2fGp/jMBMdnJqT4zK6Oz+ya4jO7OT6zW4rPTHR8ZmKKz0xyfGZSis/s7vjM7ik+s4fjM3tIn5HnZ+sZKT7DfB6V+XcURlx1lsruJ+85NGNIK+n7AoHEWBGQvr9jgDM2xoxW0vfZ7ZH1I5//srlOKwXWZlZyPxrX5ByYPb4WJ9zc8TmVbdmfK3H8vUz8XXVmFj3/cdm79XRWtN/5XdbTblag8WlcZ3DU2Xq19dze+XkJ6+DA2sxK/J6O4v/ttQJZlt2OfOnzxeL/G/Nwx7+x/31E8f1tpe9PaLeiTtZLB8XnOyg+7zy748whOM/snWe3J5Dsw60CKPsZYqjiJU5+SbUqJuLkl8ZVZzeB+qm05bfj0U+5Lb89j36q5DOfYPk1tvyOPPppPJvbiUV+vNE+C3j003h2PMijnyL5LCdYfpV8nhPsX43jG+FpfyMfjPLIb5zfC3nspzH/7MzT/lpbfhcW+fG4vPZrf4f12N8t74NgvtuobSpftr+/o9RWLr7cTWqPrB95Pb+7oq0RBSbPIdQeuPN7VLK6AGWFgLLaAWV1BsoKAmUhdd/Wp+0qBMoqAMrKB8ryq61GgbKQNtHJp+1qA5QVAcryq00g/bEjUJZf42proKwwUJadM6rWIKxnmPgzpvnYbW2jaGueoq3251XrjioeVeD47GEzpk4/IiA98oGZVtLfbbwwRQP6Sv++dQq5snzn/xemwfsqZGXDhvZF4v+be0P7MdHoLN9QLfZqQ5VpA8Vg/rG+ckPV2ZdG+5Q+J/8b6/HDRhaTnkrkAzbOfjP/IL60lfR9zvFwYvb3dwxw2uS6xLyt1B5ZP3mSftrztCemWrRFyrf721HRX6c9t5f6W8DTniL5gJ39Hc7vDvJ8d3FTbdH+/o5SW7lsMagYG6d+qE3VjhLWZlZyP1Sbqvb4WuO+u6N/TszZHtXBwEgg2VbsdjP7TRGz3xhu/SYs/t+5ECAnNB1d6tX579t5o9diZr3Gc/Go8cnFIweW5fGonNlvhrTQeFTJrNeiXDxqfHLxyIFleTyqZfabYr/GI9XBQPllrM41LftgrNXO/QPr/l4l/s58aLA4d2hw3edTHRrcT/y/nw8N7iX+7tWhwWWONU6njdtjneH3SU9JnPlQXxnzob4i3kN9pTHeQ33rDh3xHOorKeE91Fc0hPdQ37qXUvMc6isxeA/1lRbzHupbd6iM51DfukNlPIf64nHeQ33FdcyH+mp4D/UVG7yH+oob41tXHvspUx0MBLa/8VBrdx75jfNLDx79NB5a7skjv0b1ckKg/Mb405tF/rpD13142t8ovy+P/Eb77Mdjn43jux6P/itVL+gDym/kP+uzyB/SaJ8b8LS/cV1wQx77aZy/NmKRX9RoPxvztL+R/wxgkb/uRx+b8IxvIz/ZlMc+G/1rMx79N9rnQB79VNlrLvYPN+3vsB77uwc56mFrH0Z5k9cz7e/vKLUV2h7HeuYgqT2yfpzrmRa2haKtEQUmj+EWiu/ZQvE9KlkRoKy+QFmbAWWFgbL6AGUhdb+pT9sVAsrqDZS1CVBWECirF1AWUl9Imxjg03Yh40QBUFZPoKyNgbJaQvzqBJTl1zkNaas9gLI2AsoKAmUh+4iM0Uj76giUhdQX0laR3AQpqztQFpLnIHXv11iInB+RuQIyFm4IlIXsI1L3yJjTErhvB6AspG/71SaQdo+cO/zKybv5VBZSX8g8LRej/3/4EDLe59Z93cnKrfs2X7uQuQIyh/FrPrQBUFZL4KvIuQM5pyFjTnugLOQ6U1egLL/GwvWBsvzqQ0ibQMavdkBZLWG/I8cLmy9G53ihO1m58wDuZOXOAzRfu3LnAXLxS5aVOw/gThYyT8vtizafTeT2RZuvj35dc+/i0z4ifTt3Dqb5ZOX23Ztv7sjtuzefTeT23d3J6g+UhbR7pD8i9wKQ6/fINYXcHn7z9TG3Vvv/I94j25Xbw3cnawOgrJbAfXN7+M0317aEPfy2QFm5PXx3snJ7+O5k5Xhh88XoHC90Jyu3h+9OVm4Pv/naldvDz8UvWVZnoCxknEDaF9Lu/fob9fWAsvy6v53bA2s++8rtgf3/mDtawh5Yvk/blds7ab74lcuRc3NaS5zTkONYCJTVz6eykH30q76Q85BfOUAboCxkzPHrWcUcz3EnK8dzmk/3ub0Ad7JyewH/P2Jhbi/AnazcXoA7Wbm9gOaLObm9gFyMlmXl1k2az75yewHNJyu3F+BOVi5HdicrlyPn5rSWOKfl9gJyfeTsY26/o/n8ETmnRYGykDzar+tMyN93+PV3YLm9pubrY45HN5/uczy6+WJOjke7k+V3jmnffew8m2E9w8SfMc3Hbmu+oq15irban2+r+LzqbuICh+zDZkydfkRAepxfbAt3/t3G20qfa52iQRe1SvxcmxTfY/8pd8z5tJH+v630//K/sf9fboP1WC9+tANQm1mBhH4ME/Uxjae07L/BtJ7Ws9b1uXUg+WnjwJ2ff1R82PnSMvvPNhrtrCutNOqGVNZVFlfW1BRVVxZK8q0nT6En+0/nj81R+jIfw5bfhUd+rF0g+enq+HsXqZ9OhxsGaoMtz7aD/EDykydh9mfbS+1rhW+fEZCe1orvsh97s7WLo65rirY6bRg4pnFbfice+Uqb6ej4eycJs8eujeLftUrx/3nSn9RnWxFygwrMlmmPlbO9dj/sZNnWpXPDAalLW35bHvmN8aMdj/whKltw1sn+Ks9FzjbJMRXc1spWiva1lr5TbqPzMyr7zZP+v41U37oJn1XZr41FFO2T/10HRVuddbZtqXxBHhc7RuWnkNXOgTs/3076LNcYdla0yW77/wGqtpZQbRAdAA==","debug_symbols":"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xABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQATwzwxABPDPDEAE8M8MQAT0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE9M8MQET0zwxARPTPDEBE8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxJIr4uSOOPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAJPLPDEAk8s8MQCTyzwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQGT2zwxAZPbPDEBk9s8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEAU8c8MQBTxzwxAFPHPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAVPXPDEBU9c8MQFT1zwxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3jiAU884IkHPPGAJx7wxAOeeMATD3ji+bknXn+J/Oi5QtP/Wi5vb4m3t+TbWv6+rv788PL44ePTwx/Xjlvx2+dPXx+fP/9Yfv3ry2vl48vj09Pj7++/vDx/evjt28vD+6fnT7faL+9uj+8HrXh3F/XrNXz/79b15RG3rct/WxV3l9rrF38/aV267i49t0zcMre5M+4qboFb/v66us+9BfI1sHV36jVwqu9O31/nuc70Dw==","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"60":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n","path":"std/uint128.nr"},"62":{"source":"use aggregation_prover::aggregate::aggregate;\nuse training_prover::train::MultiClassTrainedModel;\n\npub fn main(submitted_models: [MultiClassTrainedModel<4, 3>; 3]) {\n    let aggregated_model = aggregate(submitted_models);\n    println(\"aggregated model: \");\n    println((aggregated_model))\n}\n","path":"/Users/yurikonishijima/Development/vfl-demo/server/src/main.nr"},"63":{"source":"use noir_fixed_point::quantized::Quantized as QuantizedWithDiv; // this has division function\nuse noir_mpc_ml::quantized::Quantized;\nuse noir_mpc_ml::utils::{assert_bitsize, scale_down};\nuse training_prover::train::MultiClassTrainedModel;\nuse training_prover::train::TrainedModelPerClass;\n\n// New struct definition using QuantizedWithDiv, which has division implementation\n// We switch form the original Quantized struct to this struct becuase we need to do division at the end for weighted average calculation\npub struct FinalTrainedModelPerClass<let M: u32> {\n    pub weights: [QuantizedWithDiv; M],\n    pub bias: QuantizedWithDiv,\n}\n\n// multiclass model\npub struct FinalMultiClassTrainedModel<let M: u32, let C: u32> {\n    pub models: [FinalTrainedModelPerClass<M>; C],\n    pub n_samples: Field,\n}\n\npub fn castToQuantizedWithDiv(q: Quantized) -> QuantizedWithDiv {\n    QuantizedWithDiv { x: q.x }\n}\n\npub fn aggregate<let M: u32, let C: u32, let L: u32>(\n    submitted_models: [MultiClassTrainedModel<M, C>; L],\n) -> FinalMultiClassTrainedModel<M, C> {\n    // Initialize temporary empty model to accumulate weighted sums for weights and bias\n    // We use original Quantized struct\n    let mut temp_aggregated_model: MultiClassTrainedModel<M, C> = MultiClassTrainedModel {\n        models: [\n            TrainedModelPerClass { weights: [Quantized::zero(); M], bias: Quantized::zero() }; C\n        ],\n        n_samples: Field::from(0),\n    };\n\n    // Loop over each model submitted by clients, stored in `submitted_models`\n    for client_idx in 0..L {\n        // println(\"client_idx\");\n        // println(client_idx);\n        let model = submitted_models[client_idx];\n        let unscaled_n_samples = Quantized::new(model.n_samples);\n\n        // n_samples is 20 = 5 bits at max for this demo\n        // println(\"unscaled n_samples\");\n        // println(unscaled_n_samples);\n\n        assert_bitsize::<5>(unscaled_n_samples);\n        temp_aggregated_model.n_samples += unscaled_n_samples.x;\n\n        // println(\"total number of samples summed up so far\");\n        // println(temp_aggregated_model.n_samples);\n\n        // For each class in this model\n        for class_idx in 0..C {\n            let current = model.models[class_idx];\n\n            // println(\"class_idx\");\n            // println(class_idx);\n            // println(current);\n\n            // Weighted sum for each weight\n            for weight_idx in 0..M {\n                // println(\"weight\");\n                // println(current.weights[weight_idx]);\n                // since n_samples is already constrained to be <= 5 bits,\n                // weights can be 125 - 5 = 120 bits at maximum\n                let unscaled_weight = Quantized { x: scale_down(current.weights[weight_idx].x) };\n                // println(\"unscaled_weight\");\n                // println(unscaled_weight);\n                assert_bitsize::<120>(unscaled_weight);\n\n                let scaled_down_weighted_sum_for_weights = unscaled_weight * unscaled_n_samples;\n\n                // println(\n                //     \"scaled down weighted sum for weights = unscaled weight * unscaled n_sampled / 2^16\",\n                // );\n                // println(scaled_down_weighted_sum_for_weights);\n\n                // NOTE: multiplication between `Quantized` outputs a result devided by 2^16 because it's intended to be\n                // performed on fixed point numbers. However, since we are passing unscaled values here (in order to pass max-bitsize assertion for safe multiplication), we have to rescale the result by 2^16.\n                // the other operand `weights` must be 125 - 16 = 109 bits at maximum\n                assert_bitsize::<109>(scaled_down_weighted_sum_for_weights);\n                let weighted_sum = scaled_down_weighted_sum_for_weights * Quantized::new(65535);\n\n                // max input bit size for safe addition: 125 bits\n                assert_bitsize::<125>(weighted_sum);\n                temp_aggregated_model.models[class_idx].weights[weight_idx] += weighted_sum;\n            }\n\n            let unscaled_bias = Quantized { x: scale_down(current.bias.x) };\n\n            // since n_samples is already constrained to be <= 5 bits,\n            // bias can be 125 - 5 = 120 bits at maximum for safe multiplication\n            assert_bitsize::<120>(unscaled_bias);\n            let scaled_down_weighted_sum_for_bias = unscaled_bias * unscaled_n_samples;\n\n            // NOTE: multiplication between `Quantized` outputs a result devided by 2^16 because it's intended to be\n            // performed on fixed point numbers. However, since we are passing unscaled values here (in order to pass max-bitsize assertion for safe multiplication), we have to rescale the result by 2^16.\n            // the other operand `weights` must be 125 - 16 = 109 bits at maximum\n            assert_bitsize::<109>(scaled_down_weighted_sum_for_bias);\n            let weighted_sum_for_bias = scaled_down_weighted_sum_for_bias * Quantized::new(65535);\n\n            // max input bit size for safe addition: 125 bits\n            assert_bitsize::<125>(weighted_sum_for_bias);\n            temp_aggregated_model.models[class_idx].bias += weighted_sum_for_bias;\n        }\n    }\n\n    // println(\"temp aggeregated model: \");\n    // println(temp_aggregated_model);\n\n    // Initialize empty model to be returned as a final aggregated model\n    // We need to do division so we'll use QuantizedWithDiv Struct here\n    let mut aggregated_model: FinalMultiClassTrainedModel<M, C> = FinalMultiClassTrainedModel {\n        models: [\n            FinalTrainedModelPerClass {\n                weights: [QuantizedWithDiv::zero(); M],\n                bias: QuantizedWithDiv::zero(),\n            }; C\n        ],\n        n_samples: temp_aggregated_model.n_samples,\n    };\n\n    // Divide all sums by total_samples to get weighted average\n    // Since original noir_mpc_ml::quantized::Quantized does not implement division,\n    // let's it to noir_fixed_point::quantized::Quantized first which has division function implemented.\n    for class_idx in 0..C {\n        for weight_idx in 0..M {\n            // println(\"weight_idx\");\n            // println(weight_idx);\n            aggregated_model.models[class_idx].weights[weight_idx] = castToQuantizedWithDiv(\n                temp_aggregated_model.models[class_idx].weights[weight_idx],\n            )\n                / QuantizedWithDiv::new(temp_aggregated_model.n_samples);\n        }\n        aggregated_model.models[class_idx].bias = castToQuantizedWithDiv(\n            temp_aggregated_model.models[class_idx].bias,\n        )\n            / QuantizedWithDiv::new(temp_aggregated_model.n_samples);\n    }\n\n    aggregated_model\n}\n\n","path":"/Users/yurikonishijima/Development/vfl-demo/aggregation_prover/src/aggregate.nr"},"66":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a fixed scale factor of 2^16\n// See further explanation in the `Quantized` struct comments below.\nglobal scale: Field = 65536; // 2^16\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A Field element is a type with 254 bits.\n// We only use the first 126 or the last 126 bits.\n// A positive number is within the first 126 bits.\n// A negative numbers is within the last 126 bits.\n// The \"middle\" 2 bits that are left over, should not be used.\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\n// So following above visual, x_126 and x_127 MUST be 0\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses a scale of 2^-16. This means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Overflow and overflow prevention:\n// To make sure the arithmetic performed on a value will not overflow, the library contains\n// bitsize checks that prevent numbers from growing larger than 126 bits. More concretely:\n// - multiplication: inputs must have bitsize <= 63\n// - addition: inputs must have bitsize <=125\n// - subtraction: inputs must have bitsize <=125\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\n// returns 1 for a negative element, 0 for a positive element\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// NOTE: this asserts the field contains has maximum 126 bits. If the element contains more than\n// 126 bits either way, this function cannot correctly indicate whether it's negative or not.\nfn is_negative(x: Field) -> Field {\n    let (lower_bytes, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        // Make sure the number is not overflowing the 126 bits\n        x.assert_max_bit_size::<126>();\n        0\n    } else {\n        1\n    }\n}\n\nimpl Quantized {\n    // Assert that number of bits <= bitsize\n    // if quantized is negative, it counts the bits backwards\n    // NOTE: this works only for bitsize <= 126, because decompose gives us\n    // 128 and 126 bits\n    pub fn assert_bitsize<let bitsize: u32>(self: Self) {\n        // Decomposes into two 128 bits chunks\n        let (lower_bytes, higher_bytes) = decompose(self.x);\n        if higher_bytes == 0 {\n            // positive number\n            self.x.assert_max_bit_size::<bitsize>();\n        } else {\n            // negative number\n            (-self.x).assert_max_bit_size::<bitsize>();\n        }\n    }\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        let res = Self { x: x };\n        res.assert_bitsize::<126>();\n        res\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 63 bits for both inputs\n        // Perform multiplication of the underlying field elements\n        // This doubles the scale.\n        self.assert_bitsize::<63>();\n        other.assert_bitsize::<63>();\n        let mut temp: Field = self.x * other.x;\n\n        // Scale down by dividing by 2^16\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the division doesn't work\n\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\n        // Cast x to a u16 to preserve only the lowest 16 bits.\n        let lowest_16_bits = temp as u16;\n\n        // Subtract off the lowest 16 bits so they are cleared.\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\n\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n        // therefore field division is equivalent to integer division.\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\n\n        // If the result was originally negative, flip the sign back\n        final_res = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - final_res\n                    + 1\n                    - final_res\n            )\n            + final_res;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: final_res }\n    }\n\n    fn div(self: Self, other: Self) -> Self {\n        // Ensure `other` is not zero\n        assert(other.x != 0, \"Division by zero is not allowed.\");\n        self.assert_bitsize::<109>(); // will be multiplied by scale later, so we allow 126-17 bits\n        other.assert_bitsize::<126>(); // standard bitsize check\n        // Flip signs of numerator and denominator if negative, work with their absolute values\n        let mut numerator = self.x;\n        let mut denominator = other.x;\n\n        let mut numerator_is_negative = is_negative(numerator);\n        let mut denominator_is_negative = is_negative(denominator);\n\n        numerator = numerator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - numerator\n                    + 1\n                    - numerator\n            )\n            + numerator;\n\n        denominator = denominator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - denominator\n                    + 1\n                    - denominator\n            )\n            + denominator;\n\n        // Scale numerator before division\n        let scaled_numerator = numerator * scale;\n\n        // Cast to U128 for division\n        let scaled_numerator_u128 = U128::from_le_bytes(scaled_numerator.to_le_bytes());\n        let denominator_u128 = U128::from_le_bytes(denominator.to_le_bytes());\n\n        // Perform the division in U128\n        let result_u128 = scaled_numerator_u128 / denominator_u128;\n\n        // Cast back to Field\n        let mut result = Field::from_le_bytes(result_u128.to_le_bytes());\n\n        // Determine the sign of the result\n        let result_is_negative = numerator_is_negative + denominator_is_negative == 1;\n\n        // If result is negative, flip sign back\n        if result_is_negative {\n            result = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - result\n                + 1;\n        }\n\n        Quantized { x: result }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Div for Quantized {\n    fn div(self, other: Self) -> Self {\n        self.div(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        } else {\n            let (_, sub_hi) = decompose(self.x - other.x);\n            if sub_hi == 0 {\n                Ordering::greater()\n            } else {\n                Ordering::less()\n            }\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n\n#[test]\nfn test_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Division with small positive values\n    let a1 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b1 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result1 = a1 / b1; // 1.5 / 1.0 = 1.5\n    assert(result1.x == 98304); // Scaled result for 1.5\n\n    // Test case 2: Division resulting in a smaller value\n    let a2 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let b2 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let result2 = a2 / b2; // 1.0 / 1.5 = 0.666...\n    assert(result2.x == 43690); // Scaled result for ~0.6667\n\n    // Test case 3: Negative divided by positive\n    let a3 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b3 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result3 = a3 / b3; // -1.5 / 1.0 = -1.5\n    assert(result3.x == p - 98304); // Correctly negative\n\n    // Test case 4: Positive divided by negative\n    let a4 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b4 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result4 = a4 / b4; // 1.5 / -1.0 = -1.5\n    assert(result4.x == p - 98304); // Correctly negative\n\n    // Test case 5: Both negative values\n    let a5 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b5 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result5 = a5 / b5; // -1.5 / -1.0 = 1.5\n    assert(result5.x == 98304); // Scaled result for 1.5\n}\n\n#[test]\nfn test_large_values_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Large positive values\n    let a1 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b1 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result1 = a1 / b1; // 17592186044416.0 / 8796093022208.0 = 2.0\n    assert(result1.x == 131072); // Scaled result for 2.0\n\n    // Test case 2: Large positive divided by a larger positive\n    let a2 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let b2 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let result2 = a2 / b2; // 8796093022208.0 / 17592186044416.0 = 0.5\n    assert(result2.x == 32768); // Scaled result for 0.5\n\n    // Test case 3: Large negative divided by large positive\n    let a3 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b3 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result3 = a3 / b3; // -17592186044416.0 / 8796093022208.0 = -2.0\n    assert(result3.x == p - 131072); // Correctly negative\n\n    // Test case 4: Large positive divided by large negative\n    let a4 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b4 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result4 = a4 / b4; // 17592186044416.0 / -8796093022208.0 = -2.0\n    assert(result4.x == p - 131072); // Correctly negative\n\n    // Test case 5: Both large negative values\n    let a5 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b5 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result5 = a5 / b5; // -17592186044416.0 / -8796093022208.0 = 2.0\n    assert(result5.x == 131072); // Scaled result for 2.0\n}\n\n#[test(should_fail)]\nfn test_division_by_zero() -> Quantized {\n    Quantized { x: 65536 } / Quantized { x: 0 }\n}\n","path":"/Users/yurikonishijima/Development/noir-fixed-point/src/quantized.nr"},"69":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a scale factor of 2^(8*factor).\nglobal scale: Field = 65536; // 2^(8*2) = 2^16\n\n// NOTE: this is a version of the noir-fixed-point library without overflow checks\n// Ref: https://github.com/hashcloak/noir-fixed-point/\n// The ML functionality of this larger library take care of the necessary overflow checks\n// which makes the whole more performant.\n// This version also doesn't contain the `div` function, since it's not needed.\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A Field element is a type with 254 bits.\n// We only use the first 126 or the last 126 bits.\n// A positive number is within the first 126 bits.\n// A negative numbers is within the last 126 bits.\n// The \"middle\" 2 bits that are left over, should not be used.\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\n// So following above visual, x_126 and x_127 MUST be 0\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses a scale of 2^-16. This means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\n// returns 1 for a negative element, 0 for a positive element\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// NOTE: Make sure that the value that the field contains has maximum 126 bits.\n// If the element contains more than 126 bits either way, this function cannot correctly indicate\n// whether it's negative or not.\npub fn is_negative(x: Field) -> Field {\n    let (_, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        0\n    } else {\n        1\n    }\n}\n\nimpl Quantized {\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        Self { x: x }\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        let mut temp: Field = self.x * other.x;\n\n        // Scale down by dividing by 2^16\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the division doesn't work\n\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\n        // Cast x to a u16 to preserve only the lowest 16 bits.\n        let lowest_16_bits = temp as u16;\n\n        // Subtract off the lowest 16 bits so they are cleared.\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\n\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n        // therefore field division is equivalent to integer division.\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\n\n        // If the result was originally negative, flip the sign back\n        final_res = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - final_res\n                    + 1\n                    - final_res\n            )\n            + final_res;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: final_res }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        } else {\n            let (_, sub_hi) = decompose(self.x - other.x);\n            if (sub_hi == 0) {\n                Ordering::greater()\n            } else {\n                Ordering::less()\n            }\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-mpc-ml/v0.1.2/src/quantized.nr"},"70":{"source":"use super::quantized::{is_negative, Quantized};\nuse std::field::bn254::decompose;\n\n// returns x * 2^-16, interpreted as an integer\n// Scaling down is needed for example after multiplying 2 Quantized values\npub fn scale_down(x: Field) -> Field {\n    let mut z = x;\n\n    let negative = is_negative(z);\n\n    z = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - z + 1\n                - z\n        )\n        + z;\n\n    // Division by 2^16, code as suggested by Tom French @TomAFrench\n    // Cast x to a u16 to preserve only the lowest 16 bits.\n    let lowest_16_bits = z as u16;\n\n    // Subtract off the lowest 16 bits so they are cleared.\n    let x_with_cleared_lower_bits = z - lowest_16_bits as Field;\n\n    // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n    // therefore field division is equivalent to integer division.\n    let mut new_x: Field = x_with_cleared_lower_bits / 65536;\n\n    // Flip back sign if the output is negative\n    new_x = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - new_x\n                + 1\n                - new_x\n        )\n        + new_x;\n\n    new_x\n}\n\n// Assert that number of bits <= bitsize\n// if quantized is negative, it count the bits backwards\npub fn assert_bitsize<let bitsize: u32>(q: Quantized) {\n    // Decomposes into two 128 bits chunks\n    let (_, higher_bytes) = decompose(q.x);\n    if higher_bytes == 0 {\n        // positive number\n        q.x.assert_max_bit_size::<bitsize>();\n    } else {\n        // negative number\n        (-q.x).assert_max_bit_size::<bitsize>();\n    }\n}\n\n#[test]\nfn test_assert_bitsize() {\n    // 4 bits\n    assert_bitsize::<4>(Quantized { x: 10 });\n    assert_bitsize::<4>(Quantized { x: -10 });\n\n    // 100 bits\n    assert_bitsize::<100>(Quantized { x: 1267650600228229401496703205375 });\n    assert_bitsize::<100>(Quantized { x: -1267650600228229401496703205375 });\n\n    // 127 bits\n    assert_bitsize::<127>(Quantized { x: 170141183460469231731687303715884105727 });\n    assert_bitsize::<127>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: 1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127_neg() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: -1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize1() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: 10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize2() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: -10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize3() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: 1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize4() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: -1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize5() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: 170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize6() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-mpc-ml/v0.1.2/src/utils.nr"}},"names":["main"],"brillig_names":["decompose_hint","lte_hint","unconstrained_div","print_unconstrained","print_unconstrained","directive_invert","directive_integer_quotient","directive_to_radix"]}