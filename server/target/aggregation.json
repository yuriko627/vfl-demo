{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":3672452839326788705,"abi":{"parameters":[{"name":"submitted_models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::MultiClassTrainedModel","fields":[{"name":"models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::TrainedModelPerClass","fields":[{"name":"weights","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}},{"name":"bias","type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}]}}},{"name":"n_samples","type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9174856516895611197":{"error_kind":"string","string":"Division by zero is not allowed."},"16646908709298801123":{"error_kind":"string","string":"attempt to subtract with underflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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wj+BvPAvIC/8G8gL/wHyQkuQONg2tscqxipT40ymI0ZQZweTfefVBRUaIsYbI8HznX17i88f1kDnGuRcdc412LmGONdQ5xrmXMMtd4IZ6VyjnGu0c41xrhmca0bnGutcMznXzM41zrnGO9cszjXBuWZ1rtmca3bnmsO55nSuic41l3PN7VzzONe8zjWfc83vXAs414LOtZBzLexcizjXolaxbBDr/T3Bf1549ay3jf84vpl4X9Inb5BP3mCfvBE+eaN88tb2yVvHJ29Dn7yNffK28MnbyidvW5+87XzyJvvk7eyTt4dP3l4+eQf45B3ok3eoT97hPnnH+OQd55N3ik/eqT55Z/rkne2Td4FP3kU+eVf45F3pk3etT971Pnm3+OTd5pN3h0/enT559/rk3e+T94hP3mM+ec/75L3gk/eqT97rPnnv+OS955P3sU/eJz55X/rkfe2T94NP3k8+eX/45P3pk/efT14sVjov7ZM30CdvmE/ecJ+8MT55M/rkjffJm+CTN5tP3uw+eXP75M3rk7eQT94iPnk5n7xmn7wlffKW9slbwSdvJZ+8NXzy1vTJW88nbwOfvE198jb3yWv1yWvzydvWJ2+ST95OPnm7+OTt5ZO3t0/eAT55B/nkHeaTd4RP3lE+eUf75J3gk3eST97pPnln+OSd45N3rk/eRT55l/jkXemTd7VP3s0+ebf45N3pk3e3T96DPnkP++Q96ZP3lE/e8z55L/rkveGT95ZP3gc+eR/65H3qk/e5T953Pnk/+OT95pP3u0/ePz55//nN7/HSeQN98up88gb75I3wyRvlkzezT954n7y5fPLm9slbwCdvIZ+8ep+8Rp+8xX3ylvDJW9Ynb3mfvNV88tbwyVvPJ299n7xNfPI288lr9clr98mb5JO3vU/ezj55u/rk7eOTt59P3gE+eQf65B3qk3e4T95xPnkn+OSd4ZN3pk/eeT55F/jkXe6Td6VP3nU+edf75N3ik3ebT949Pnn3+eQ94pP3qE/eUz55z/jkveyT96pP3ts+ee/45H3ok/eRT96XPnlf++R965P3nU/ezz55v/rk/eOT959PXowv1C559r3LdVy6/sFiXiJR+v8lffIG+eQN9skb5ZM3xidvRp+8sT55s/jkzeqTN7dP3rw+eWvyvKdPf/6xq45u7RDzdvbJO4TnzfDxsjPv+tSV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","debug_symbols":"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JMAnEuATCfCJBPhEAnwiAT6RAJ9IgE8kwCcS4BMJ8IkE+EQCfCIBPpEAn0iATyTAJxLgEwnwiQT4RAJ8IgE+kQCfSIBPJMAnEuATCfCJBPhEAnwiAT6RAJ9IgE8kwCcS4BMJ8IkE+EQCfCIBPpEAn0iATyTAJxLgEwnwiQT4RAJ8IgE+kQCfSIBPJMAnEuATCfCJBPhEAnwiAT6RAJ9IgE8kwCcS4BMJ8IkE+EQCfCIBPpEAn0iATyTAJxLgEwnwiQT4RAJ8IgE+kQCfSIBPJMAnEuATCfCJBPhEAnwiAT6RAJ9IgE8kwCcS4BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM94BM9MiMOGRIH+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+EQP+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQA+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQI+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQE+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MQM+MTHf9qQBxnkQRZ5kEMeRMiDPPKggDwoIg9KyIOQM8IgZ4RBzgiDnBEGOSMMckYY5IwwyBlhkDPCIGeEQc4Ii5wRFjkjLHJGWOSMsMgZYZEzwiJnhEXOCIucERY5IxxyRjjkjHDIGeGQM8IhZ4RDzgiHnBEOOSMcckY45Iwg5Iwg5Iwg5Iwg5Iwg5Iwg5Iwg5Iwg5Iwg5Iwg5IzwyBnhkTPCI2eER84Ij5wRHjkjPHJGeOSM8MgZcewik00fD0rBVI85dpGNxxjgMfbaY/75+Nf/+29///O//ftf/vTfj0d8/x//56//8Y8//+2vH//8x//3X/v/8u9///Nf/vLn//zX//r73/7jT//nf/7+p3/9y9/+4/v/9oft+//5flK58I3Cbyt5/MM4/83Q9sfHQ833A378R7t9M9Z//4+2/Ee3fXO//SdX/tNjyc59/09U/rb/Rv7gb/v9ABu+ufLkPqdvYfvtL4TyF+w3suUv2PzNOPp+QCzPGvK3+Nt/SvtjUvyWY3nM418m2+8H5OdKvftmffp+jPltFf6bDfG3XRcu5L55V/7K41+G0m9HmPI8/lt+7m4L9O3xf/LjBXq8SP8/","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"60":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n","path":"std/uint128.nr"},"62":{"source":"use aggregation_prover::aggregate::aggregate;\nuse training_prover::train::MultiClassTrainedModel;\n\npub fn main(submitted_models: [MultiClassTrainedModel<4, 3>; 3]) {\n    let aggregated_model = aggregate(submitted_models);\n    println(\"aggregated model: \");\n    println((aggregated_model))\n}\n","path":"/Users/yurikonishijima/Development/vfl-demo/server/src/main.nr"},"63":{"source":"use noir_fixed_point::quantized::Quantized as QuantizedWithDiv; // this has a division function\nuse noir_mpc_ml::quantized::Quantized;\nuse noir_mpc_ml::utils::assert_bitsize;\nuse training_prover::train::MultiClassTrainedModel;\nuse training_prover::train::TrainedModelPerClass;\n\n// New struct definition using QuantizedWithDiv, which has division implementation\n// We switch form the original Quantized struct to this struct becuase we need to do division at the end for weighted average calculation\npub struct FinalTrainedModelPerClass<let M: u32> {\n    pub weights: [QuantizedWithDiv; M],\n    pub bias: QuantizedWithDiv,\n}\n\n// multiclass model\npub struct FinalMultiClassTrainedModel<let M: u32, let C: u32> {\n    pub models: [FinalTrainedModelPerClass<M>; C],\n    pub n_samples: Quantized,\n}\n\npub fn castToQuantizedWithDiv(q: Quantized) -> QuantizedWithDiv {\n    QuantizedWithDiv { x: q.x }\n}\n\npub fn aggregate<let M: u32, let C: u32, let L: u32>(\n    submitted_models: [MultiClassTrainedModel<M, C>; L],\n) -> FinalMultiClassTrainedModel<M, C> {\n    // Initialize temporary empty model to accumulate weighted sums for weights and bias\n    // We use original Quantized struct\n    let mut temp_aggregated_model: MultiClassTrainedModel<M, C> = MultiClassTrainedModel {\n        models: [\n            TrainedModelPerClass { weights: [Quantized::zero(); M], bias: Quantized::zero() }; C\n        ],\n        n_samples: Quantized::zero(),\n    };\n\n    // Loop over each model submitted by clients, stored in `submitted_models`\n    for client_idx in 0..L {\n        println(\"client_idx:\");\n        println(client_idx);\n        let model = submitted_models[client_idx];\n        let unscaled_n_samples = model.n_samples;\n\n        // println(\"unscaled n_samples\");\n        // println(unscaled_n_samples);\n\n        // n_samples is 20 = 5 bits at max for this demo\n        assert_bitsize::<5>(unscaled_n_samples);\n        temp_aggregated_model.n_samples += unscaled_n_samples;\n\n        // println(\"total number of samples summed up so far\");\n        // println(temp_aggregated_model.n_samples);\n\n        // Summing up weights at the same index for each class, submitted by different clients 0-2\n        //                          |class0                     | |class1                     | |class2                     |\n        // model 0 (from client 0): [w000, w001, w002, w003, b00] [w010, w011, w012, w013, b01] [w020, w021, w022, w023, b02]\n        // model 1 (from client 1): [w100, w101, w102, w103, b10] [w110, w111, w112, w113, b11] [w120, w121, w122, w123, b12]\n        // model 1 (from client 1): [w200, w201, w202, w203, b20] [w210, w211, w212, w213, b21] [w220, w221, w222, w223, b22]\n        // aggregated model       : [w000+w100+w200, w001+w101+w201,...,b00+b10+b20]...\n        for class_idx in 0..C {\n            let current = model.models[class_idx];\n\n            println(\"class_idx:\");\n            println(class_idx);\n            println(current);\n\n            // Weighted sum for each weight\n            for weight_idx in 0..M {\n                println(\"weight:\");\n                println(current.weights[weight_idx].x);\n                println(\n                    \"temp_aggregated_model.models[class_idx].weights[weight_idx].x:\",\n                );\n                println(\n                    temp_aggregated_model.models[class_idx].weights[weight_idx].x,\n                );\n\n                // max input bit size for safe addition: 125 bits\n                // directly perform operation on the Field elements inside the Quantized struct\n                assert_bitsize::<125>(temp_aggregated_model.models[class_idx].weights[weight_idx]);\n                temp_aggregated_model.models[class_idx].weights[weight_idx].x +=\n                    current.weights[weight_idx].x;\n            }\n\n            // max input bit size for safe addition: 125 bits\n            // directly perform operation on the Field elements inside the Quantized struct\n            assert_bitsize::<125>(temp_aggregated_model.models[class_idx].bias);\n            temp_aggregated_model.models[class_idx].bias.x += current.bias.x;\n        }\n    }\n\n    // Initialize empty model to be returned as a final aggregated model\n    // We need to do division so we'll use QuantizedWithDiv Struct here\n    let mut aggregated_model: FinalMultiClassTrainedModel<M, C> = FinalMultiClassTrainedModel {\n        models: [\n            FinalTrainedModelPerClass {\n                weights: [QuantizedWithDiv::zero(); M],\n                bias: QuantizedWithDiv::zero(),\n            }; C\n        ],\n        n_samples: temp_aggregated_model.n_samples,\n    };\n\n    // Divide all sums by total_samples to get weighted average\n    // Since original noir_mpc_ml::quantized::Quantized does not implement division,\n    // let's it to noir_fixed_point::quantized::Quantized first which has division function implemented.\n    for class_idx in 0..C {\n        for weight_idx in 0..M {\n            // println(\"weight_idx\");\n            // println(weight_idx);\n            aggregated_model.models[class_idx].weights[weight_idx] = castToQuantizedWithDiv(\n                temp_aggregated_model.models[class_idx].weights[weight_idx],\n            )\n                / castToQuantizedWithDiv(temp_aggregated_model.n_samples);\n        }\n        aggregated_model.models[class_idx].bias = castToQuantizedWithDiv(\n            temp_aggregated_model.models[class_idx].bias,\n        )\n            / castToQuantizedWithDiv(temp_aggregated_model.n_samples);\n    }\n\n    aggregated_model\n}\n\n","path":"/Users/yurikonishijima/Development/vfl-demo/aggregation_prover/src/aggregate.nr"},"66":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a fixed scale factor of 2^16\n// See further explanation in the `Quantized` struct comments below.\nglobal scale: Field = 65536; // 2^16\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A Field element is a type with 254 bits.\n// We only use the first 126 or the last 126 bits.\n// A positive number is within the first 126 bits.\n// A negative numbers is within the last 126 bits.\n// The \"middle\" 2 bits that are left over, should not be used.\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\n// So following above visual, x_126 and x_127 MUST be 0\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses a scale of 2^-16. This means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Overflow and overflow prevention:\n// To make sure the arithmetic performed on a value will not overflow, the library contains\n// bitsize checks that prevent numbers from growing larger than 126 bits. More concretely:\n// - multiplication: inputs must have bitsize <= 63\n// - addition: inputs must have bitsize <=125\n// - subtraction: inputs must have bitsize <=125\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\n// returns 1 for a negative element, 0 for a positive element\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// NOTE: this asserts the field contains has maximum 126 bits. If the element contains more than\n// 126 bits either way, this function cannot correctly indicate whether it's negative or not.\nfn is_negative(x: Field) -> Field {\n    let (lower_bytes, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        // Make sure the number is not overflowing the 126 bits\n        x.assert_max_bit_size::<126>();\n        0\n    } else {\n        1\n    }\n}\n\nimpl Quantized {\n    // Assert that number of bits <= bitsize\n    // if quantized is negative, it counts the bits backwards\n    // NOTE: this works only for bitsize <= 126, because decompose gives us\n    // 128 and 126 bits\n    pub fn assert_bitsize<let bitsize: u32>(self: Self) {\n        // Decomposes into two 128 bits chunks\n        let (lower_bytes, higher_bytes) = decompose(self.x);\n        if higher_bytes == 0 {\n            // positive number\n            self.x.assert_max_bit_size::<bitsize>();\n        } else {\n            // negative number\n            (-self.x).assert_max_bit_size::<bitsize>();\n        }\n    }\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        let res = Self { x: x };\n        res.assert_bitsize::<126>();\n        res\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 63 bits for both inputs\n        // Perform multiplication of the underlying field elements\n        // This doubles the scale.\n        self.assert_bitsize::<63>();\n        other.assert_bitsize::<63>();\n        let mut temp: Field = self.x * other.x;\n\n        // Scale down by dividing by 2^16\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the division doesn't work\n\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\n        // Cast x to a u16 to preserve only the lowest 16 bits.\n        let lowest_16_bits = temp as u16;\n\n        // Subtract off the lowest 16 bits so they are cleared.\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\n\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n        // therefore field division is equivalent to integer division.\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\n\n        // If the result was originally negative, flip the sign back\n        final_res = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - final_res\n                    + 1\n                    - final_res\n            )\n            + final_res;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: final_res }\n    }\n\n    fn div(self: Self, other: Self) -> Self {\n        // Ensure `other` is not zero\n        assert(other.x != 0, \"Division by zero is not allowed.\");\n        self.assert_bitsize::<109>(); // will be multiplied by scale later, so we allow 126-17 bits\n        other.assert_bitsize::<126>(); // standard bitsize check\n        // Flip signs of numerator and denominator if negative, work with their absolute values\n        let mut numerator = self.x;\n        let mut denominator = other.x;\n\n        let mut numerator_is_negative = is_negative(numerator);\n        let mut denominator_is_negative = is_negative(denominator);\n\n        numerator = numerator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - numerator\n                    + 1\n                    - numerator\n            )\n            + numerator;\n\n        denominator = denominator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - denominator\n                    + 1\n                    - denominator\n            )\n            + denominator;\n\n        // Scale numerator before division\n        let scaled_numerator = numerator * scale;\n\n        // Cast to U128 for division\n        let scaled_numerator_u128 = U128::from_le_bytes(scaled_numerator.to_le_bytes());\n        let denominator_u128 = U128::from_le_bytes(denominator.to_le_bytes());\n\n        // Perform the division in U128\n        let result_u128 = scaled_numerator_u128 / denominator_u128;\n\n        // Cast back to Field\n        let mut result = Field::from_le_bytes(result_u128.to_le_bytes());\n\n        // Determine the sign of the result\n        let result_is_negative = numerator_is_negative + denominator_is_negative == 1;\n\n        // If result is negative, flip sign back\n        if result_is_negative {\n            result = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - result\n                + 1;\n        }\n\n        Quantized { x: result }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Div for Quantized {\n    fn div(self, other: Self) -> Self {\n        self.div(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        } else {\n            let (_, sub_hi) = decompose(self.x - other.x);\n            if sub_hi == 0 {\n                Ordering::greater()\n            } else {\n                Ordering::less()\n            }\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n\n#[test]\nfn test_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Division with small positive values\n    let a1 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b1 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result1 = a1 / b1; // 1.5 / 1.0 = 1.5\n    assert(result1.x == 98304); // Scaled result for 1.5\n\n    // Test case 2: Division resulting in a smaller value\n    let a2 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let b2 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let result2 = a2 / b2; // 1.0 / 1.5 = 0.666...\n    assert(result2.x == 43690); // Scaled result for ~0.6667\n\n    // Test case 3: Negative divided by positive\n    let a3 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b3 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result3 = a3 / b3; // -1.5 / 1.0 = -1.5\n    assert(result3.x == p - 98304); // Correctly negative\n\n    // Test case 4: Positive divided by negative\n    let a4 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b4 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result4 = a4 / b4; // 1.5 / -1.0 = -1.5\n    assert(result4.x == p - 98304); // Correctly negative\n\n    // Test case 5: Both negative values\n    let a5 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b5 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result5 = a5 / b5; // -1.5 / -1.0 = 1.5\n    assert(result5.x == 98304); // Scaled result for 1.5\n}\n\n#[test]\nfn test_large_values_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Large positive values\n    let a1 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b1 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result1 = a1 / b1; // 17592186044416.0 / 8796093022208.0 = 2.0\n    assert(result1.x == 131072); // Scaled result for 2.0\n\n    // Test case 2: Large positive divided by a larger positive\n    let a2 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let b2 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let result2 = a2 / b2; // 8796093022208.0 / 17592186044416.0 = 0.5\n    assert(result2.x == 32768); // Scaled result for 0.5\n\n    // Test case 3: Large negative divided by large positive\n    let a3 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b3 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result3 = a3 / b3; // -17592186044416.0 / 8796093022208.0 = -2.0\n    assert(result3.x == p - 131072); // Correctly negative\n\n    // Test case 4: Large positive divided by large negative\n    let a4 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b4 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result4 = a4 / b4; // 17592186044416.0 / -8796093022208.0 = -2.0\n    assert(result4.x == p - 131072); // Correctly negative\n\n    // Test case 5: Both large negative values\n    let a5 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b5 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result5 = a5 / b5; // -17592186044416.0 / -8796093022208.0 = 2.0\n    assert(result5.x == 131072); // Scaled result for 2.0\n}\n\n#[test(should_fail)]\nfn test_division_by_zero() -> Quantized {\n    Quantized { x: 65536 } / Quantized { x: 0 }\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-fixed-point/main/src/quantized.nr"},"70":{"source":"use super::quantized::{is_negative, Quantized};\nuse std::field::bn254::decompose;\n\n// returns x * 2^-16, interpreted as an integer\n// Scaling down is needed for example after multiplying 2 Quantized values\npub fn scale_down(x: Field) -> Field {\n    let mut z = x;\n\n    let negative = is_negative(z);\n\n    z = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - z + 1\n                - z\n        )\n        + z;\n\n    // Division by 2^16, code as suggested by Tom French @TomAFrench\n    // Cast x to a u16 to preserve only the lowest 16 bits.\n    let lowest_16_bits = z as u16;\n\n    // Subtract off the lowest 16 bits so they are cleared.\n    let x_with_cleared_lower_bits = z - lowest_16_bits as Field;\n\n    // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n    // therefore field division is equivalent to integer division.\n    let mut new_x: Field = x_with_cleared_lower_bits / 65536;\n\n    // Flip back sign if the output is negative\n    new_x = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - new_x\n                + 1\n                - new_x\n        )\n        + new_x;\n\n    new_x\n}\n\n// Assert that number of bits <= bitsize\n// if quantized is negative, it count the bits backwards\npub fn assert_bitsize<let bitsize: u32>(q: Quantized) {\n    // Decomposes into two 128 bits chunks\n    let (_, higher_bytes) = decompose(q.x);\n    if higher_bytes == 0 {\n        // positive number\n        q.x.assert_max_bit_size::<bitsize>();\n    } else {\n        // negative number\n        (-q.x).assert_max_bit_size::<bitsize>();\n    }\n}\n\n#[test]\nfn test_assert_bitsize() {\n    // 4 bits\n    assert_bitsize::<4>(Quantized { x: 10 });\n    assert_bitsize::<4>(Quantized { x: -10 });\n\n    // 100 bits\n    assert_bitsize::<100>(Quantized { x: 1267650600228229401496703205375 });\n    assert_bitsize::<100>(Quantized { x: -1267650600228229401496703205375 });\n\n    // 127 bits\n    assert_bitsize::<127>(Quantized { x: 170141183460469231731687303715884105727 });\n    assert_bitsize::<127>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: 1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127_neg() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: -1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize1() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: 10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize2() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: -10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize3() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: 1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize4() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: -1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize5() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: 170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize6() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-mpc-ml/v0.1.2/src/utils.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","decompose_hint","lte_hint","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","unconstrained_div","print_unconstrained","print_unconstrained","directive_invert","directive_to_radix","directive_integer_quotient"]}