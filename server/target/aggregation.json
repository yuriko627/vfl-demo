{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":4461902422937622208,"abi":{"parameters":[{"name":"submitted_models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::MultiClassTrainedModel","fields":[{"name":"models","type":{"kind":"array","length":3,"type":{"kind":"struct","path":"training_prover::train::TrainedModelPerClass","fields":[{"name":"weights","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}},{"name":"bias","type":{"kind":"struct","path":"aggregation_prover::noir_mpc_ml::quantized::Quantized","fields":[{"name":"x","type":{"kind":"field"}}]}}]}}},{"name":"n_samples","type":{"kind":"field"}}]}},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9174856516895611197":{"error_kind":"string","string":"Division by zero is not allowed."},"16646908709298801123":{"error_kind":"string","string":"attempt to subtract with underflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"60":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                /// Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        /// Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        /// Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        /// Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        /// Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        /// Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n","path":"std/uint128.nr"},"62":{"source":"use aggregation_prover::aggregate::aggregate;\nuse training_prover::train::MultiClassTrainedModel;\n\npub fn main(submitted_models: [MultiClassTrainedModel<4, 3>; 3]) {\n    let aggregated_model = aggregate(submitted_models);\n    println(\"aggregated model: \");\n    println((aggregated_model))\n}\n","path":"/Users/yurikonishijima/Development/vfl-demo/server/src/main.nr"},"63":{"source":"use noir_fixed_point::quantized::Quantized as QuantizedWithDiv; // this has division function\nuse noir_mpc_ml::quantized::Quantized;\nuse noir_mpc_ml::utils::assert_bitsize;\nuse training_prover::train::MultiClassTrainedModel;\nuse training_prover::train::TrainedModelPerClass;\n\n// New struct definition using QuantizedWithDiv, which has division implementation\n// We switch form the original Quantized struct to this struct becuase we need to do division at the end when we do weighted average calculation\npub struct FinalTrainedModelPerClass<let M: u32> {\n    pub weights: [QuantizedWithDiv; M],\n    pub bias: QuantizedWithDiv,\n}\n\n// multiclass model\npub struct FinalMultiClassTrainedModel<let M: u32, let C: u32> {\n    pub models: [FinalTrainedModelPerClass<M>; C],\n    pub n_samples: Field,\n}\n\npub fn castToQuantizedWithDiv(q: Quantized) -> QuantizedWithDiv {\n    QuantizedWithDiv { x: q.x }\n}\n\npub fn aggregate<let M: u32, let C: u32, let L: u32>(\n    submitted_models: [MultiClassTrainedModel<M, C>; L],\n) -> FinalMultiClassTrainedModel<M, C> {\n    // Initialize temporary empty model to accumulate weighted sums\n    // We use original Quantized struct\n    let mut temp_aggregated_model: MultiClassTrainedModel<M, C> = MultiClassTrainedModel {\n        models: [\n            TrainedModelPerClass { weights: [Quantized::zero(); M], bias: Quantized::zero() }; C\n        ],\n        n_samples: Field::from(0),\n    };\n\n    let mut total_samples = Field::from(0);\n\n    // Loop over each model submitted by clients, stored in `submitted_models`\n    for i in 0..L {\n        println(\"model\");\n        println(i);\n        let model = submitted_models[i];\n        let n_samples = model.n_samples;\n        total_samples += n_samples;\n\n        println(\"n_samples\");\n        println((Quantized::new(n_samples * 65536))); // fixed scale factor of 2^16 for fixed-point arithmetic\n        assert_bitsize::<21>(Quantized::new(n_samples * 65536));\n\n        // For each class in this model\n        for class_idx in 0..C {\n            let current = model.models[class_idx];\n\n            println(\"class_idx\");\n            println(class_idx);\n            println(current);\n\n            // Weighted sum for each weight\n            for weight_idx in 0..M {\n                println(\"weight\");\n                println(current.weights[weight_idx]);\n                // since n_samples is already constrained to be < 21 bits,\n                // weights can be max 125 - 21 = 104 bits\n                assert_bitsize::<104>(current.weights[weight_idx]);\n\n                // max bit size for safe addition: 125 bits\n                let weighted_sum = current.weights[weight_idx] * (Quantized::new(n_samples));\n                // assert_bitsize::<105>(weighted_sum);\n                println(\"weighted sum\");\n                println(weighted_sum);\n\n                temp_aggregated_model.models[class_idx].weights[weight_idx] += weighted_sum;\n            }\n\n            // Weighted add for the bias\n            temp_aggregated_model.models[class_idx].bias +=\n                current.bias * (Quantized::new(n_samples));\n        }\n    }\n\n    println(\"temp aggeregated model: \");\n    println(temp_aggregated_model);\n\n    // Initialize empty model to be returned as an aggregated model\n    // We need to do division so we'll use QuantizedWithDiv Struct here\n    let mut aggregated_model: FinalMultiClassTrainedModel<M, C> = FinalMultiClassTrainedModel {\n        models: [\n            FinalTrainedModelPerClass {\n                weights: [QuantizedWithDiv::zero(); M],\n                bias: QuantizedWithDiv::zero(),\n            }; C\n        ],\n        n_samples: Field::from(0),\n    };\n\n    // Divide all sums by total_samples to get weighted average\n    // Since original noir_mpc_ml::quantized::Quantized does not implement division,\n    // let's it to noir_fixed_point::quantized::Quantized first which has division function implemented.\n    for class_idx in 0..C {\n        for weight_idx in 0..M {\n            aggregated_model.models[class_idx].weights[weight_idx] = castToQuantizedWithDiv(\n                temp_aggregated_model.models[class_idx].weights[weight_idx],\n            )\n                / QuantizedWithDiv::new(total_samples);\n        }\n        aggregated_model.models[class_idx].bias = castToQuantizedWithDiv(\n            temp_aggregated_model.models[class_idx].bias,\n        )\n            / QuantizedWithDiv::new(total_samples);\n    }\n\n    aggregated_model\n}\n\n","path":"/Users/yurikonishijima/Development/vfl-demo/aggregation_prover/src/aggregate.nr"},"66":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a fixed scale factor of 2^16\n// See further explanation in the `Quantized` struct comments below.\nglobal scale: Field = 65536; // 2^16\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A Field element is a type with 254 bits.\n// We only use the first 126 or the last 126 bits.\n// A positive number is within the first 126 bits.\n// A negative numbers is within the last 126 bits.\n// The \"middle\" 2 bits that are left over, should not be used.\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\n// So following above visual, x_126 and x_127 MUST be 0\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses a scale of 2^-16. This means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Overflow and overflow prevention:\n// To make sure the arithmetic performed on a value will not overflow, the library contains\n// bitsize checks that prevent numbers from growing larger than 126 bits. More concretely:\n// - multiplication: inputs must have bitsize <= 63\n// - addition: inputs must have bitsize <=125\n// - subtraction: inputs must have bitsize <=125\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\n// returns 1 for a negative element, 0 for a positive element\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// NOTE: this asserts the field contains has maximum 126 bits. If the element contains more than\n// 126 bits either way, this function cannot correctly indicate whether it's negative or not.\nfn is_negative(x: Field) -> Field {\n    let (lower_bytes, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        // Make sure the number is not overflowing the 126 bits\n        x.assert_max_bit_size::<126>();\n        0\n    } else {\n        // The higher bytes are filled, but we also have to make sure the\n        // lower bytes are not\n        assert(lower_bytes == 0);\n        1\n    }\n}\n\nimpl Quantized {\n    // Assert that number of bits <= bitsize\n    // if quantized is negative, it counts the bits backwards\n    // NOTE: this works only for bitsize <= 126, because decompose gives us\n    // 128 and 126 bits\n    pub fn assert_bitsize<let bitsize: u32>(self: Self) {\n        // Decomposes into two 128 bits chunks\n        let (lower_bytes, higher_bytes) = decompose(self.x);\n        if higher_bytes == 0 {\n            // positive number\n            self.x.assert_max_bit_size::<bitsize>();\n        } else {\n            // The higher bytes are filled, but we also have to make sure the\n            // lower bytes are not\n            assert(lower_bytes == 0);\n            // negative number\n            (-self.x).assert_max_bit_size::<bitsize>();\n        }\n    }\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        let res = Self { x: x };\n        res.assert_bitsize::<126>();\n        res\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 125 bits for both inputs\n        self.assert_bitsize::<125>();\n        other.assert_bitsize::<125>();\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        // To prevent overflow, allow max 63 bits for both inputs\n        // Perform multiplication of the underlying field elements\n        // This doubles the scale.\n        self.assert_bitsize::<63>();\n        other.assert_bitsize::<63>();\n        let mut temp: Field = self.x * other.x;\n\n        // Scale down by dividing by 2^16\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the division doesn't work\n\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\n        // Cast x to a u16 to preserve only the lowest 16 bits.\n        let lowest_16_bits = temp as u16;\n\n        // Subtract off the lowest 16 bits so they are cleared.\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\n\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n        // therefore field division is equivalent to integer division.\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\n\n        // If the result was originally negative, flip the sign back\n        final_res = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - final_res\n                    + 1\n                    - final_res\n            )\n            + final_res;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: final_res }\n    }\n\n    fn div(self: Self, other: Self) -> Self {\n        // Ensure `other` is not zero\n        assert(other.x != 0, \"Division by zero is not allowed.\");\n        self.assert_bitsize::<109>(); // will be multiplied by scale later, so we allow 126-17 bits\n        other.assert_bitsize::<126>(); // standard bitsize check\n        // Flip signs of numerator and denominator if negative, work with their absolute values\n        let mut numerator = self.x;\n        let mut denominator = other.x;\n\n        let mut numerator_is_negative = is_negative(numerator);\n        let mut denominator_is_negative = is_negative(denominator);\n\n        numerator = numerator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - numerator\n                    + 1\n                    - numerator\n            )\n            + numerator;\n\n        denominator = denominator_is_negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - denominator\n                    + 1\n                    - denominator\n            )\n            + denominator;\n\n        // Scale numerator before division\n        let scaled_numerator = numerator * scale;\n\n        // Cast to U128 for division\n        let scaled_numerator_u128 = U128::from_le_bytes(scaled_numerator.to_le_bytes());\n        let denominator_u128 = U128::from_le_bytes(denominator.to_le_bytes());\n\n        // Perform the division in U128\n        let result_u128 = scaled_numerator_u128 / denominator_u128;\n\n        // Cast back to Field\n        let mut result = Field::from_le_bytes(result_u128.to_le_bytes());\n\n        // Determine the sign of the result\n        let result_is_negative = numerator_is_negative + denominator_is_negative == 1;\n\n        // If result is negative, flip sign back\n        if result_is_negative {\n            result = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - result\n                + 1;\n        }\n\n        Quantized { x: result }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Div for Quantized {\n    fn div(self, other: Self) -> Self {\n        self.div(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if (self.x == other.x) {\n            Ordering::equal()\n        } else if (decompose(self.x - other.x).1 == 0) {\n            Ordering::greater()\n        } else {\n            Ordering::less()\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n\n#[test]\nfn test_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Division with small positive values\n    let a1 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b1 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result1 = a1 / b1; // 1.5 / 1.0 = 1.5\n    assert(result1.x == 98304); // Scaled result for 1.5\n\n    // Test case 2: Division resulting in a smaller value\n    let a2 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let b2 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let result2 = a2 / b2; // 1.0 / 1.5 = 0.666...\n    assert(result2.x == 43690); // Scaled result for ~0.6667\n\n    // Test case 3: Negative divided by positive\n    let a3 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b3 = Quantized { x: 65536 }; // Represents 1.0 (scaled)\n    let result3 = a3 / b3; // -1.5 / 1.0 = -1.5\n    assert(result3.x == p - 98304); // Correctly negative\n\n    // Test case 4: Positive divided by negative\n    let a4 = Quantized { x: 98304 }; // Represents 1.5 (scaled)\n    let b4 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result4 = a4 / b4; // 1.5 / -1.0 = -1.5\n    assert(result4.x == p - 98304); // Correctly negative\n\n    // Test case 5: Both negative values\n    let a5 = Quantized { x: p - 98304 }; // Represents -1.5 (scaled)\n    let b5 = Quantized { x: p - 65536 }; // Represents -1.0 (scaled)\n    let result5 = a5 / b5; // -1.5 / -1.0 = 1.5\n    assert(result5.x == 98304); // Scaled result for 1.5\n}\n\n#[test]\nfn test_large_values_division() {\n    // Field modulus\n    let p: Field = 0;\n\n    // Test case 1: Large positive values\n    let a1 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b1 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result1 = a1 / b1; // 17592186044416.0 / 8796093022208.0 = 2.0\n    assert(result1.x == 131072); // Scaled result for 2.0\n\n    // Test case 2: Large positive divided by a larger positive\n    let a2 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let b2 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let result2 = a2 / b2; // 8796093022208.0 / 17592186044416.0 = 0.5\n    assert(result2.x == 32768); // Scaled result for 0.5\n\n    // Test case 3: Large negative divided by large positive\n    let a3 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b3 = Quantized { x: 576460752303423488 }; // Represents 8796093022208.0 (scaled)\n    let result3 = a3 / b3; // -17592186044416.0 / 8796093022208.0 = -2.0\n    assert(result3.x == p - 131072); // Correctly negative\n\n    // Test case 4: Large positive divided by large negative\n    let a4 = Quantized { x: 1152921504606846976 }; // Represents 17592186044416.0 (scaled)\n    let b4 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result4 = a4 / b4; // 17592186044416.0 / -8796093022208.0 = -2.0\n    assert(result4.x == p - 131072); // Correctly negative\n\n    // Test case 5: Both large negative values\n    let a5 = Quantized { x: p - 1152921504606846976 }; // Represents -17592186044416.0 (scaled)\n    let b5 = Quantized { x: p - 576460752303423488 }; // Represents -8796093022208.0 (scaled)\n    let result5 = a5 / b5; // -17592186044416.0 / -8796093022208.0 = 2.0\n    assert(result5.x == 131072); // Scaled result for 2.0\n}\n\n#[test(should_fail)]\nfn test_division_by_zero() -> Quantized {\n    Quantized { x: 65536 } / Quantized { x: 0 }\n}\n","path":"/Users/yurikonishijima/Development/noir-fixed-point/src/quantized.nr"},"69":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Div, Mul, Sub};\n\n// IMPORTANT: This library is designed to work with a scale factor of 2^(8*factor).\nglobal scale: Field = 65536; // 2^(8*2) = 2^16\n\n// NOTE: this is a version of the noir-fixed-point library without overflow checks\n// Ref: https://github.com/hashcloak/noir-fixed-point/\n// The ML functionality of this larger library take care of the necessary overflow checks\n// which makes the whole more performant.\n// This version also doesn't contain the `div` function, since it's not needed.\n\n// A signed fixed-point number `x` is represented in a single Field element.\n//\n// Representation Overview:\n// A Field element is a type with 254 bits.\n// We only use the first 126 or the last 126 bits.\n// A positive number is within the first 126 bits.\n// A negative numbers is within the last 126 bits.\n// The \"middle\" 2 bits that are left over, should not be used.\n// - Positive values have bits set in the lower part: |x_0,x_1,x_2,..,x_125, ... ,_,_,_,_|\n// - Negative values have bits set in the upper part: |_,_,_,_, .. x_128,x_129,..,x_253|\n// So following above visual, x_126 and x_127 MUST be 0\n//\n// Modular arithmetic ensures correct handling of signed fixed-point numbers by wrapping\n// values around the field's modulus. For example, subtracting 5 from 3 in a field with\n// modulus `p` results in (3 - 5) mod p = p - 2, representing -2. This behavior allows\n// negative values to be correctly encoded in the field's upper range.\n//\n// Scaling:\n// Since fields do not inherently support decimal values, the fixed-point representation\n// uses a scale of 2^-16. This means that:\n// - `Quantized { x: 1 }` represents the value 1/2^16.\n// - To represent an original value, divide it by the scale, truncate, and store the result.\n// Example:\n// - Original value: 0.001\n// - Scaled value: 0.001 * 2^16 = 65.536\n// - Truncated result: 65 (stored as `Quantized { x: 65 }`)\n//\n// Conversion Steps to `Quantized`:\n// 1. Check if the original value `x` is negative. If negative, use (p - |x|), where `p` is\n//    the field's prime modulus. Otherwise, proceed with `x`.\n// 2. Multiply the value by the scale factor (e.g., 2^16).\n// 3. Store the scaled value in a `Quantized` struct.\n//\n// Prime Modulus:\n// The field modulus `p` used in this implementation is:\n//   p = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// This prime comes from the Barretenberg backend.\npub struct Quantized {\n    pub x: Field,\n}\n\n// returns 1 for a negative element, 0 for a positive element\n// A Quantized element is negative if the upper bits are set, so this is what we check for.\n// NOTE: Make sure that the value that the field contains has maximum 126 bits.\n// If the element contains more than 126 bits either way, this function cannot correctly indicate\n// whether it's negative or not.\npub fn is_negative(x: Field) -> Field {\n    let (_, higher_bytes) = decompose(x);\n    if higher_bytes == 0 {\n        0\n    } else {\n        1\n    }\n}\n\nimpl Quantized {\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        Self { x: x }\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        let mut temp: Field = self.x * other.x;\n\n        // Scale down by dividing by 2^16\n        // Since the scale is a multiple of 2^8, this will scale it down correctly.\n        // Note that we have to take care of the case that the value is negative; in that case we flip the sign\n        // temporarily, and flip it back at the end. Otherwise the division doesn't work\n\n        // Check whether we're working with a negative value\n        let negative = is_negative(temp);\n\n        temp = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616 - temp\n                    + 1\n                    - temp\n            )\n            + temp;\n\n        // Division by 2^16, code as suggested by Tom French @TomAFrench\n        // Cast x to a u16 to preserve only the lowest 16 bits.\n        let lowest_16_bits = temp as u16;\n\n        // Subtract off the lowest 16 bits so they are cleared.\n        let temp_with_cleared_lower_bits = temp - lowest_16_bits as Field;\n\n        // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n        // therefore field division is equivalent to integer division.\n        let mut final_res: Field = temp_with_cleared_lower_bits / 65536;\n\n        // If the result was originally negative, flip the sign back\n        final_res = negative\n            * (\n                21888242871839275222246405745257275088548364400416034343698204186575808495616\n                    - final_res\n                    + 1\n                    - final_res\n            )\n            + final_res;\n\n        // Return the result as a new Quantized instance\n        Quantized { x: final_res }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Ord for Quantized {\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        } else {\n            let (_, sub_hi) = decompose(self.x - other.x);\n            if (sub_hi == 0) {\n                Ordering::greater()\n            } else {\n                Ordering::less()\n            }\n        }\n    }\n}\n\n#[test]\nfn test_order() {\n    // Test 1: comparison between positive and negative value.\n    // a = 0.2 and b = -0.2\n    let a: Field = 13107;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 2: comparison between two possitive numbers.\n    // a = 1 and b = 0.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 13107;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized > b_quantized);\n\n    // Test 3: comparison between two possitive numbers where the roles are\n    // inverted.\n    // a = 1 and b = 1.2.\n    // Then a * 2^16 = 65536\n    let a: Field = 65536;\n    let a_quantized = Quantized { x: a };\n    let b = 78643;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // Test 4: comparison between two negative numbers.\n    // a = -1 and b = -0.2.\n    // Then a * 2^16 = -65536 therefore taking mod p we obtain that\n    // a = 21888242871839275222246405745257275088548364400416034343698204186575808430081\n    // b = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a: Field = 21888242871839275222246405745257275088548364400416034343698204186575808430081;\n    let a_quantized = Quantized { x: a };\n    let b = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    let b_quantized = Quantized { x: b };\n    assert(a_quantized < b_quantized);\n\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001\n    // - 32768\n    // 21888242871839275222246405745257275088548364400416034343698204186575808495617 - 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001\n    let a = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593efff8001 };\n    // - 327680\n    let b = Quantized { x: 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593effb0001 };\n    assert(a > b);\n}\n\n#[test]\nfn test_is_negative() {\n    // Test 1: checking if it's negative for a positive value.\n    // a = 0.2   =>   0.2 * 2^16 = 13107\n    let a: Field = 13107;\n    assert(is_negative(a) == 0);\n\n    // Test 2: checking if it's negative for a negative value.\n    // a = -0.2  =>   -0.2 * 2^16 = -13107\n    // Hence, -13107 mod p = p - 13107 = 21888242871839275222246405745257275088548364400416034343698204186575808482510\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575808482510;\n    assert(is_negative(a) == 1);\n\n    // Test 3: checing if it's negative for a negative larger value.\n    // a = -1301.34  =>  -1301.34 * 2^16 = -85284618\n    // Hence, -85284618 mod p = p - 85284618 = 21888242871839275222246405745257275088548364400416034343698204186575723210999\n    let a = 21888242871839275222246405745257275088548364400416034343698204186575723210999;\n    assert(is_negative(a) == 1);\n}\n\n#[test]\nfn test_add() {\n    // Max value 2^60-1, positive and negative\n    let a = 1152921504606846975;\n    let b = -1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized + b_quantized;\n    assert(addition_quantized.x == 0);\n\n    // Test case 1: Max value 2^60 - 1, positive and zero\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized + b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    // Test case 2: Small positive values\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n\n    // Test case 3: Positive and negative values resulting in a non-zero positive result\n    let a3 = 50000;\n    let b3 = -30000;\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    let addition3_quantized = a3_quantized + b3_quantized;\n    assert(addition3_quantized.x == 20000);\n\n    // Test case 4: Positive and negative values resulting in a non-zero negative result\n    let a4 = 30000;\n    let b4 = -50000;\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n    let addition4_quantized = a4_quantized + b4_quantized;\n    assert(addition4_quantized.x == -20000);\n\n    // Test case 5: Add two negative values resulting in a negative value\n    let a5 = -40000;\n    let b5 = -20000;\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    let addition5_quantized = a5_quantized + b5_quantized;\n    assert(addition5_quantized.x == -60000);\n}\n\n#[test]\nfn test_mul() {\n    // Test case 1: Small positive values\n    let a1 = 12345; // original value 12345/2^16 = 0.1883697509765625\n    let b1 = 67890; // original value 67890/2^16 = 1.035919189453125\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    // new value = 0.1883697509765625 * 1.035919189453125 = 0.1951358397491276264190673828125\n    // x = 0.1951358397491276264190673828125 * 2^16 = 12788.422393798828125 => 12788\n    let mult1_quantized = a1_quantized * b1_quantized;\n    assert(mult1_quantized.x == 12788);\n\n    // Test case 2: Large positive values\n    let a2 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b2 = 2; // original 2/2^16 = 0.000030517578125\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let mult2_quantized = a2_quantized * b2_quantized;\n    // 17592186044415.9999847412109375 * 0.000030517578125 = 536870911.9999999995343387126922607421875\n    // x/2^16 = value;  mult by 2^16 and truncate to whole number => x = 35184372088831\n    assert(mult2_quantized.x == 35184372088831);\n\n    // Test case 3: Large positive and small positive value\n    let a3 = 1152921504606846975; // Max value 2^60 - 1, original 1152921504606846975/2^16 = 17592186044415.9999847412109375\n    let b3 = 1; // original value 1/2^16 = 0.0000152587890625\n    let a3_quantized = Quantized { x: a3 };\n    let b3_quantized = Quantized { x: b3 };\n    // mul = 17592186044415.9999847412109375 * 0.0000152587890625 = 268435455.99999999976716935634613037109375\n    let mult3_quantized = a3_quantized * b3_quantized;\n    // mul * 2^16 = 17592186044415.9999847412109375\n    assert(mult3_quantized.x == 17592186044415);\n\n    // Test case 4: Positive and negative value\n    let a4 = 40000; // Original value 40000/2^16 = 0.6103515625\n    let b4 = -30000; // Original value -0.457763671875\n    let a4_quantized = Quantized { x: a4 };\n    let b4_quantized = Quantized { x: b4 };\n\n    // 0.6103515625 * -0.457763671875 = -0.2793967723846435546875\n    let mult4_quantized = a4_quantized * b4_quantized;\n    // -0.2793967723846435546875 * 2^16 = -18310.546875\n    assert(mult4_quantized.x == -18310);\n\n    // Test case 5: Both values negative\n    let a5 = -40000; // Original value -40000 / 2^16 = -0.6103515625\n    let b5 = -20000; // -0.30517578125\n    let a5_quantized = Quantized { x: a5 };\n    let b5_quantized = Quantized { x: b5 };\n    // -0.6103515625 *  -0.30517578125 = 0.186264514923095703125\n    let mult5_quantized = a5_quantized * b5_quantized;\n    // Expected result: 12207.03125\n    assert(mult5_quantized.x == 12207);\n}\n\n#[test]\nfn test_sub() {\n    let a = 1152921504606846975;\n    let b = 1152921504606846975;\n    let a_quantized = Quantized { x: a };\n    let b_quantized = Quantized { x: b };\n    let addition_quantized = a_quantized - b_quantized;\n    assert(addition_quantized.x == 0);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = a1_quantized - b1_quantized;\n    assert(addition1_quantized.x == a1);\n\n    let a1 = 1152921504606846975;\n    let b1 = 0;\n    let a1_quantized = Quantized { x: a1 };\n    let b1_quantized = Quantized { x: b1 };\n    let addition1_quantized = b1_quantized - a1_quantized;\n    // The result should be -a1, which means it is p - a1 in the field because\n    // of the wrap around.\n    let result = 21888242871839275222246405745257275088548364400416034343697051265071201648642;\n    assert(addition1_quantized.x == result);\n\n    let a2 = 12345;\n    let b2 = 67890;\n    let a2_quantized = Quantized { x: a2 };\n    let b2_quantized = Quantized { x: b2 };\n    let addition2_quantized = a2_quantized + b2_quantized;\n    assert(addition2_quantized.x == (a2 + b2));\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-mpc-ml/v0.1.2/src/quantized.nr"},"70":{"source":"use super::quantized::{is_negative, Quantized};\nuse std::field::bn254::decompose;\n\n// returns x * 2^-16, interpreted as an integer\n// Scaling down is needed for example after multiplying 2 Quantized values\npub fn scale_down(x: Field) -> Field {\n    let mut z = x;\n\n    let negative = is_negative(z);\n\n    z = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - z + 1\n                - z\n        )\n        + z;\n\n    // Division by 2^16, code as suggested by Tom French @TomAFrench\n    // Cast x to a u16 to preserve only the lowest 16 bits.\n    let lowest_16_bits = z as u16;\n\n    // Subtract off the lowest 16 bits so they are cleared.\n    let x_with_cleared_lower_bits = z - lowest_16_bits as Field;\n\n    // The lowest 16 bits are clear, `x_with_cleared_lower_bits` is divisible by `65536`,\n    // therefore field division is equivalent to integer division.\n    let mut new_x: Field = x_with_cleared_lower_bits / 65536;\n\n    // Flip back sign if the output is negative\n    new_x = negative\n        * (\n            21888242871839275222246405745257275088548364400416034343698204186575808495616 - new_x\n                + 1\n                - new_x\n        )\n        + new_x;\n\n    new_x\n}\n\n// Assert that number of bits <= bitsize\n// if quantized is negative, it count the bits backwards\npub fn assert_bitsize<let bitsize: u32>(q: Quantized) {\n    // Decomposes into two 128 bits chunks\n    let (_, higher_bytes) = decompose(q.x);\n    if higher_bytes == 0 {\n        // positive number\n        q.x.assert_max_bit_size::<bitsize>();\n    } else {\n        // negative number\n        (-q.x).assert_max_bit_size::<bitsize>();\n    }\n}\n\n#[test]\nfn test_assert_bitsize() {\n    // 4 bits\n    assert_bitsize::<4>(Quantized { x: 10 });\n    assert_bitsize::<4>(Quantized { x: -10 });\n\n    // 100 bits\n    assert_bitsize::<100>(Quantized { x: 1267650600228229401496703205375 });\n    assert_bitsize::<100>(Quantized { x: -1267650600228229401496703205375 });\n\n    // 127 bits\n    assert_bitsize::<127>(Quantized { x: 170141183460469231731687303715884105727 });\n    assert_bitsize::<127>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: 1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize127_neg() {\n    // 131 bits\n    assert_bitsize::<127>(Quantized { x: -1361129467683753853853498429727072845824 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize1() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: 10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize2() {\n    // 4 bits\n    assert_bitsize::<3>(Quantized { x: -10 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize3() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: 1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize4() {\n    // 100 bits\n    assert_bitsize::<99>(Quantized { x: -1267650600228229401496703205375 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize5() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: 170141183460469231731687303715884105727 });\n}\n\n#[test(should_fail)]\nfn test_fail_assert_bitsize6() {\n    // 127 bits\n    assert_bitsize::<126>(Quantized { x: -170141183460469231731687303715884105727 });\n}\n","path":"/Users/yurikonishijima/nargo/github.com/hashcloak/noir-mpc-ml/v0.1.2/src/utils.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","decompose_hint","lte_hint","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","unconstrained_div","print_unconstrained","print_unconstrained","directive_invert","directive_integer_quotient","directive_to_radix"]}